{
  "repo": {
    "name": "3Hren/blackhole",
    "buggy_commit": "e043fa9933fd4106248f46968ad2ddfbf85d29af",
    "fixed_commit": "12e0c6a84d91b499ef04fa9b503409af44437501"
  },
  "input": {
    "language": "C++",
    "issue": {
      "issue_title": "Return back newline option for JSON formatter",
      "issue_description": ""
    },
    "buggy_commit_message": "feat(sink/udp): implement factory\n\nCloses #88.",
    "buggy_file": {
      "buggy_filename": "src/formatter/json.cpp",
      "buggy_code": "#include \"blackhole/formatter/json.hpp\"\n\n#include <array>\n#include <set>\n#include <unordered_map>\n\n#include <boost/optional/optional.hpp>\n#include <boost/variant/apply_visitor.hpp>\n\n#ifndef RAPIDJSON_HAS_STDSTRING\n#define RAPIDJSON_HAS_STDSTRING 1\n#endif\n#include <rapidjson/document.h>\n#include <rapidjson/stringbuffer.h>\n#include <rapidjson/writer.h>\n#include <rapidjson/pointer.h>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/record.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\nnamespace {\n\nstruct visitor_t {\n    typedef void result_type;\n\n    rapidjson::Value& node;\n    rapidjson::MemoryPoolAllocator<>& allocator;\n\n    const string_view& name;\n\n    auto operator()(std::nullptr_t) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), rapidjson::kNullType, allocator);\n    }\n\n    // For `bool`, `std::int64_t`, `std::uint64_t` and `double` types.\n    template<typename T>\n    auto operator()(T value) -> void {\n        static_assert(\n            std::is_same<T, bool>::value ||\n            std::is_same<T, std::int64_t>::value ||\n            std::is_same<T, std::uint64_t>::value ||\n            std::is_same<T, double>::value, \"type mismatch\");\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), value, allocator);\n    }\n\n    auto operator()(const string_view& value) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            rapidjson::StringRef(value.data(), value.size()), allocator);\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) -> void {\n        writer_t wr;\n        value(wr);\n\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            wr.result().to_string(), allocator);\n    }\n};\n\n/// A RapidJSON Stream concept implementation required to avoid intermediate buffer allocation.\nstruct stream_t {\n    typedef char Ch;\n\n    writer_t& wr;\n\n    /// Writes a character directly into the underlying buffer.\n    // TODO: Seems like writing string one-by-one affects the performance. See similar benchmarks\n    // that differs only with input string length.\n    auto Put(Ch c) -> void {\n        wr.inner << c;\n    }\n\n    /// Does nothing, because there is no intermediate buffer.\n    auto Flush() -> void {}\n};\n\n}  // namespace\n\nclass json_t::properties_t {\npublic:\n    bool unique;\n    bool newline;\n\n    struct {\n        std::map<std::string, std::vector<std::string>> specified;\n        std::string unspecified;\n    } routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    properties_t() :\n        unique(false),\n        newline(false)\n    {}\n};\n\nclass json_t::inner_t {\n    template<typename> class builder;\n\npublic:\n    // A JSON routing pointer for attributes that weren't mentioned in `routing` map.\n    rapidjson::Pointer rest;\n    // Routing map from attribute name to its JSON pointer.\n    std::map<std::string, rapidjson::Pointer> routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    bool unique;\n\n    inner_t(json_t::properties_t properties) :\n        rest(properties.routing.unspecified),\n        mapping(std::move(properties.mapping)),\n        unique(properties.unique)\n    {\n        for (const auto& route : properties.routing.specified) {\n            for (const auto& name : route.second) {\n                routing.insert({name, rapidjson::Pointer(route.first)});\n            }\n        }\n    }\n\n    template<typename Document>\n    auto get(const string_view& name, Document& root) -> rapidjson::Value& {\n        // TODO: Here we can avoid a temporary string construction by using multi indexed\n        // containers.\n        const auto it = routing.find(name.to_string());\n\n        if (it == routing.end()) {\n            return rest.GetWithDefault(root, rapidjson::kObjectType);\n        } else {\n            return it->second.GetWithDefault(root, rapidjson::kObjectType);\n        }\n    }\n\n    template<typename Document>\n    auto create(Document& root, const record_t& record) -> builder<Document>;\n\n    auto renamed(const string_view& name) const -> string_view {\n        const auto it = mapping.find(name.to_string());\n\n        if (it == mapping.end()) {\n            return name;\n        } else {\n            return it->second;\n        }\n    }\n};\n\ntemplate<typename Document>\nclass json_t::inner_t::builder {\n    Document& root;\n    const record_t& record;\n    inner_t& inner;\n\npublic:\n    builder(Document& root, const record_t& record, inner_t& inner) :\n        root(root),\n        record(record),\n        inner(inner)\n    {}\n\n    auto message() -> void {\n        apply(\"message\", record.formatted());\n    }\n\n    auto severity() -> void {\n        apply(\"severity\", static_cast<std::int64_t>(record.severity()));\n    }\n\n    auto timestamp() -> void {\n        apply(\"timestamp\", std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(record.timestamp().time_since_epoch()).count());\n    }\n\n    auto build(writer_t& writer) -> void {\n        stream_t stream{writer};\n        rapidjson::Writer<stream_t> wr(stream);\n        root.Accept(wr);\n    }\n\n    auto attributes() -> void {\n        if (inner.unique) {\n            // TODO: Small buffer optimization is possible here (see stack allocator with arena).\n            // TODO: Also consider using `unordered_set` instead. But it requires either manually or\n            // indirectly implementing murmur3 hashing to be fully compatible with the Standard.\n            std::set<string_view> set;\n\n            for (const auto& attributes : record.attributes()) {\n                for (const auto& attribute : attributes.get()) {\n                    if (set.insert(attribute.first).second) {\n                        apply(attribute.first, attribute.second);\n                    }\n                }\n            }\n            return;\n        }\n\n        // TODO: Make flattened range\n        // TODO: Make uniqued range.\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                apply(attribute.first, attribute.second);\n            }\n        }\n    }\n\nprivate:\n    template<typename T>\n    auto apply(const string_view& name, const T& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        visitor(value);\n    }\n\n    auto apply(const string_view& name, const attribute::view_t& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        boost::apply_visitor(visitor, value.inner().value);\n    }\n};\n\ntemplate<typename Document>\nauto json_t::inner_t::create(Document& root, const record_t& record) ->\n    builder<Document>\n{\n    return builder<Document>{root, record, *this};\n}\n\njson_t::json_t() :\n    inner(new inner_t(properties_t()))\n{}\n\njson_t::json_t(properties_t properties) :\n    inner(new inner_t(std::move(properties)))\n{}\n\njson_t::~json_t() {}\n\nauto json_t::format(const record_t& record, writer_t& writer) -> void {\n    typedef rapidjson::GenericDocument<\n        rapidjson::UTF8<>,\n        rapidjson::MemoryPoolAllocator<>,\n        rapidjson::MemoryPoolAllocator<>\n    > document_type;\n\n    std::array<char, 4096> value_buffer;\n    std::array<char, 1024> parse_buffer;\n    rapidjson::MemoryPoolAllocator<> value_allocator(value_buffer.data(), value_buffer.size());\n    rapidjson::MemoryPoolAllocator<> parse_allocator(parse_buffer.data(), parse_buffer.size());\n\n    document_type root(&value_allocator, parse_buffer.size(), &parse_allocator);\n    root.SetObject();\n\n    // TODO: Try to use `AutoUTF<>` or `AutoUTFOutputStream` for UTF-8 validation.\n\n    auto builder = inner->create(root, record);\n    builder.message();\n    builder.severity();\n    builder.timestamp();\n    builder.attributes();\n\n    builder.build(writer);\n\n    // TODO: Add newline if required. Obtained through config.\n    // if (config.newline) {\n    //     writer << '\\n';\n    // }\n}\n\njson_t::builder_t::builder_t() :\n    properties(new properties_t)\n{}\n\njson_t::builder_t::~builder_t() = default;\n\nauto json_t::builder_t::route(std::string route) -> builder_t& {\n    properties->routing.unspecified = std::move(route);\n    return *this;\n}\n\nauto json_t::builder_t::route(std::string route, std::vector<std::string> attributes) -> builder_t& {\n    properties->routing.specified[std::move(route)] = std::move(attributes);\n    return *this;\n}\n\nauto json_t::builder_t::rename(std::string from, std::string to) -> builder_t& {\n    properties->mapping[std::move(from)] = std::move(to);\n    return *this;\n}\n\nauto json_t::builder_t::unique() -> builder_t& {\n    properties->unique = true;\n    return *this;\n}\n\nauto json_t::builder_t::build() const -> json_t {\n    return {std::move(*properties)};\n}\n\n}  // namespace formatter\n\nauto factory<formatter::json_t>::type() noexcept -> const char* {\n    return \"json\";\n}\n\nauto factory<formatter::json_t>::from(const config::node_t& config) -> formatter::json_t {\n    formatter::json_t::builder_t builder;\n\n    if (auto unique = config[\"unique\"].to_bool()) {\n        if (unique.get()) {\n            builder.unique();\n        }\n    }\n\n    if (auto mapping = config[\"mapping\"]) {\n        mapping.each_map([&](const std::string& key, const config::node_t& value) {\n            builder.rename(key, value.to_string());\n        });\n    }\n\n    if (auto routing = config[\"routing\"]) {\n        routing.each_map([&](const std::string& key, const config::node_t& value) {\n            try {\n                // TODO: Probably it's right thing to explicitly check whether the value is string.\n                value.to_string();\n                builder.route(key);\n                return;\n            } catch (const std::logic_error&) {\n                // Eat.\n            }\n\n            std::vector<std::string> attributes;\n            value.each([&](const config::node_t& config) {\n                attributes.emplace_back(config.to_string());\n            });\n            builder.route(key, std::move(attributes));\n        });\n    }\n\n    return builder.build();\n}\n\n}  // namespace v1\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "include/blackhole/formatter/json.hpp",
        "code": "#pragma once\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"blackhole/formatter.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<typename>\nstruct factory;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\n\n/// The JSON formatter is responsible for effective converting the given log record into a\n/// structured JSON tree with attributes routing and renaming features.\n///\n/// Briefly using JSON formatter allows to build fully dynamic JSON trees for its further processing\n/// with various external tools, like logstash or rsyslog lefting it, however, in a human-readable\n/// state.\n///\n/// Blackhole allows you to control of JSON tree building process using several predefined options.\n///\n/// Without options it will produce just a plain tree with zero level depth.\n/// For example for a log record with a severity of 3, message \"fatal error, please try again\" and a\n/// pair of attributes `{\"key\": 42, \"ip\": \"[::]\"}` the result string will look like:\n/// {\n///     \"message\": \"fatal error, please try again\",\n///     \"severity\": 3,\n///     \"timestamp\": 1449859055,\n///     \"process\": 12345,\n///     \"thread\": 0x0000dead,\n///     \"key\": 42,\n///     \"ip\": \"[::]\"\n/// }\n///\n/// Using configuration parameters for this formatter you can:\n/// - Rename parameters.\n/// - Construct hierarchical tree using a standardized JSON pointer API. For more information please\n///   follow \\ref https://tools.ietf.org/html/rfc6901.\n///\n/// Attributes renaming acts so much transparently as it appears: it just renames the given\n/// attribute name using the specified alternative.\n///\n/// Attributes routing specifies a location where the listed attributes will be placed at the tree\n/// construction. Also you can specify a default location for all attributes, which is \"/\" meaning\n/// root otherwise.\n///\n/// For example with routing `{\"/fields\": [\"message\", \"severity\"]}` and \"/\" as a default pointer the\n/// mentioned JSON will look like:\n/// {\n///     \"fields\": {\n///         \"message\": \"fatal error, please try again\",\n///         \"severity\": 3\n///     },\n///     \"timestamp\": 1449859055,\n///     \"process\": 12345,\n///     \"thread\": 0x0000dead,\n///     \"key\": 42,\n///     \"ip\": \"[::]\"\n/// }\n///\n/// Attribute renaming occurs after routing, so mapping \"message\" => \"#message\" just replaces the\n/// old name with its new alternative.\n///\n/// To gain maximum speed at the tree construction no filtering occurs, so this formatter by default\n/// allows duplicated keys, which means invalid JSON tree (but most of parsers are fine with it).\n/// If you are really required to deal with unique keys, you can enable `unique` option, but it\n/// involves heap allocation and may slow down formatting.\n///\n/// Also formatter allows to automatically append a newline character at the end of the tree, which\n/// is strangely required by some consumers, like logstash.\n///\n/// Note, that JSON formatter formats the tree using compact style without excess spaces, tabs etc.\n///\n/// For convenient formatter construction a special builder class is implemented allowing to create\n/// and configure instances of this class using streaming API. For example:\n///     auto formatter = json_t::builder_t()\n///         .route(\"/fields\", {\"message\", \"severity\", \"timestamp\"})\n///         .route(\"/other\")\n///         .rename(\"message\", \"#message\")\n///         .rename(\"timestamp\", \"#timestamp\")\n///         .newline()\n///         .unique()\n///         .build();\n///\n/// This allow to avoid hundreds of constructors and to make a formatter creation to look eye-candy.\n// TODO: Add severity mapping support.\n// TODO: Add timestamp mapping support.\nclass json_t : public formatter_t {\n    class inner_t;\n    class properties_t;\n\n    std::unique_ptr<inner_t> inner;\n\npublic:\n    /// Represents a JSON formatter object builder to ease its configuration.\n    class builder_t;\n\n    /// Constructs a defaultly configured JSON formatter, which will produce plain trees with no\n    /// filtering without adding a separator character at the end.\n    json_t();\n\n    /// Copy constructing is explicitly prohibited.\n    json_t(const json_t& other) = delete;\n\n    /// Constructs a JSON formatter using the given other JSON formatter by moving its content.\n    json_t(json_t&& other) noexcept;\n\n    /// Destroys the current JSON formatter instance, freeing all its resources.\n    ~json_t();\n\n    /// Copy assignment is explicitly prohibited.\n    auto operator=(const json_t& other) -> json_t& = delete;\n\n    /// Assigns the given JSON formatter to the current one by moving its content.\n    auto operator=(json_t&& other) noexcept -> json_t&;\n\n    /// Formats the given record by constructing a JSON tree with further serializing into the\n    /// specified writer.\n    auto format(const record_t& record, writer_t& writer) -> void;\n\nprivate:\n    json_t(properties_t properties);\n};\n\n/// Represents a JSON formatter object builder to ease its configuration.\n///\n/// Exists mainly for both avoiding hundreds of formatter constructors and keep its semantics\n/// immutable. It's quite convenient to build up different formatter objects just by chaining the\n/// different \"setters\" \u2013 no need for default parameters, dealing with constructor bloat etc.\nclass json_t::builder_t {\n    std::unique_ptr<json_t::properties_t> properties;\n\npublic:\n    builder_t();\n    ~builder_t();\n\n    /// Configures attribute routing for all not mentioned attributes.\n    auto route(std::string route) -> builder_t&;\n\n    /// Configures attribute routing for the given set of attributes.\n    ///\n    /// Routing feature allows to build a JSON tree using simple key -> set representation. Each\n    /// attribute in the set will be traversed into the specified route.\n    /// Route parameter adheres JSON Pointer RFC, see https://tools.ietf.org/html/rfc6901 for more\n    /// information.\n    auto route(std::string route, std::vector<std::string> attributes) -> builder_t&;\n    auto rename(std::string from, std::string to) -> builder_t&;\n    auto unique() -> builder_t&;\n    auto newline() -> builder_t&;\n\n    auto build() const -> json_t;\n};\n\n}  // namespace formatter\n\ntemplate<>\nstruct factory<formatter::json_t> {\n    static auto type() noexcept -> const char*;\n    static auto from(const config::node_t& config) -> formatter::json_t;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/attribute.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n#include <type_traits>\n\n#include <boost/mpl/contains.hpp>\n#include <boost/mpl/vector.hpp>\n\n#include \"blackhole/cpp17/string_view.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\n/// Trait that describes how to format user defined types provided as attributes.\ntemplate<typename T>\nstruct display_traits;\n\n/// Represents a trait for mapping an owned types to their associated lightweight view types.\n///\n/// By default all types are transparently mapped to itself, but Blackhole provides some\n/// specializations.\n///\n/// \\warning it is undefined behavior to add specializations for this trait.\ntemplate<typename T>\nstruct view_of {\n    typedef T type;\n};\n\n/// Forward.\nclass writer_t;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nclass value_t;\nclass view_t;\n\n/// Represents an attribute value holder.\n///\n/// Attribute value is an algebraic data type that can be initialized with one of the following\n/// predefined primitive types:\n///     - none marker;\n///     - boolean type (true or false);\n///     - signed integer types up to 64-bit size;\n///     - unsigned integer types up to 64-bit size;\n///     - floating point type;\n///     - owned string type;\n///     - and a function type, which can fill the specified writer with the value lazily.\n///\n/// The underlying value can be obtained through `blackhole::attribute::get` function with providing\n/// the desired result type. For example:\n///     blackhole::attribute::value_t value(42);\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(42 == actual);\n///\n/// As an alternative a visitor pattern is provided for enabling underlying value visitation. To\n/// enable this feature, implement the `value_t::visitor_t` interface and provide an instance of\n/// this implementation to the `apply` method.\nclass value_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef std::string    string_type;\n    typedef std::function<auto(writer_t& writer) -> void> function_type;\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<sizeof(function_type) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value containing tagged nullptr value.\n    value_t();\n\n    value_t(std::nullptr_t);\n\n    /// Constructs a value initialized with the given boolean value.\n    value_t(bool value);\n\n    /// Constructs a value initialized with the given signed integer.\n    value_t(char value);\n    value_t(short value);\n    value_t(int value);\n    value_t(long value);\n    value_t(long long value);\n\n    /// Constructs a value initialized with the given unsigned integer.\n    value_t(unsigned char value);\n    value_t(unsigned short value);\n    value_t(unsigned int value);\n    value_t(unsigned long value);\n    value_t(unsigned long long value);\n\n    value_t(double value);\n\n    /// Constructs a value from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    value_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    value_t(std::string value);\n\n    ~value_t();\n\n    value_t(const value_t& other);\n    value_t(value_t&& other);\n\n    auto operator=(const value_t& other) -> value_t&;\n    auto operator=(value_t&& other) -> value_t&;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n};\n\n/// Represents an attribute value holder view, containing only lightweight views of the actual\n/// values.\n///\n/// If an owned value is small enough to keep its copy - this class does it, otherwise keeping only\n/// view proxy values. For example for `std::string` values there is a lightweight mapping that\n/// holds only two members: a pointer to constant char and a size.\n///\n/// The underlying value can also be obtained through `blackhole::attribute::get` function with\n/// providing the desired result type. For example:\n///     blackhole::attribute::view_t value(\"le vinegret\");\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(\"le vinegret\" == actual);\n///\nclass view_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef string_view    string_type;\n\n    struct function_type {\n        const void* value;\n        std::reference_wrapper<auto(const void* value, writer_t& writer) -> void> fn;\n\n        auto operator()(writer_t& wr) const -> void {\n            fn(value, wr);\n        }\n\n        auto operator==(const function_type& other) const noexcept -> bool {\n            return value == other.value && fn.get() == other.fn.get();\n        }\n    };\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<2 * sizeof(void*) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value view containing tagged nullptr value.\n    view_t();\n\n    view_t(std::nullptr_t);\n\n    /// Constructs a value view initialized with the given boolean value.\n    view_t(bool value);\n\n    /// Constructs a value view initialized with the given signed integer.\n    view_t(char value);\n    view_t(short value);\n    view_t(int value);\n    view_t(long value);\n    view_t(long long value);\n\n    /// Constructs a value view initialized with the given unsigned integer.\n    view_t(unsigned char value);\n    view_t(unsigned short value);\n    view_t(unsigned int value);\n    view_t(unsigned long value);\n    view_t(unsigned long long value);\n\n    /// Constructs a value view from the given floating point value.\n    view_t(float value);\n    view_t(double value);\n\n    /// Constructs a value view from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    view_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    /// Constructs a value view from the given string view.\n    view_t(const string_type& value);\n\n    /// Constructs a value view from the given string.\n    view_t(const std::string& value);\n\n    /// Constructs a value view from the given owned attribute value.\n    view_t(const value_t& value);\n\n    /// Constructs a value view from a custom type that implements `display_traits` trait.\n    ///\n    /// \\sa display_traits for more information.\n    template<typename T>\n    view_t(const T& value, decltype(&display_traits<T>::apply)* = nullptr) {\n        construct(function_type{static_cast<const void*>(&value), std::ref(display<T>)});\n    }\n\n    view_t(const view_t& other) = default;\n    view_t(view_t&& other) = default;\n\n    ~view_t() = default;\n\n    auto operator=(const view_t& other) -> view_t& = default;\n    auto operator=(view_t&& other) -> view_t& = default;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    auto operator==(const view_t& other) const -> bool;\n    auto operator!=(const view_t& other) const -> bool;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n\n    template<typename T>\n    static auto display(const void* value, writer_t& wr) -> void {\n        display_traits<T>::apply(*static_cast<const T*>(value), wr);\n    }\n};\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const value_t& value) ->\n    typename std::enable_if<boost::mpl::contains<value_t::types, T>::value, const T&>::type;\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value view.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const view_t& value) ->\n    typename std::enable_if<boost::mpl::contains<view_t::types, T>::value, const T&>::type;\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/node.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\ntemplate<typename T>\nclass option;\n\n/// Represents the configuration tree node.\n///\n/// Blackhole operates with instances of this class while configuring the logging system from some\n/// generic source, from file for example. It assumes that the whole configuration can be described\n/// using tree data structure, like JSON, XML or YAML.\n/// To be able to initialize from your own data format you must create subclass and implement its\n/// converting methods as like as tree traversing using subscription operators.\nclass node_t {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\npublic:\n    virtual ~node_t() = 0;\n\n    /// Tries to convert the underlying object to bool.\n    virtual auto to_bool() const -> bool = 0;\n\n    /// Tries to convert the underlying object to signed integer.\n    virtual auto to_sint64() const -> std::int64_t = 0;\n\n    /// Tries to convert the underlying object to unsigned integer.\n    virtual auto to_uint64() const -> std::uint64_t = 0;\n\n    /// Tries to convert the underlying object to double.\n    virtual auto to_double() const -> double = 0;\n\n    /// Tries to convert the underlying object to string.\n    virtual auto to_string() const -> std::string = 0;\n\n    /// Assuming that the underlying object is an array, performs inner iteration over it by\n    /// applying the given function to each element.\n    ///\n    /// Should do nothing either if there is no underlying array or it is empty.\n    virtual auto each(const each_function& fn) const -> void = 0;\n\n    /// Assuming that the underlying object is a map, performs inner iteration over it by applying\n    /// the given function to each key-value element.\n    ///\n    /// Should do nothing either if there is no underlying map or it is empty.\n    virtual auto each_map(const member_function& fn) const -> void = 0;\n\n    /// Assuming that the underlying object is an array performs index operation returning the\n    /// option object with some node at the given index on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::size_t& idx) const -> option<node_t> = 0;\n\n    /// Assuming that the underlying object is a map performs tree traversing operation returning\n    /// option object with some node at the given key on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::string& key) const -> option<node_t> = 0;\n};\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/option.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include <boost/optional/optional_fwd.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\ntemplate<typename T>\nclass option;\n\ntemplate<>\nclass option<node_t> {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\nprivate:\n    std::unique_ptr<node_t> node;\n\npublic:\n    /// Constructs an option object that will contan nothing.\n    option() noexcept;\n\n    /// Constructs an option object that will contain the specified configuration node.\n    explicit option(std::unique_ptr<node_t> node) noexcept;\n\n    explicit operator bool() const noexcept;\n\n    /// Unwraps an option, yielding the content of an underlying config node object.\n    auto unwrap() const -> boost::optional<const node_t&>;\n\n    auto to_bool() const -> boost::optional<bool>;\n    auto to_sint64() const -> boost::optional<std::int64_t>;\n    auto to_uint64() const -> boost::optional<std::uint64_t>;\n    auto to_double() const -> boost::optional<double>;\n    auto to_string() const -> boost::optional<std::string>;\n\n    auto each(const each_function& fn) const -> void;\n    auto each_map(const member_function& fn) const -> void;\n\n    auto operator[](const std::size_t& idx) const -> option<node_t>;\n    auto operator[](const std::string& key) const -> option<node_t>;\n\nprivate:\n    template<typename F>\n    auto to(F&& fn) const -> decltype(fn());\n};\n\n/// Constructs an option of the specified configuration node type using given arguments.\ntemplate<typename T, typename... Args>\nauto make_option(Args&&... args) -> option<node_t> {\n    return option<node_t>(std::unique_ptr<T>(new T(std::forward<Args>(args)...)));\n}\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/record.hpp",
        "code": "#pragma once\n\n#include <chrono>\n#include <cstdint>\n#include <thread>\n\n#include \"blackhole/attributes.hpp\"\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/severity.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\nclass record_t {\npublic:\n    typedef std::chrono::system_clock clock_type;\n    typedef clock_type::time_point time_point;\n\nprivate:\n    struct inner_t;\n\n    typedef std::aligned_storage<64>::type storage_type;\n    storage_type storage;\n\npublic:\n    /// Creates a log record with the given severity, possibly unformatted message and attributes.\n    ///\n    /// The created record contains almost all information about the logging event associated except\n    /// the timestamp and formatted message.\n    ///\n    /// These missing attributes are set right after filtering pass with `activate` method.\n    ///\n    /// \\warning constructing from rvalue references is explicitly forbidden, specified objects must\n    ///     outlive the record created.\n    record_t(severity_t severity,\n        std::reference_wrapper<const string_view> message,\n        std::reference_wrapper<const attribute_pack> attributes);\n\n    auto message() const noexcept -> const string_view&;\n    auto severity() const noexcept -> severity_t;\n    auto timestamp() const noexcept -> time_point;\n\n    auto pid() const noexcept -> std::uint64_t;\n    auto tid() const noexcept -> std::thread::native_handle_type;\n\n    auto formatted() const noexcept -> const string_view&;\n    auto attributes() const noexcept -> const attribute_pack&;\n\n    /// Activate the record by setting the given formatted message accompanied by obtaining and\n    /// setting the current time point.\n    auto activate(const string_view& formatted = string_view()) noexcept -> void;\n\nprivate:\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/extensions/writer.hpp",
        "code": "#pragma once\n\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/extensions/format.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\n/// Represents stream writer backed up by cppformat.\nclass writer_t {\npublic:\n    fmt::MemoryWriter inner;\n\n    /// Formats the given arguments using the underlying formatter.\n    template<typename... Args>\n    inline auto write(const Args&... args) -> void {\n        inner.write(args...);\n    }\n\n    auto result() const noexcept -> string_view {\n        return string_view(inner.data(), inner.size());\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/attribute.hpp",
        "code": "#pragma once\n\n#include <boost/variant/variant.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nstruct value_t::inner_t {\n    typedef boost::make_variant_over<value_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\nstruct view_t::inner_t {\n    typedef boost::make_variant_over<view_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      }
    ],
    "unresolved_context": []
  },
  "output": {
    "language": "C++",
    "fixed_commit_message": "feat(formatter/json): add newline option\n\nThis option allows to append a newline sequence to the end of the JSON\nresult.\n\nCloses #86.",
    "fixed_file": {
      "fixed_filename": "src/formatter/json.cpp",
      "fixed_code": "#include \"blackhole/formatter/json.hpp\"\n\n#include <array>\n#include <set>\n#include <unordered_map>\n\n#include <boost/optional/optional.hpp>\n#include <boost/variant/apply_visitor.hpp>\n\n#ifndef RAPIDJSON_HAS_STDSTRING\n#define RAPIDJSON_HAS_STDSTRING 1\n#endif\n#include <rapidjson/document.h>\n#include <rapidjson/stringbuffer.h>\n#include <rapidjson/writer.h>\n#include <rapidjson/pointer.h>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/record.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\nnamespace {\n\nstruct visitor_t {\n    typedef void result_type;\n\n    rapidjson::Value& node;\n    rapidjson::MemoryPoolAllocator<>& allocator;\n\n    const string_view& name;\n\n    auto operator()(std::nullptr_t) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), rapidjson::kNullType, allocator);\n    }\n\n    // For `bool`, `std::int64_t`, `std::uint64_t` and `double` types.\n    template<typename T>\n    auto operator()(T value) -> void {\n        static_assert(\n            std::is_same<T, bool>::value ||\n            std::is_same<T, std::int64_t>::value ||\n            std::is_same<T, std::uint64_t>::value ||\n            std::is_same<T, double>::value, \"type mismatch\");\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), value, allocator);\n    }\n\n    auto operator()(const string_view& value) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            rapidjson::StringRef(value.data(), value.size()), allocator);\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) -> void {\n        writer_t wr;\n        value(wr);\n\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            wr.result().to_string(), allocator);\n    }\n};\n\n/// A RapidJSON Stream concept implementation required to avoid intermediate buffer allocation.\nstruct stream_t {\n    typedef char Ch;\n\n    writer_t& wr;\n\n    /// Writes a character directly into the underlying buffer.\n    // TODO: Seems like writing string one-by-one affects the performance. See similar benchmarks\n    // that differs only with input string length.\n    auto Put(Ch c) -> void {\n        wr.inner << c;\n    }\n\n    /// Does nothing, because there is no intermediate buffer.\n    auto Flush() -> void {}\n};\n\n}  // namespace\n\nclass json_t::properties_t {\npublic:\n    bool unique;\n    bool newline;\n\n    struct {\n        std::map<std::string, std::vector<std::string>> specified;\n        std::string unspecified;\n    } routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    properties_t() :\n        unique(false),\n        newline(false)\n    {}\n};\n\nclass json_t::inner_t {\n    template<typename> class builder;\n\npublic:\n    // A JSON routing pointer for attributes that weren't mentioned in `routing` map.\n    rapidjson::Pointer rest;\n    // Routing map from attribute name to its JSON pointer.\n    std::map<std::string, rapidjson::Pointer> routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    bool unique;\n    bool newline;\n\n    inner_t(json_t::properties_t properties) :\n        rest(properties.routing.unspecified),\n        mapping(std::move(properties.mapping)),\n        unique(properties.unique),\n        newline(properties.newline)\n    {\n        for (const auto& route : properties.routing.specified) {\n            for (const auto& name : route.second) {\n                routing.insert({name, rapidjson::Pointer(route.first)});\n            }\n        }\n    }\n\n    template<typename Document>\n    auto get(const string_view& name, Document& root) -> rapidjson::Value& {\n        // TODO: Here we can avoid a temporary string construction by using multi indexed\n        // containers.\n        const auto it = routing.find(name.to_string());\n\n        if (it == routing.end()) {\n            return rest.GetWithDefault(root, rapidjson::kObjectType);\n        } else {\n            return it->second.GetWithDefault(root, rapidjson::kObjectType);\n        }\n    }\n\n    template<typename Document>\n    auto create(Document& root, const record_t& record) -> builder<Document>;\n\n    auto renamed(const string_view& name) const -> string_view {\n        const auto it = mapping.find(name.to_string());\n\n        if (it == mapping.end()) {\n            return name;\n        } else {\n            return it->second;\n        }\n    }\n};\n\ntemplate<typename Document>\nclass json_t::inner_t::builder {\n    Document& root;\n    const record_t& record;\n    inner_t& inner;\n\npublic:\n    builder(Document& root, const record_t& record, inner_t& inner) :\n        root(root),\n        record(record),\n        inner(inner)\n    {}\n\n    auto message() -> void {\n        apply(\"message\", record.formatted());\n    }\n\n    auto severity() -> void {\n        apply(\"severity\", static_cast<std::int64_t>(record.severity()));\n    }\n\n    auto timestamp() -> void {\n        apply(\"timestamp\", std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(record.timestamp().time_since_epoch()).count());\n    }\n\n    auto build(writer_t& writer) -> void {\n        stream_t stream{writer};\n        rapidjson::Writer<stream_t> wr(stream);\n        root.Accept(wr);\n    }\n\n    auto attributes() -> void {\n        if (inner.unique) {\n            // TODO: Small buffer optimization is possible here (see stack allocator with arena).\n            // TODO: Also consider using `unordered_set` instead. But it requires either manually or\n            // indirectly implementing murmur3 hashing to be fully compatible with the Standard.\n            std::set<string_view> set;\n\n            for (const auto& attributes : record.attributes()) {\n                for (const auto& attribute : attributes.get()) {\n                    if (set.insert(attribute.first).second) {\n                        apply(attribute.first, attribute.second);\n                    }\n                }\n            }\n            return;\n        }\n\n        // TODO: Make flattened range\n        // TODO: Make uniqued range.\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                apply(attribute.first, attribute.second);\n            }\n        }\n    }\n\nprivate:\n    template<typename T>\n    auto apply(const string_view& name, const T& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        visitor(value);\n    }\n\n    auto apply(const string_view& name, const attribute::view_t& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        boost::apply_visitor(visitor, value.inner().value);\n    }\n};\n\ntemplate<typename Document>\nauto json_t::inner_t::create(Document& root, const record_t& record) ->\n    builder<Document>\n{\n    return builder<Document>{root, record, *this};\n}\n\njson_t::json_t() :\n    inner(new inner_t(properties_t()))\n{}\n\njson_t::json_t(properties_t properties) :\n    inner(new inner_t(std::move(properties)))\n{}\n\njson_t::~json_t() {}\n\nauto json_t::format(const record_t& record, writer_t& writer) -> void {\n    typedef rapidjson::GenericDocument<\n        rapidjson::UTF8<>,\n        rapidjson::MemoryPoolAllocator<>,\n        rapidjson::MemoryPoolAllocator<>\n    > document_type;\n\n    std::array<char, 4096> value_buffer;\n    std::array<char, 1024> parse_buffer;\n    rapidjson::MemoryPoolAllocator<> value_allocator(value_buffer.data(), value_buffer.size());\n    rapidjson::MemoryPoolAllocator<> parse_allocator(parse_buffer.data(), parse_buffer.size());\n\n    document_type root(&value_allocator, parse_buffer.size(), &parse_allocator);\n    root.SetObject();\n\n    // TODO: Try to use `AutoUTF<>` or `AutoUTFOutputStream` for UTF-8 validation.\n\n    auto builder = inner->create(root, record);\n    builder.message();\n    builder.severity();\n    builder.timestamp();\n    builder.attributes();\n\n    builder.build(writer);\n\n    if (inner->newline) {\n        writer.inner << '\\n';\n    }\n}\n\njson_t::builder_t::builder_t() :\n    properties(new properties_t)\n{}\n\njson_t::builder_t::~builder_t() = default;\n\nauto json_t::builder_t::route(std::string route) -> builder_t& {\n    properties->routing.unspecified = std::move(route);\n    return *this;\n}\n\nauto json_t::builder_t::route(std::string route, std::vector<std::string> attributes) -> builder_t& {\n    properties->routing.specified[std::move(route)] = std::move(attributes);\n    return *this;\n}\n\nauto json_t::builder_t::rename(std::string from, std::string to) -> builder_t& {\n    properties->mapping[std::move(from)] = std::move(to);\n    return *this;\n}\n\nauto json_t::builder_t::unique() -> builder_t& {\n    properties->unique = true;\n    return *this;\n}\n\nauto json_t::builder_t::newline() -> builder_t& {\n    properties->newline = true;\n    return *this;\n}\n\nauto json_t::builder_t::build() const -> json_t {\n    return {std::move(*properties)};\n}\n\n}  // namespace formatter\n\nauto factory<formatter::json_t>::type() noexcept -> const char* {\n    return \"json\";\n}\n\nauto factory<formatter::json_t>::from(const config::node_t& config) -> formatter::json_t {\n    formatter::json_t::builder_t builder;\n\n    if (auto unique = config[\"unique\"].to_bool()) {\n        if (unique.get()) {\n            builder.unique();\n        }\n    }\n\n    if (auto mapping = config[\"mapping\"]) {\n        mapping.each_map([&](const std::string& key, const config::node_t& value) {\n            builder.rename(key, value.to_string());\n        });\n    }\n\n    if (auto routing = config[\"routing\"]) {\n        routing.each_map([&](const std::string& key, const config::node_t& value) {\n            try {\n                // TODO: Probably it's right thing to explicitly check whether the value is string.\n                value.to_string();\n                builder.route(key);\n                return;\n            } catch (const std::logic_error&) {\n                // Eat.\n            }\n\n            std::vector<std::string> attributes;\n            value.each([&](const config::node_t& config) {\n                attributes.emplace_back(config.to_string());\n            });\n            builder.route(key, std::move(attributes));\n        });\n    }\n\n    return builder.build();\n}\n\n}  // namespace v1\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "include/blackhole/formatter/json.hpp",
        "code": "#pragma once\n\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"blackhole/formatter.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<typename>\nstruct factory;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\n\n/// The JSON formatter is responsible for effective converting the given log record into a\n/// structured JSON tree with attributes routing and renaming features.\n///\n/// Briefly using JSON formatter allows to build fully dynamic JSON trees for its further processing\n/// with various external tools, like logstash or rsyslog lefting it, however, in a human-readable\n/// state.\n///\n/// Blackhole allows you to control of JSON tree building process using several predefined options.\n///\n/// Without options it will produce just a plain tree with zero level depth.\n/// For example for a log record with a severity of 3, message \"fatal error, please try again\" and a\n/// pair of attributes `{\"key\": 42, \"ip\": \"[::]\"}` the result string will look like:\n/// {\n///     \"message\": \"fatal error, please try again\",\n///     \"severity\": 3,\n///     \"timestamp\": 1449859055,\n///     \"process\": 12345,\n///     \"thread\": 0x0000dead,\n///     \"key\": 42,\n///     \"ip\": \"[::]\"\n/// }\n///\n/// Using configuration parameters for this formatter you can:\n/// - Rename parameters.\n/// - Construct hierarchical tree using a standardized JSON pointer API. For more information please\n///   follow \\ref https://tools.ietf.org/html/rfc6901.\n///\n/// Attributes renaming acts so much transparently as it appears: it just renames the given\n/// attribute name using the specified alternative.\n///\n/// Attributes routing specifies a location where the listed attributes will be placed at the tree\n/// construction. Also you can specify a default location for all attributes, which is \"/\" meaning\n/// root otherwise.\n///\n/// For example with routing `{\"/fields\": [\"message\", \"severity\"]}` and \"/\" as a default pointer the\n/// mentioned JSON will look like:\n/// {\n///     \"fields\": {\n///         \"message\": \"fatal error, please try again\",\n///         \"severity\": 3\n///     },\n///     \"timestamp\": 1449859055,\n///     \"process\": 12345,\n///     \"thread\": 0x0000dead,\n///     \"key\": 42,\n///     \"ip\": \"[::]\"\n/// }\n///\n/// Attribute renaming occurs after routing, so mapping \"message\" => \"#message\" just replaces the\n/// old name with its new alternative.\n///\n/// To gain maximum speed at the tree construction no filtering occurs, so this formatter by default\n/// allows duplicated keys, which means invalid JSON tree (but most of parsers are fine with it).\n/// If you are really required to deal with unique keys, you can enable `unique` option, but it\n/// involves heap allocation and may slow down formatting.\n///\n/// Also formatter allows to automatically append a newline character at the end of the tree, which\n/// is strangely required by some consumers, like logstash.\n///\n/// Note, that JSON formatter formats the tree using compact style without excess spaces, tabs etc.\n///\n/// For convenient formatter construction a special builder class is implemented allowing to create\n/// and configure instances of this class using streaming API. For example:\n///     auto formatter = json_t::builder_t()\n///         .route(\"/fields\", {\"message\", \"severity\", \"timestamp\"})\n///         .route(\"/other\")\n///         .rename(\"message\", \"#message\")\n///         .rename(\"timestamp\", \"#timestamp\")\n///         .newline()\n///         .unique()\n///         .build();\n///\n/// This allow to avoid hundreds of constructors and to make a formatter creation to look eye-candy.\n// TODO: Add severity mapping support.\n// TODO: Add timestamp mapping support.\nclass json_t : public formatter_t {\n    class inner_t;\n    class properties_t;\n\n    std::unique_ptr<inner_t> inner;\n\npublic:\n    /// Represents a JSON formatter object builder to ease its configuration.\n    class builder_t;\n\n    /// Constructs a defaultly configured JSON formatter, which will produce plain trees with no\n    /// filtering without adding a separator character at the end.\n    json_t();\n\n    /// Copy constructing is explicitly prohibited.\n    json_t(const json_t& other) = delete;\n\n    /// Constructs a JSON formatter using the given other JSON formatter by moving its content.\n    json_t(json_t&& other) noexcept;\n\n    /// Destroys the current JSON formatter instance, freeing all its resources.\n    ~json_t();\n\n    /// Copy assignment is explicitly prohibited.\n    auto operator=(const json_t& other) -> json_t& = delete;\n\n    /// Assigns the given JSON formatter to the current one by moving its content.\n    auto operator=(json_t&& other) noexcept -> json_t&;\n\n    /// Formats the given record by constructing a JSON tree with further serializing into the\n    /// specified writer.\n    auto format(const record_t& record, writer_t& writer) -> void;\n\nprivate:\n    json_t(properties_t properties);\n};\n\n/// Represents a JSON formatter object builder to ease its configuration.\n///\n/// Exists mainly for both avoiding hundreds of formatter constructors and keep its semantics\n/// immutable. It's quite convenient to build up different formatter objects just by chaining the\n/// different \"setters\" \u2013 no need for default parameters, dealing with constructor bloat etc.\nclass json_t::builder_t {\n    std::unique_ptr<json_t::properties_t> properties;\n\npublic:\n    builder_t();\n    ~builder_t();\n\n    /// Configures attribute routing for all not mentioned attributes.\n    auto route(std::string route) -> builder_t&;\n\n    /// Configures attribute routing for the given set of attributes.\n    ///\n    /// Routing feature allows to build a JSON tree using simple key -> set representation. Each\n    /// attribute in the set will be traversed into the specified route.\n    /// Route parameter adheres JSON Pointer RFC, see https://tools.ietf.org/html/rfc6901 for more\n    /// information.\n    auto route(std::string route, std::vector<std::string> attributes) -> builder_t&;\n    auto rename(std::string from, std::string to) -> builder_t&;\n    auto unique() -> builder_t&;\n    auto newline() -> builder_t&;\n\n    auto build() const -> json_t;\n};\n\n}  // namespace formatter\n\ntemplate<>\nstruct factory<formatter::json_t> {\n    static auto type() noexcept -> const char*;\n    static auto from(const config::node_t& config) -> formatter::json_t;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/attribute.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n#include <type_traits>\n\n#include <boost/mpl/contains.hpp>\n#include <boost/mpl/vector.hpp>\n\n#include \"blackhole/cpp17/string_view.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\n/// Trait that describes how to format user defined types provided as attributes.\ntemplate<typename T>\nstruct display_traits;\n\n/// Represents a trait for mapping an owned types to their associated lightweight view types.\n///\n/// By default all types are transparently mapped to itself, but Blackhole provides some\n/// specializations.\n///\n/// \\warning it is undefined behavior to add specializations for this trait.\ntemplate<typename T>\nstruct view_of {\n    typedef T type;\n};\n\n/// Forward.\nclass writer_t;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nclass value_t;\nclass view_t;\n\n/// Represents an attribute value holder.\n///\n/// Attribute value is an algebraic data type that can be initialized with one of the following\n/// predefined primitive types:\n///     - none marker;\n///     - boolean type (true or false);\n///     - signed integer types up to 64-bit size;\n///     - unsigned integer types up to 64-bit size;\n///     - floating point type;\n///     - owned string type;\n///     - and a function type, which can fill the specified writer with the value lazily.\n///\n/// The underlying value can be obtained through `blackhole::attribute::get` function with providing\n/// the desired result type. For example:\n///     blackhole::attribute::value_t value(42);\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(42 == actual);\n///\n/// As an alternative a visitor pattern is provided for enabling underlying value visitation. To\n/// enable this feature, implement the `value_t::visitor_t` interface and provide an instance of\n/// this implementation to the `apply` method.\nclass value_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef std::string    string_type;\n    typedef std::function<auto(writer_t& writer) -> void> function_type;\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<sizeof(function_type) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value containing tagged nullptr value.\n    value_t();\n\n    value_t(std::nullptr_t);\n\n    /// Constructs a value initialized with the given boolean value.\n    value_t(bool value);\n\n    /// Constructs a value initialized with the given signed integer.\n    value_t(char value);\n    value_t(short value);\n    value_t(int value);\n    value_t(long value);\n    value_t(long long value);\n\n    /// Constructs a value initialized with the given unsigned integer.\n    value_t(unsigned char value);\n    value_t(unsigned short value);\n    value_t(unsigned int value);\n    value_t(unsigned long value);\n    value_t(unsigned long long value);\n\n    value_t(double value);\n\n    /// Constructs a value from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    value_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    value_t(std::string value);\n\n    ~value_t();\n\n    value_t(const value_t& other);\n    value_t(value_t&& other);\n\n    auto operator=(const value_t& other) -> value_t&;\n    auto operator=(value_t&& other) -> value_t&;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n};\n\n/// Represents an attribute value holder view, containing only lightweight views of the actual\n/// values.\n///\n/// If an owned value is small enough to keep its copy - this class does it, otherwise keeping only\n/// view proxy values. For example for `std::string` values there is a lightweight mapping that\n/// holds only two members: a pointer to constant char and a size.\n///\n/// The underlying value can also be obtained through `blackhole::attribute::get` function with\n/// providing the desired result type. For example:\n///     blackhole::attribute::view_t value(\"le vinegret\");\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(\"le vinegret\" == actual);\n///\nclass view_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef string_view    string_type;\n\n    struct function_type {\n        const void* value;\n        std::reference_wrapper<auto(const void* value, writer_t& writer) -> void> fn;\n\n        auto operator()(writer_t& wr) const -> void {\n            fn(value, wr);\n        }\n\n        auto operator==(const function_type& other) const noexcept -> bool {\n            return value == other.value && fn.get() == other.fn.get();\n        }\n    };\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<2 * sizeof(void*) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value view containing tagged nullptr value.\n    view_t();\n\n    view_t(std::nullptr_t);\n\n    /// Constructs a value view initialized with the given boolean value.\n    view_t(bool value);\n\n    /// Constructs a value view initialized with the given signed integer.\n    view_t(char value);\n    view_t(short value);\n    view_t(int value);\n    view_t(long value);\n    view_t(long long value);\n\n    /// Constructs a value view initialized with the given unsigned integer.\n    view_t(unsigned char value);\n    view_t(unsigned short value);\n    view_t(unsigned int value);\n    view_t(unsigned long value);\n    view_t(unsigned long long value);\n\n    /// Constructs a value view from the given floating point value.\n    view_t(float value);\n    view_t(double value);\n\n    /// Constructs a value view from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    view_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    /// Constructs a value view from the given string view.\n    view_t(const string_type& value);\n\n    /// Constructs a value view from the given string.\n    view_t(const std::string& value);\n\n    /// Constructs a value view from the given owned attribute value.\n    view_t(const value_t& value);\n\n    /// Constructs a value view from a custom type that implements `display_traits` trait.\n    ///\n    /// \\sa display_traits for more information.\n    template<typename T>\n    view_t(const T& value, decltype(&display_traits<T>::apply)* = nullptr) {\n        construct(function_type{static_cast<const void*>(&value), std::ref(display<T>)});\n    }\n\n    view_t(const view_t& other) = default;\n    view_t(view_t&& other) = default;\n\n    ~view_t() = default;\n\n    auto operator=(const view_t& other) -> view_t& = default;\n    auto operator=(view_t&& other) -> view_t& = default;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    auto operator==(const view_t& other) const -> bool;\n    auto operator!=(const view_t& other) const -> bool;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n\n    template<typename T>\n    static auto display(const void* value, writer_t& wr) -> void {\n        display_traits<T>::apply(*static_cast<const T*>(value), wr);\n    }\n};\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const value_t& value) ->\n    typename std::enable_if<boost::mpl::contains<value_t::types, T>::value, const T&>::type;\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value view.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const view_t& value) ->\n    typename std::enable_if<boost::mpl::contains<view_t::types, T>::value, const T&>::type;\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/node.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\ntemplate<typename T>\nclass option;\n\n/// Represents the configuration tree node.\n///\n/// Blackhole operates with instances of this class while configuring the logging system from some\n/// generic source, from file for example. It assumes that the whole configuration can be described\n/// using tree data structure, like JSON, XML or YAML.\n/// To be able to initialize from your own data format you must create subclass and implement its\n/// converting methods as like as tree traversing using subscription operators.\nclass node_t {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\npublic:\n    virtual ~node_t() = 0;\n\n    /// Tries to convert the underlying object to bool.\n    virtual auto to_bool() const -> bool = 0;\n\n    /// Tries to convert the underlying object to signed integer.\n    virtual auto to_sint64() const -> std::int64_t = 0;\n\n    /// Tries to convert the underlying object to unsigned integer.\n    virtual auto to_uint64() const -> std::uint64_t = 0;\n\n    /// Tries to convert the underlying object to double.\n    virtual auto to_double() const -> double = 0;\n\n    /// Tries to convert the underlying object to string.\n    virtual auto to_string() const -> std::string = 0;\n\n    /// Assuming that the underlying object is an array, performs inner iteration over it by\n    /// applying the given function to each element.\n    ///\n    /// Should do nothing either if there is no underlying array or it is empty.\n    virtual auto each(const each_function& fn) const -> void = 0;\n\n    /// Assuming that the underlying object is a map, performs inner iteration over it by applying\n    /// the given function to each key-value element.\n    ///\n    /// Should do nothing either if there is no underlying map or it is empty.\n    virtual auto each_map(const member_function& fn) const -> void = 0;\n\n    /// Assuming that the underlying object is an array performs index operation returning the\n    /// option object with some node at the given index on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::size_t& idx) const -> option<node_t> = 0;\n\n    /// Assuming that the underlying object is a map performs tree traversing operation returning\n    /// option object with some node at the given key on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::string& key) const -> option<node_t> = 0;\n};\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/option.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include <boost/optional/optional_fwd.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\ntemplate<typename T>\nclass option;\n\ntemplate<>\nclass option<node_t> {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\nprivate:\n    std::unique_ptr<node_t> node;\n\npublic:\n    /// Constructs an option object that will contan nothing.\n    option() noexcept;\n\n    /// Constructs an option object that will contain the specified configuration node.\n    explicit option(std::unique_ptr<node_t> node) noexcept;\n\n    explicit operator bool() const noexcept;\n\n    /// Unwraps an option, yielding the content of an underlying config node object.\n    auto unwrap() const -> boost::optional<const node_t&>;\n\n    auto to_bool() const -> boost::optional<bool>;\n    auto to_sint64() const -> boost::optional<std::int64_t>;\n    auto to_uint64() const -> boost::optional<std::uint64_t>;\n    auto to_double() const -> boost::optional<double>;\n    auto to_string() const -> boost::optional<std::string>;\n\n    auto each(const each_function& fn) const -> void;\n    auto each_map(const member_function& fn) const -> void;\n\n    auto operator[](const std::size_t& idx) const -> option<node_t>;\n    auto operator[](const std::string& key) const -> option<node_t>;\n\nprivate:\n    template<typename F>\n    auto to(F&& fn) const -> decltype(fn());\n};\n\n/// Constructs an option of the specified configuration node type using given arguments.\ntemplate<typename T, typename... Args>\nauto make_option(Args&&... args) -> option<node_t> {\n    return option<node_t>(std::unique_ptr<T>(new T(std::forward<Args>(args)...)));\n}\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/record.hpp",
        "code": "#pragma once\n\n#include <chrono>\n#include <cstdint>\n#include <thread>\n\n#include \"blackhole/attributes.hpp\"\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/severity.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\nclass record_t {\npublic:\n    typedef std::chrono::system_clock clock_type;\n    typedef clock_type::time_point time_point;\n\nprivate:\n    struct inner_t;\n\n    typedef std::aligned_storage<64>::type storage_type;\n    storage_type storage;\n\npublic:\n    /// Creates a log record with the given severity, possibly unformatted message and attributes.\n    ///\n    /// The created record contains almost all information about the logging event associated except\n    /// the timestamp and formatted message.\n    ///\n    /// These missing attributes are set right after filtering pass with `activate` method.\n    ///\n    /// \\warning constructing from rvalue references is explicitly forbidden, specified objects must\n    ///     outlive the record created.\n    record_t(severity_t severity,\n        std::reference_wrapper<const string_view> message,\n        std::reference_wrapper<const attribute_pack> attributes);\n\n    auto message() const noexcept -> const string_view&;\n    auto severity() const noexcept -> severity_t;\n    auto timestamp() const noexcept -> time_point;\n\n    auto pid() const noexcept -> std::uint64_t;\n    auto tid() const noexcept -> std::thread::native_handle_type;\n\n    auto formatted() const noexcept -> const string_view&;\n    auto attributes() const noexcept -> const attribute_pack&;\n\n    /// Activate the record by setting the given formatted message accompanied by obtaining and\n    /// setting the current time point.\n    auto activate(const string_view& formatted = string_view()) noexcept -> void;\n\nprivate:\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/extensions/writer.hpp",
        "code": "#pragma once\n\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/extensions/format.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\n/// Represents stream writer backed up by cppformat.\nclass writer_t {\npublic:\n    fmt::MemoryWriter inner;\n\n    /// Formats the given arguments using the underlying formatter.\n    template<typename... Args>\n    inline auto write(const Args&... args) -> void {\n        inner.write(args...);\n    }\n\n    auto result() const noexcept -> string_view {\n        return string_view(inner.data(), inner.size());\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/attribute.hpp",
        "code": "#pragma once\n\n#include <boost/variant/variant.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nstruct value_t::inner_t {\n    typedef boost::make_variant_over<value_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\nstruct view_t::inner_t {\n    typedef boost::make_variant_over<view_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      }
    ],
    "unresolved_context": [],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -114,11 +114,13 @@\n     std::unordered_map<std::string, std::string> mapping;\n \n     bool unique;\n+    bool newline;\n \n     inner_t(json_t::properties_t properties) :\n         rest(properties.routing.unspecified),\n         mapping(std::move(properties.mapping)),\n-        unique(properties.unique)\n+        unique(properties.unique),\n+        newline(properties.newline)\n     {\n         for (const auto& route : properties.routing.specified) {\n             for (const auto& name : route.second) {\n@@ -270,10 +272,9 @@\n \n     builder.build(writer);\n \n-    // TODO: Add newline if required. Obtained through config.\n-    // if (config.newline) {\n-    //     writer << '\\n';\n-    // }\n+    if (inner->newline) {\n+        writer.inner << '\\n';\n+    }\n }\n \n json_t::builder_t::builder_t() :\n@@ -299,6 +300,11 @@\n \n auto json_t::builder_t::unique() -> builder_t& {\n     properties->unique = true;\n+    return *this;\n+}\n+\n+auto json_t::builder_t::newline() -> builder_t& {\n+    properties->newline = true;\n     return *this;\n }\n "
  }
}