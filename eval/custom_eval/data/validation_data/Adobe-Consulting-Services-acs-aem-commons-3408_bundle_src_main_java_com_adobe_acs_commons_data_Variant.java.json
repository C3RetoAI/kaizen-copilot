{
  "repo": {
    "name": "Adobe-Consulting-Services/acs-aem-commons",
    "buggy_commit": "a2cf90935d6166680ad85a9ac045e5060bf202ac",
    "fixed_commit": "be4c5995f48fb4b25d56d6b20485d28d62d76479"
  },
  "input": {
    "language": "Java",
    "issue": {
      "issue_title": "Reduce usage of Apache Commons Lang 2",
      "issue_description": "\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n"
    },
    "buggy_commit_message": "Merge branch 'Adobe-Consulting-Services:master' into master",
    "buggy_file": {
      "buggy_filename": "bundle/src/main/java/com/adobe/acs/commons/data/Variant.java",
      "buggy_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.data;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.text.ParseException;\nimport java.time.Instant;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.CellStyle;\nimport org.apache.poi.ss.usermodel.DataFormatter;\nimport org.apache.poi.ss.usermodel.DateUtil;\nimport org.osgi.annotation.versioning.ProviderType;\n\n/**\n * Used to represent values that might be provided as one baseType but used as\n * another. Avoids glue code and switch statements in other parts of the code\n * especially dealing with data from spreadsheets.\n */\n@ProviderType\npublic final class Variant {\n\n    private Class baseType = null;\n    private static final Locale STANDARD_LOCALE = Locale.ROOT;\n    private static final FastDateFormat STANDARD_DATE_FORMAT = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, STANDARD_LOCALE);\n    private Optional<Long> longVal = Optional.empty();\n    private Optional<Double> doubleVal = Optional.empty();\n    private Optional<String> stringVal = Optional.empty();\n    private Optional<Boolean> booleanVal = Optional.empty();\n    private Optional<Date> dateVal = Optional.empty();\n\n    private static final FastDateFormat[] DATE_FORMATS = {\n            FastDateFormat.getDateInstance(FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getDateInstance(FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getTimeInstance(FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getTimeInstance(FastDateFormat.LONG, STANDARD_LOCALE),\n            STANDARD_DATE_FORMAT,\n            FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, STANDARD_LOCALE),\n            FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", STANDARD_LOCALE)\n    };\n\n    public Variant() {\n    }\n\n    public <T> Variant(T src) {\n        setValue(src);\n    }\n\n    public Variant(Cell src) {\n        this(src, Locale.getDefault());\n    }\n\n    public Variant(Cell src, Locale locale) {\n        setValue(src, locale);\n    }\n\n    public void clear() {\n        longVal = Optional.empty();\n        doubleVal = Optional.empty();\n        stringVal = Optional.empty();\n        booleanVal = Optional.empty();\n        dateVal = Optional.empty();\n    }\n\n    public boolean isEmpty() {\n        return !stringVal.isPresent()\n                && !longVal.isPresent()\n                && !doubleVal.isPresent()\n                && !dateVal.isPresent()\n                && !booleanVal.isPresent();\n    }\n\n    @SuppressWarnings(\"squid:S00115\")\n    public static enum CellType {\n        // POI switches from int-based to enum-based constants, and unfortunately they also removed things along the way.\n        // This bridges the gap between the constants and the enum types.\n        // _NONE is used to match POI 4, see https://poi.apache.org/apidocs/4.0/org/apache/poi/ss/usermodel/CellType.html\n        // therefore ignoring the code climate issue for this\n        _NONE(3), NUMERIC(0), STRING(1), FORMULA(2), BLANK(3), BOOLEAN(4), ERROR(5);\n        int ord;\n        CellType(int ord) {\n            this.ord=ord;\n        }\n\n        public static CellType fromObject(Object o) {\n            if (o.getClass() == String.class || o.getClass().isEnum()) {\n                return CellType.valueOf(o.toString());\n            } else {\n                int num = (Integer) o;\n                for (CellType ct:values()) {\n                    if (ct.ord == num) {\n                        return ct;\n                    }\n                }\n                return null;\n            }\n        }\n    }\n\n    private void setValue(Cell cell, Locale locale) {\n        try {\n            // Use reflection to access the method as it changes return type from int to CellType in 4.x\n            CellType cellType = CellType.fromObject(MethodUtils.invokeMethod(cell, \"getCellType\"));\n            if (cellType == CellType.FORMULA) {\n                // Use reflection to access the method as it changes return type from int to CellType in 4.x\n                cellType = CellType.fromObject(MethodUtils.invokeMethod(cell,\"getCachedFormulaResultType\"));\n            }\n            switch (cellType) {\n                case BOOLEAN:\n                    setValue(cell.getBooleanCellValue());\n                    break;\n                case NUMERIC:\n                    double number = cell.getNumericCellValue();\n                    if (Math.floor(number) == number) {\n                        setValue((long) number);\n                    } else {\n                        setValue(number);\n                    }\n                    if (DateUtil.isCellDateFormatted(cell)) {\n                        setValue(cell.getDateCellValue());\n                        baseType = Calendar.class;\n                    }\n                    DataFormatter dataFormatter = new DataFormatter(locale);\n                    if (cellType == CellType.FORMULA) {\n                        setValue(dataFormatter.formatCellValue(cell));\n                    } else {\n                        CellStyle cellStyle = cell.getCellStyle();\n                        setValue(dataFormatter.formatRawCellContents(\n                                cell.getNumericCellValue(),\n                                cellStyle.getDataFormat(),\n                                cellStyle.getDataFormatString()\n                        ));\n                    }\n                    break;\n                case STRING:\n                    setValue(cell.getStringCellValue().trim());\n                    break;\n                case BLANK:\n                default:\n                    clear();\n                    break;\n            }\n        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {\n            Logger.getLogger(Variant.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    @SuppressWarnings(\"squid:S3776\")\n    public final <T> void setValue(T val) {\n        if (val == null) {\n            return;\n        }\n        Class valueType = val.getClass();\n        if (valueType == Variant.class) {\n            Variant v = (Variant) val;\n            longVal = v.longVal;\n            doubleVal = v.doubleVal;\n            stringVal = v.stringVal;\n            booleanVal = v.booleanVal;\n            dateVal = v.dateVal;\n            this.baseType = v.baseType;\n        } else if (valueType == Byte.TYPE || valueType == Byte.class) {\n            setLongVal(((Byte) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Integer.TYPE || valueType == Integer.class) {\n            setLongVal(((Integer) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Long.TYPE || valueType == Long.class) {\n            setLongVal((Long) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Short.TYPE || valueType == Short.class) {\n            setLongVal(((Short) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Float.TYPE || valueType == Float.class\n                || valueType == Double.TYPE || valueType == Double.class) {\n            setDoubleVal((Double) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Double.TYPE;\n            }\n        } else if (valueType == Boolean.TYPE || valueType == Boolean.class) {\n            setBooleanVal((Boolean) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Boolean.TYPE;\n            }\n        } else if (valueType == String.class) {\n            setStringVal((String) val);\n            if (baseType == null) {\n                baseType = String.class;\n            }\n        } else if (valueType == Date.class) {\n            setDateVal((Date) val);\n            baseType = Calendar.class;\n        } else if (valueType == Instant.class) {\n            setDateVal(new Date(((Instant) val).toEpochMilli()));\n            baseType = Calendar.class;\n        } else if (Calendar.class.isAssignableFrom(valueType)) {\n            setDateVal(((Calendar) val).getTime());\n            baseType = Calendar.class;\n        } else {\n            setStringVal(String.valueOf(val));\n            if (baseType == null) {\n                baseType = String.class;\n            }\n        }\n    }\n\n    private void setLongVal(Long l) {\n        longVal = l == null ? Optional.empty() : Optional.of(l);\n    }\n\n    private void setDoubleVal(Double d) {\n        doubleVal = d == null ? Optional.empty() : Optional.of(d);\n    }\n\n    private void setStringVal(String s) {\n        if (s != null && !s.isEmpty()) {\n            stringVal = Optional.of(s);\n        } else {\n            stringVal = Optional.empty();\n        }\n    }\n\n    private void setBooleanVal(Boolean b) {\n        booleanVal = b == null ? Optional.empty() : Optional.of(b);\n    }\n\n    private void setDateVal(Date d) {\n        dateVal = d == null ? Optional.empty() : Optional.of(d);\n    }\n\n    public Long toLong() {\n        return longVal.orElse(dateVal.map(Date::getTime)\n                .orElse(doubleVal.map(Double::longValue)\n                        .orElse(booleanVal.map(b -> (Long) (b ? 1L : 0L))\n                                .orElseGet(() -> {\n                                    try {\n                                        return stringVal.map(s -> (long) Double.parseDouble(s)).orElse(null);\n                                    } catch (NumberFormatException ex) {\n                                        return null;\n                                    }\n                                }))));\n    }\n\n    public Double toDouble() {\n        return doubleVal.orElse(longVal.map(Long::doubleValue)\n                .orElse(booleanVal.map(b -> (Double) (b ? 1.0 : 0.0))\n                        .orElseGet(() -> {\n                            try {\n                                return stringVal.map(Double::parseDouble).orElse(null);\n                            } catch (NumberFormatException ex) {\n                                return null;\n                            }\n                        })));\n    }\n\n    @Override\n    public String toString() {\n        return stringVal.orElse(dateVal.map(STANDARD_DATE_FORMAT::format)\n                .orElse(doubleVal.map(String::valueOf)\n                        .orElse(longVal.map(String::valueOf)\n                                .orElse(booleanVal.map(String::valueOf)\n                                        .orElse(null)))));\n    }\n\n    public Date toDate() {\n        return dateVal.orElse(longVal.map(Date::new)\n                .orElse(stringVal.map(s -> {\n                    for (FastDateFormat format : DATE_FORMATS) {\n                        try {\n                            return format.parse(s);\n                        } catch (ParseException ex) {\n                            // No good, go to the next pattern\n                        }\n                    }\n                    return null;\n                }).orElse(null)));\n    }\n\n    public Boolean toBoolean() {\n        return booleanVal.orElse(longVal.map(l -> l != 0)\n                .orElse(doubleVal.map(d -> d != 0)\n                        .orElse(stringVal.map(this::isStringTruthy)\n                                .orElse(null))));\n    }\n\n    /**\n     * Truthiness is any non-empty string that looks like a non-zero number or\n     * looks like it is True, Yes, or X\n     *\n     * @param s String to evaluate\n     * @return True if it is truthy, otherwise false\n     */\n    public boolean isStringTruthy(String s) {\n        if (s == null || s.trim().isEmpty()) {\n            return false;\n        } else if (StringUtils.isNumeric(s)) {\n            return Long.parseLong(s) != 0;\n        } else {\n            char c = s.trim().toLowerCase().charAt(0);\n            return (c == 't' || c == 'y' || c == 'x');\n        }\n    }\n\n    private <U, T> T apply(U value, Function<U, T> func) {\n        return value == null ? null : func.apply(value);\n    }\n\n    @SuppressWarnings(\"squid:S3776\")\n    public <T> T asType(Class<T> type) {\n        if (type == Byte.TYPE || type == Byte.class) {\n            return (T) apply(toLong(), Long::byteValue);\n        } else if (type == Integer.TYPE || type == Integer.class) {\n            return (T) apply(toLong(), Long::intValue);\n        } else if (type == Long.TYPE || type == Long.class) {\n            return (T) toLong();\n        } else if (type == Short.TYPE || type == Short.class) {\n            return (T) apply(toLong(), Long::shortValue);\n        } else if (type == Float.TYPE || type == Float.class) {\n            return (T) apply(toDouble(), Double::floatValue);\n        } else if (type == Double.TYPE || type == Double.class) {\n            return (T) toDouble();\n        } else if (type == Boolean.TYPE || type == Boolean.class) {\n            return (T) toBoolean();\n        } else if (type == String.class) {\n            return (T) toString();\n        } else if (type == Date.class) {\n            return (T) toDate();\n        } else if (type == Instant.class) {\n            return (T) toDate().toInstant();\n        } else if (Calendar.class.isAssignableFrom(type)) {\n            Calendar c = Calendar.getInstance();\n            c.setTime(toDate());\n            return (T) c;\n        } else {\n            return null;\n        }\n    }\n\n    public static <S, D> D convert(S val, Class<D> destType) {\n        Variant v = new Variant(val);\n        return v.asType(destType);\n    }\n\n    Class getBaseType() {\n        return baseType;\n    }\n}\n"
    },
    "context": [],
    "unresolved_context": [
      "java.lang.reflect.InvocationTargetException",
      "java.text.ParseException",
      "java.time.Instant",
      "java.util.Calendar",
      "java.util.Date",
      "java.util.Locale",
      "java.util.Optional",
      "java.util.function.Function",
      "java.util.logging.Level",
      "java.util.logging.Logger",
      "org.apache.commons.lang.StringUtils",
      "org.apache.commons.lang3.reflect.MethodUtils",
      "org.apache.commons.lang3.time.FastDateFormat",
      "org.apache.poi.ss.usermodel.Cell",
      "org.apache.poi.ss.usermodel.CellStyle",
      "org.apache.poi.ss.usermodel.DataFormatter",
      "org.apache.poi.ss.usermodel.DateUtil",
      "org.osgi.annotation.versioning.ProviderType"
    ]
  },
  "output": {
    "language": "Java",
    "fixed_commit_message": "Reduce usage of Apache Commons Lang 2\nThis fixes #3408",
    "fixed_file": {
      "fixed_filename": "bundle/src/main/java/com/adobe/acs/commons/data/Variant.java",
      "fixed_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.data;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.text.ParseException;\nimport java.time.Instant;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.CellStyle;\nimport org.apache.poi.ss.usermodel.DataFormatter;\nimport org.apache.poi.ss.usermodel.DateUtil;\nimport org.osgi.annotation.versioning.ProviderType;\n\n/**\n * Used to represent values that might be provided as one baseType but used as\n * another. Avoids glue code and switch statements in other parts of the code\n * especially dealing with data from spreadsheets.\n */\n@ProviderType\npublic final class Variant {\n\n    private Class baseType = null;\n    private static final Locale STANDARD_LOCALE = Locale.ROOT;\n    private static final FastDateFormat STANDARD_DATE_FORMAT = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, STANDARD_LOCALE);\n    private Optional<Long> longVal = Optional.empty();\n    private Optional<Double> doubleVal = Optional.empty();\n    private Optional<String> stringVal = Optional.empty();\n    private Optional<Boolean> booleanVal = Optional.empty();\n    private Optional<Date> dateVal = Optional.empty();\n\n    private static final FastDateFormat[] DATE_FORMATS = {\n            FastDateFormat.getDateInstance(FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getDateInstance(FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getTimeInstance(FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getTimeInstance(FastDateFormat.LONG, STANDARD_LOCALE),\n            STANDARD_DATE_FORMAT,\n            FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, STANDARD_LOCALE),\n            FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", STANDARD_LOCALE)\n    };\n\n    public Variant() {\n    }\n\n    public <T> Variant(T src) {\n        setValue(src);\n    }\n\n    public Variant(Cell src) {\n        this(src, Locale.getDefault());\n    }\n\n    public Variant(Cell src, Locale locale) {\n        setValue(src, locale);\n    }\n\n    public void clear() {\n        longVal = Optional.empty();\n        doubleVal = Optional.empty();\n        stringVal = Optional.empty();\n        booleanVal = Optional.empty();\n        dateVal = Optional.empty();\n    }\n\n    public boolean isEmpty() {\n        return !stringVal.isPresent()\n                && !longVal.isPresent()\n                && !doubleVal.isPresent()\n                && !dateVal.isPresent()\n                && !booleanVal.isPresent();\n    }\n\n    @SuppressWarnings(\"squid:S00115\")\n    public static enum CellType {\n        // POI switches from int-based to enum-based constants, and unfortunately they also removed things along the way.\n        // This bridges the gap between the constants and the enum types.\n        // _NONE is used to match POI 4, see https://poi.apache.org/apidocs/4.0/org/apache/poi/ss/usermodel/CellType.html\n        // therefore ignoring the code climate issue for this\n        _NONE(3), NUMERIC(0), STRING(1), FORMULA(2), BLANK(3), BOOLEAN(4), ERROR(5);\n        int ord;\n        CellType(int ord) {\n            this.ord=ord;\n        }\n\n        public static CellType fromObject(Object o) {\n            if (o.getClass() == String.class || o.getClass().isEnum()) {\n                return CellType.valueOf(o.toString());\n            } else {\n                int num = (Integer) o;\n                for (CellType ct:values()) {\n                    if (ct.ord == num) {\n                        return ct;\n                    }\n                }\n                return null;\n            }\n        }\n    }\n\n    private void setValue(Cell cell, Locale locale) {\n        try {\n            // Use reflection to access the method as it changes return type from int to CellType in 4.x\n            CellType cellType = CellType.fromObject(MethodUtils.invokeMethod(cell, \"getCellType\"));\n            if (cellType == CellType.FORMULA) {\n                // Use reflection to access the method as it changes return type from int to CellType in 4.x\n                cellType = CellType.fromObject(MethodUtils.invokeMethod(cell,\"getCachedFormulaResultType\"));\n            }\n            switch (cellType) {\n                case BOOLEAN:\n                    setValue(cell.getBooleanCellValue());\n                    break;\n                case NUMERIC:\n                    double number = cell.getNumericCellValue();\n                    if (Math.floor(number) == number) {\n                        setValue((long) number);\n                    } else {\n                        setValue(number);\n                    }\n                    if (DateUtil.isCellDateFormatted(cell)) {\n                        setValue(cell.getDateCellValue());\n                        baseType = Calendar.class;\n                    }\n                    DataFormatter dataFormatter = new DataFormatter(locale);\n                    if (cellType == CellType.FORMULA) {\n                        setValue(dataFormatter.formatCellValue(cell));\n                    } else {\n                        CellStyle cellStyle = cell.getCellStyle();\n                        setValue(dataFormatter.formatRawCellContents(\n                                cell.getNumericCellValue(),\n                                cellStyle.getDataFormat(),\n                                cellStyle.getDataFormatString()\n                        ));\n                    }\n                    break;\n                case STRING:\n                    setValue(cell.getStringCellValue().trim());\n                    break;\n                case BLANK:\n                default:\n                    clear();\n                    break;\n            }\n        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {\n            Logger.getLogger(Variant.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    @SuppressWarnings(\"squid:S3776\")\n    public final <T> void setValue(T val) {\n        if (val == null) {\n            return;\n        }\n        Class valueType = val.getClass();\n        if (valueType == Variant.class) {\n            Variant v = (Variant) val;\n            longVal = v.longVal;\n            doubleVal = v.doubleVal;\n            stringVal = v.stringVal;\n            booleanVal = v.booleanVal;\n            dateVal = v.dateVal;\n            this.baseType = v.baseType;\n        } else if (valueType == Byte.TYPE || valueType == Byte.class) {\n            setLongVal(((Byte) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Integer.TYPE || valueType == Integer.class) {\n            setLongVal(((Integer) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Long.TYPE || valueType == Long.class) {\n            setLongVal((Long) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Short.TYPE || valueType == Short.class) {\n            setLongVal(((Short) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Float.TYPE || valueType == Float.class\n                || valueType == Double.TYPE || valueType == Double.class) {\n            setDoubleVal((Double) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Double.TYPE;\n            }\n        } else if (valueType == Boolean.TYPE || valueType == Boolean.class) {\n            setBooleanVal((Boolean) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Boolean.TYPE;\n            }\n        } else if (valueType == String.class) {\n            setStringVal((String) val);\n            if (baseType == null) {\n                baseType = String.class;\n            }\n        } else if (valueType == Date.class) {\n            setDateVal((Date) val);\n            baseType = Calendar.class;\n        } else if (valueType == Instant.class) {\n            setDateVal(new Date(((Instant) val).toEpochMilli()));\n            baseType = Calendar.class;\n        } else if (Calendar.class.isAssignableFrom(valueType)) {\n            setDateVal(((Calendar) val).getTime());\n            baseType = Calendar.class;\n        } else {\n            setStringVal(String.valueOf(val));\n            if (baseType == null) {\n                baseType = String.class;\n            }\n        }\n    }\n\n    private void setLongVal(Long l) {\n        longVal = l == null ? Optional.empty() : Optional.of(l);\n    }\n\n    private void setDoubleVal(Double d) {\n        doubleVal = d == null ? Optional.empty() : Optional.of(d);\n    }\n\n    private void setStringVal(String s) {\n        if (s != null && !s.isEmpty()) {\n            stringVal = Optional.of(s);\n        } else {\n            stringVal = Optional.empty();\n        }\n    }\n\n    private void setBooleanVal(Boolean b) {\n        booleanVal = b == null ? Optional.empty() : Optional.of(b);\n    }\n\n    private void setDateVal(Date d) {\n        dateVal = d == null ? Optional.empty() : Optional.of(d);\n    }\n\n    public Long toLong() {\n        return longVal.orElse(dateVal.map(Date::getTime)\n                .orElse(doubleVal.map(Double::longValue)\n                        .orElse(booleanVal.map(b -> (Long) (b ? 1L : 0L))\n                                .orElseGet(() -> {\n                                    try {\n                                        return stringVal.map(s -> (long) Double.parseDouble(s)).orElse(null);\n                                    } catch (NumberFormatException ex) {\n                                        return null;\n                                    }\n                                }))));\n    }\n\n    public Double toDouble() {\n        return doubleVal.orElse(longVal.map(Long::doubleValue)\n                .orElse(booleanVal.map(b -> (Double) (b ? 1.0 : 0.0))\n                        .orElseGet(() -> {\n                            try {\n                                return stringVal.map(Double::parseDouble).orElse(null);\n                            } catch (NumberFormatException ex) {\n                                return null;\n                            }\n                        })));\n    }\n\n    @Override\n    public String toString() {\n        return stringVal.orElse(dateVal.map(STANDARD_DATE_FORMAT::format)\n                .orElse(doubleVal.map(String::valueOf)\n                        .orElse(longVal.map(String::valueOf)\n                                .orElse(booleanVal.map(String::valueOf)\n                                        .orElse(null)))));\n    }\n\n    public Date toDate() {\n        return dateVal.orElse(longVal.map(Date::new)\n                .orElse(stringVal.map(s -> {\n                    for (FastDateFormat format : DATE_FORMATS) {\n                        try {\n                            return format.parse(s);\n                        } catch (ParseException ex) {\n                            // No good, go to the next pattern\n                        }\n                    }\n                    return null;\n                }).orElse(null)));\n    }\n\n    public Boolean toBoolean() {\n        return booleanVal.orElse(longVal.map(l -> l != 0)\n                .orElse(doubleVal.map(d -> d != 0)\n                        .orElse(stringVal.map(this::isStringTruthy)\n                                .orElse(null))));\n    }\n\n    /**\n     * Truthiness is any non-empty string that looks like a non-zero number or\n     * looks like it is True, Yes, or X\n     *\n     * @param s String to evaluate\n     * @return True if it is truthy, otherwise false\n     */\n    public boolean isStringTruthy(String s) {\n        if (s == null || s.trim().isEmpty()) {\n            return false;\n        } else if (StringUtils.isNumeric(s)) {\n            return Long.parseLong(s) != 0;\n        } else {\n            char c = s.trim().toLowerCase().charAt(0);\n            return (c == 't' || c == 'y' || c == 'x');\n        }\n    }\n\n    private <U, T> T apply(U value, Function<U, T> func) {\n        return value == null ? null : func.apply(value);\n    }\n\n    @SuppressWarnings(\"squid:S3776\")\n    public <T> T asType(Class<T> type) {\n        if (type == Byte.TYPE || type == Byte.class) {\n            return (T) apply(toLong(), Long::byteValue);\n        } else if (type == Integer.TYPE || type == Integer.class) {\n            return (T) apply(toLong(), Long::intValue);\n        } else if (type == Long.TYPE || type == Long.class) {\n            return (T) toLong();\n        } else if (type == Short.TYPE || type == Short.class) {\n            return (T) apply(toLong(), Long::shortValue);\n        } else if (type == Float.TYPE || type == Float.class) {\n            return (T) apply(toDouble(), Double::floatValue);\n        } else if (type == Double.TYPE || type == Double.class) {\n            return (T) toDouble();\n        } else if (type == Boolean.TYPE || type == Boolean.class) {\n            return (T) toBoolean();\n        } else if (type == String.class) {\n            return (T) toString();\n        } else if (type == Date.class) {\n            return (T) toDate();\n        } else if (type == Instant.class) {\n            return (T) toDate().toInstant();\n        } else if (Calendar.class.isAssignableFrom(type)) {\n            Calendar c = Calendar.getInstance();\n            c.setTime(toDate());\n            return (T) c;\n        } else {\n            return null;\n        }\n    }\n\n    public static <S, D> D convert(S val, Class<D> destType) {\n        Variant v = new Variant(val);\n        return v.asType(destType);\n    }\n\n    Class getBaseType() {\n        return baseType;\n    }\n}\n"
    },
    "context": [],
    "unresolved_context": [
      "java.lang.reflect.InvocationTargetException",
      "java.text.ParseException",
      "java.time.Instant",
      "java.util.Calendar",
      "java.util.Date",
      "java.util.Locale",
      "java.util.Optional",
      "java.util.function.Function",
      "java.util.logging.Level",
      "java.util.logging.Logger",
      "org.apache.commons.lang3.StringUtils",
      "org.apache.commons.lang3.reflect.MethodUtils",
      "org.apache.commons.lang3.time.FastDateFormat",
      "org.apache.poi.ss.usermodel.Cell",
      "org.apache.poi.ss.usermodel.CellStyle",
      "org.apache.poi.ss.usermodel.DataFormatter",
      "org.apache.poi.ss.usermodel.DateUtil",
      "org.osgi.annotation.versioning.ProviderType"
    ],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -27,7 +27,7 @@\n import java.util.function.Function;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.reflect.MethodUtils;\n import org.apache.commons.lang3.time.FastDateFormat;\n import org.apache.poi.ss.usermodel.Cell;"
  }
}