{
  "repo": {
    "name": "Adobe-Consulting-Services/acs-aem-commons",
    "buggy_commit": "a2cf90935d6166680ad85a9ac045e5060bf202ac",
    "fixed_commit": "be4c5995f48fb4b25d56d6b20485d28d62d76479"
  },
  "input": {
    "language": "Java",
    "issue": {
      "issue_title": "Reduce usage of Apache Commons Lang 2",
      "issue_description": "\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n"
    },
    "buggy_commit_message": "Merge branch 'Adobe-Consulting-Services:master' into master",
    "buggy_file": {
      "buggy_filename": "bundle/src/main/java/com/adobe/acs/commons/audit_log_search/impl/AuditLogSearchServlet.java",
      "buggy_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.audit_log_search.impl;\n\nimport com.adobe.acs.commons.audit_log_search.AuditLogSearchRequest;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.sling.SlingServlet;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.SlingHttpServletResponse;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.api.resource.ValueMap;\nimport org.apache.sling.api.servlets.HttpConstants;\nimport org.apache.sling.api.servlets.SlingSafeMethodsServlet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.NodeIterator;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.query.Query;\nimport javax.jcr.query.QueryManager;\nimport javax.servlet.ServletException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@SlingServlet(\n        methods = {HttpConstants.METHOD_GET},\n        resourceTypes = {\"acs-commons/components/utilities/audit-log-search\"},\n        selectors = {\"auditlogsearch\"},\n        extensions = {\"json\"})\n@SuppressWarnings(\"serial\")\npublic class AuditLogSearchServlet extends SlingSafeMethodsServlet {\n\n    private static final Logger log = LoggerFactory.getLogger(AuditLogSearchServlet.class);\n\n    @Override\n    @SuppressWarnings(\"squid:S1141\")\n    protected final void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)\n            throws ServletException, IOException {\n\n        log.trace(\"doGet\");\n\n        AuditLogSearchRequest req = null;\n\n        JsonObject result = new JsonObject();\n        boolean succeeded = true;\n        try {\n            req = new AuditLogSearchRequest(request);\n            log.debug(\"Loaded search request: {}\", req);\n\n            JsonArray results = new JsonArray();\n            long count = 0;\n            String whereClause = req.getQueryParameters();\n            StringBuilder queryBuilder = new StringBuilder(\"SELECT * FROM [cq:AuditEvent] AS s\");\n            if (StringUtils.isNotEmpty(whereClause)) {\n                queryBuilder.append(\" WHERE \").append(whereClause);\n            }\n            String queryStr = queryBuilder.toString();\n            log.debug(\"Finding audit events with: {}\", queryStr);\n            ResourceResolver resolver = request.getResourceResolver();\n            QueryManager queryManager = resolver.adaptTo(Session.class).getWorkspace().getQueryManager();\n            Query query = queryManager.createQuery(queryStr, Query.JCR_SQL2);\n\n            int limit = -1;\n            if (StringUtils.isNotEmpty(request.getParameter(\"limit\"))) {\n                limit = Integer.parseInt(request.getParameter(\"limit\"), 10);\n                if (limit > 0) {\n                    log.debug(\"Limiting to {} results\", limit);\n                    query.setLimit(limit);\n                }\n            }\n\n            NodeIterator nodes = query.execute().getNodes();\n            log.debug(\"Query execution complete!\");\n            while (nodes.hasNext()) {\n                results.add(serializeAuditEvent(resolver.getResource(nodes.nextNode().getPath()), req));\n                count++;\n            }\n            result.addProperty(\"count\", count);\n            result.add(\"events\", results);\n            log.debug(\"Found {} audit events\", count);\n        } catch (ParseException e) {\n            log.warn(\"Encountered exception parsing start / end date\", e);\n            succeeded = false;\n        } catch (RepositoryException e) {\n            log.warn(\"Encountered respository exception attempting to retrieve audit events\", e);\n            succeeded = false;\n        } catch (ClassNotFoundException e) {\n            log.warn(\"Encountered exception deserializing attributes\", e);\n            succeeded = false;\n        }\n\n        result.addProperty(\"succeeded\", succeeded);\n\n        response.setContentType(\"application/json\");\n        response.getWriter().write(result.toString());\n    }\n\n    private JsonObject serializeAuditEvent(Resource auditEventResource, AuditLogSearchRequest request)\n            throws RepositoryException, IOException, ClassNotFoundException {\n        JsonObject auditEvent = new JsonObject();\n        ValueMap properties = auditEventResource.getValueMap();\n        auditEvent.addProperty(\"category\", properties.get(\"cq:category\", String.class));\n        auditEvent.addProperty(\"eventPath\", auditEventResource.getPath());\n        auditEvent.addProperty(\"path\", properties.get(\"cq:path\", String.class));\n        auditEvent.addProperty(\"type\", properties.get(\"cq:type\", String.class));\n        String userId = properties.get(\"cq:userid\", String.class);\n        auditEvent.addProperty(\"userId\", userId);\n        auditEvent.addProperty(\"userName\", request.getUserName(auditEventResource.getResourceResolver(), userId));\n        auditEvent.addProperty(\"userPath\", request.getUserPath(auditEventResource.getResourceResolver(), userId));\n        auditEvent.addProperty(\"time\", properties.get(\"cq:time\", new Date()).getTime());\n\n        JsonArray modified = getModifiedProperties(properties);\n        if (properties.get(\"above\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"above=\" + properties.get(\"above\", String.class)));\n        }\n        if (properties.get(\"destination\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"destination=\" + properties.get(\"destination\", String.class)));\n        }\n        if (properties.get(\"versionId\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"versionId=\" + properties.get(\"versionId\", String.class)));\n        }\n        if (modified.size() != 0) {\n            auditEvent.add(\"modified\", modified);\n        }\n\n        return auditEvent;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private JsonArray getModifiedProperties(ValueMap properties) throws IOException {\n        JsonArray modifiedProperties = new JsonArray();\n        InputStream is = properties.get(\"cq:properties\", InputStream.class);\n        if (is != null) {\n            ObjectInputStream ois = new ObjectInputStream(is);\n            ois.readInt();\n\n            while (ois.available() != -1) {\n                try {\n                    Object obj = ois.readObject();\n                    if (obj instanceof HashSet) {\n                        Set<String> propertiesSet = (Set<String>) obj;\n                        for (String property : propertiesSet) {\n                            modifiedProperties.add(new JsonPrimitive(property));\n                        }\n                        break;\n                    }\n                } catch (Exception e) {\n                    break;\n                }\n            }\n        }\n        return modifiedProperties;\n    }\n\n}\n"
    },
    "context": [
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/audit_log_search/AuditLogSearchRequest.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.audit_log_search;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.TimeZone;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.UnsupportedRepositoryOperationException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport org.apache.jackrabbit.api.security.user.Authorizable;\nimport org.apache.jackrabbit.api.security.user.UserManager;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\n\nimport com.adobe.granite.security.user.UserProperties;\nimport com.adobe.granite.security.user.UserPropertiesManager;\nimport com.adobe.granite.security.user.UserPropertiesService;\n\n/**\n * Simple POJO for audit log requests. Handles some of the crufty code around\n * loading and generating the query.\n */\npublic class AuditLogSearchRequest {\n\n    private static final FastDateFormat HTML5_DATETIME_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm\", TimeZone.getTimeZone(\"GMT\"));\n    private static final FastDateFormat QUERY_DATE_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\", TimeZone.getTimeZone(\"GMT\"));\n\n    private static String getJcrSqlDate(Date date) {\n        return QUERY_DATE_FORMAT.format(date) + \".000Z\";\n    }\n\n    private final String contentRoot;\n    private final boolean includeChildren;\n    private final String type;\n    private final String user;\n    private final Date startDate;\n    private final Date endDate;\n    private final String order;\n    private Map<String, String> userNames = new HashMap<String, String>();\n\n    private Map<String, String> userPaths = new HashMap<String, String>();\n\n    /**\n     * Constructs a new AuditLogSearchRequest from the SlingHttpServletRequest\n     *\n     * @param request\n     *            yep, that's a request... guess what it does\n     * @throws ParseException\n     *             an exception occurred parsing the start / end date\n     */\n    public AuditLogSearchRequest(SlingHttpServletRequest request) throws ParseException {\n        contentRoot = request.getParameter(\"contentRoot\");\n        includeChildren = \"true\".equals(request.getParameter(\"includeChildren\"));\n        type = request.getParameter(\"type\");\n        user = request.getParameter(\"user\");\n        startDate = loadDate(request.getParameter(\"startDate\"));\n        endDate = loadDate(request.getParameter(\"endDate\"));\n        order = request.getParameter(\"order\");\n    }\n\n    public String getContentRoot() {\n        return contentRoot;\n    }\n\n    public Date getEndDate() {\n        return Optional.ofNullable(endDate)\n                .map(date -> (Date) date.clone())\n                .orElse(null);\n    }\n\n    public String getOrder() {\n        return order;\n    }\n\n    public String getQueryParameters() {\n        List<String> expressions = new ArrayList<String>();\n\n        if (!StringUtils.isEmpty(type)) {\n            expressions.add(\"[cq:type]='\" + StringUtils.replace(type, \"'\", \"''\") + \"'\");\n        }\n        if (!StringUtils.isEmpty(user)) {\n            expressions.add(\"[cq:userid]='\" + StringUtils.replace(user, \"'\", \"''\") + \"'\");\n        }\n        if (StringUtils.isNotEmpty(contentRoot)) {\n            if (includeChildren) {\n                expressions.add(\"[cq:path] LIKE '\" + StringUtils.replace(contentRoot, \"'\", \"''\") + \"%'\");\n            } else {\n                expressions.add(\"[cq:path]='\" + StringUtils.replace(contentRoot, \"'\", \"''\") + \"'\");\n            }\n        }\n        if (startDate != null) {\n            expressions.add(\"[cq:time] > CAST('\" + getJcrSqlDate(startDate) + \"' AS DATE)\");\n        }\n        if (endDate != null) {\n            expressions.add(\"[cq:time] < CAST('\" + getJcrSqlDate(endDate) + \"' AS DATE)\");\n        }\n        String query = StringUtils.join(expressions, \" AND \");\n        if (!StringUtils.isEmpty(order)) {\n            query += \" ORDER BY \" + order;\n        }\n        return query;\n    }\n\n    public Date getStartDate() {\n        return Optional.ofNullable(startDate)\n                .map(date -> (Date) date.clone())\n                .orElse(null);\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getUser() {\n        return user;\n    }\n\n    public String getUserName(ResourceResolver resolver, String userId) throws RepositoryException {\n        if (!userNames.containsKey(userId)) {\n            final UserPropertiesManager upm = resolver.adaptTo(UserPropertiesManager.class);\n            UserProperties userProperties = upm.getUserProperties(userId, UserPropertiesService.PRIVATE_PROFILE);\n            String name = userId;\n            if (userProperties != null && !StringUtils.isEmpty(userProperties.getDisplayName())) {\n                name = userProperties.getDisplayName();\n            }\n            userNames.put(userId, name);\n        }\n        return userNames.get(userId);\n    }\n\n    public String getUserPath(ResourceResolver resolver, String userId)\n            throws UnsupportedRepositoryOperationException, RepositoryException {\n        if (!userPaths.containsKey(userId)) {\n            final UserManager userManager = resolver.adaptTo(UserManager.class);\n            if (userManager != null) {\n                final Authorizable usr = userManager.getAuthorizable(userId);\n                if (usr != null) {\n                    userPaths.put(userId, usr.getPath());\n                }\n            }\n        }\n        return userPaths.get(userId);\n    }\n\n    public boolean isIncludehildren() {\n        return includeChildren;\n    }\n\n    private Date loadDate(String dateStr) throws ParseException {\n        Date date = null;\n        if (!StringUtils.isEmpty(dateStr)) {\n            date = HTML5_DATETIME_FORMAT.parse(dateStr);\n        }\n        return date;\n    }\n\n    @Override\n    public String toString() {\n        return \"AuditLogSearchRequest [contentRoot=\" + contentRoot + \", includeChildren=\" + includeChildren + \", type=\"\n                + type + \", user=\" + user + \", startDate=\" + startDate + \", endDate=\" + endDate + \", order=\" + order\n                + \", userNames=\" + userNames + \", userPaths=\" + userPaths + \"]\";\n    }\n\n}\n"
      }
    ],
    "unresolved_context": [
      "com.google.gson.JsonArray",
      "com.google.gson.JsonObject",
      "com.google.gson.JsonPrimitive",
      "org.apache.commons.lang.StringUtils",
      "org.apache.felix.scr.annotations.sling.SlingServlet",
      "org.apache.sling.api.SlingHttpServletRequest",
      "org.apache.sling.api.SlingHttpServletResponse",
      "org.apache.sling.api.resource.Resource",
      "org.apache.sling.api.resource.ResourceResolver",
      "org.apache.sling.api.resource.ValueMap",
      "org.apache.sling.api.servlets.HttpConstants",
      "org.apache.sling.api.servlets.SlingSafeMethodsServlet",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.NodeIterator",
      "javax.jcr.RepositoryException",
      "javax.jcr.Session",
      "javax.jcr.query.Query",
      "javax.jcr.query.QueryManager",
      "javax.servlet.ServletException",
      "java.io.IOException",
      "java.io.InputStream",
      "java.io.ObjectInputStream",
      "java.text.ParseException",
      "java.util.Date",
      "java.util.HashSet",
      "java.util.Set"
    ]
  },
  "output": {
    "language": "Java",
    "fixed_commit_message": "Reduce usage of Apache Commons Lang 2\nThis fixes #3408",
    "fixed_file": {
      "fixed_filename": "bundle/src/main/java/com/adobe/acs/commons/audit_log_search/impl/AuditLogSearchServlet.java",
      "fixed_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.audit_log_search.impl;\n\nimport com.adobe.acs.commons.audit_log_search.AuditLogSearchRequest;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.felix.scr.annotations.sling.SlingServlet;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.SlingHttpServletResponse;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.api.resource.ValueMap;\nimport org.apache.sling.api.servlets.HttpConstants;\nimport org.apache.sling.api.servlets.SlingSafeMethodsServlet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.NodeIterator;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.query.Query;\nimport javax.jcr.query.QueryManager;\nimport javax.servlet.ServletException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@SlingServlet(\n        methods = {HttpConstants.METHOD_GET},\n        resourceTypes = {\"acs-commons/components/utilities/audit-log-search\"},\n        selectors = {\"auditlogsearch\"},\n        extensions = {\"json\"})\n@SuppressWarnings(\"serial\")\npublic class AuditLogSearchServlet extends SlingSafeMethodsServlet {\n\n    private static final Logger log = LoggerFactory.getLogger(AuditLogSearchServlet.class);\n\n    @Override\n    @SuppressWarnings(\"squid:S1141\")\n    protected final void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)\n            throws ServletException, IOException {\n\n        log.trace(\"doGet\");\n\n        AuditLogSearchRequest req = null;\n\n        JsonObject result = new JsonObject();\n        boolean succeeded = true;\n        try {\n            req = new AuditLogSearchRequest(request);\n            log.debug(\"Loaded search request: {}\", req);\n\n            JsonArray results = new JsonArray();\n            long count = 0;\n            String whereClause = req.getQueryParameters();\n            StringBuilder queryBuilder = new StringBuilder(\"SELECT * FROM [cq:AuditEvent] AS s\");\n            if (StringUtils.isNotEmpty(whereClause)) {\n                queryBuilder.append(\" WHERE \").append(whereClause);\n            }\n            String queryStr = queryBuilder.toString();\n            log.debug(\"Finding audit events with: {}\", queryStr);\n            ResourceResolver resolver = request.getResourceResolver();\n            QueryManager queryManager = resolver.adaptTo(Session.class).getWorkspace().getQueryManager();\n            Query query = queryManager.createQuery(queryStr, Query.JCR_SQL2);\n\n            int limit = -1;\n            if (StringUtils.isNotEmpty(request.getParameter(\"limit\"))) {\n                limit = Integer.parseInt(request.getParameter(\"limit\"), 10);\n                if (limit > 0) {\n                    log.debug(\"Limiting to {} results\", limit);\n                    query.setLimit(limit);\n                }\n            }\n\n            NodeIterator nodes = query.execute().getNodes();\n            log.debug(\"Query execution complete!\");\n            while (nodes.hasNext()) {\n                results.add(serializeAuditEvent(resolver.getResource(nodes.nextNode().getPath()), req));\n                count++;\n            }\n            result.addProperty(\"count\", count);\n            result.add(\"events\", results);\n            log.debug(\"Found {} audit events\", count);\n        } catch (ParseException e) {\n            log.warn(\"Encountered exception parsing start / end date\", e);\n            succeeded = false;\n        } catch (RepositoryException e) {\n            log.warn(\"Encountered respository exception attempting to retrieve audit events\", e);\n            succeeded = false;\n        } catch (ClassNotFoundException e) {\n            log.warn(\"Encountered exception deserializing attributes\", e);\n            succeeded = false;\n        }\n\n        result.addProperty(\"succeeded\", succeeded);\n\n        response.setContentType(\"application/json\");\n        response.getWriter().write(result.toString());\n    }\n\n    private JsonObject serializeAuditEvent(Resource auditEventResource, AuditLogSearchRequest request)\n            throws RepositoryException, IOException, ClassNotFoundException {\n        JsonObject auditEvent = new JsonObject();\n        ValueMap properties = auditEventResource.getValueMap();\n        auditEvent.addProperty(\"category\", properties.get(\"cq:category\", String.class));\n        auditEvent.addProperty(\"eventPath\", auditEventResource.getPath());\n        auditEvent.addProperty(\"path\", properties.get(\"cq:path\", String.class));\n        auditEvent.addProperty(\"type\", properties.get(\"cq:type\", String.class));\n        String userId = properties.get(\"cq:userid\", String.class);\n        auditEvent.addProperty(\"userId\", userId);\n        auditEvent.addProperty(\"userName\", request.getUserName(auditEventResource.getResourceResolver(), userId));\n        auditEvent.addProperty(\"userPath\", request.getUserPath(auditEventResource.getResourceResolver(), userId));\n        auditEvent.addProperty(\"time\", properties.get(\"cq:time\", new Date()).getTime());\n\n        JsonArray modified = getModifiedProperties(properties);\n        if (properties.get(\"above\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"above=\" + properties.get(\"above\", String.class)));\n        }\n        if (properties.get(\"destination\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"destination=\" + properties.get(\"destination\", String.class)));\n        }\n        if (properties.get(\"versionId\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"versionId=\" + properties.get(\"versionId\", String.class)));\n        }\n        if (modified.size() != 0) {\n            auditEvent.add(\"modified\", modified);\n        }\n\n        return auditEvent;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private JsonArray getModifiedProperties(ValueMap properties) throws IOException {\n        JsonArray modifiedProperties = new JsonArray();\n        InputStream is = properties.get(\"cq:properties\", InputStream.class);\n        if (is != null) {\n            ObjectInputStream ois = new ObjectInputStream(is);\n            ois.readInt();\n\n            while (ois.available() != -1) {\n                try {\n                    Object obj = ois.readObject();\n                    if (obj instanceof HashSet) {\n                        Set<String> propertiesSet = (Set<String>) obj;\n                        for (String property : propertiesSet) {\n                            modifiedProperties.add(new JsonPrimitive(property));\n                        }\n                        break;\n                    }\n                } catch (Exception e) {\n                    break;\n                }\n            }\n        }\n        return modifiedProperties;\n    }\n\n}\n"
    },
    "context": [
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/audit_log_search/AuditLogSearchRequest.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.audit_log_search;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.TimeZone;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.UnsupportedRepositoryOperationException;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport org.apache.jackrabbit.api.security.user.Authorizable;\nimport org.apache.jackrabbit.api.security.user.UserManager;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\n\nimport com.adobe.granite.security.user.UserProperties;\nimport com.adobe.granite.security.user.UserPropertiesManager;\nimport com.adobe.granite.security.user.UserPropertiesService;\n\n/**\n * Simple POJO for audit log requests. Handles some of the crufty code around\n * loading and generating the query.\n */\npublic class AuditLogSearchRequest {\n\n    private static final FastDateFormat HTML5_DATETIME_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm\", TimeZone.getTimeZone(\"GMT\"));\n    private static final FastDateFormat QUERY_DATE_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\", TimeZone.getTimeZone(\"GMT\"));\n\n    private static String getJcrSqlDate(Date date) {\n        return QUERY_DATE_FORMAT.format(date) + \".000Z\";\n    }\n\n    private final String contentRoot;\n    private final boolean includeChildren;\n    private final String type;\n    private final String user;\n    private final Date startDate;\n    private final Date endDate;\n    private final String order;\n    private Map<String, String> userNames = new HashMap<String, String>();\n\n    private Map<String, String> userPaths = new HashMap<String, String>();\n\n    /**\n     * Constructs a new AuditLogSearchRequest from the SlingHttpServletRequest\n     *\n     * @param request\n     *            yep, that's a request... guess what it does\n     * @throws ParseException\n     *             an exception occurred parsing the start / end date\n     */\n    public AuditLogSearchRequest(SlingHttpServletRequest request) throws ParseException {\n        contentRoot = request.getParameter(\"contentRoot\");\n        includeChildren = \"true\".equals(request.getParameter(\"includeChildren\"));\n        type = request.getParameter(\"type\");\n        user = request.getParameter(\"user\");\n        startDate = loadDate(request.getParameter(\"startDate\"));\n        endDate = loadDate(request.getParameter(\"endDate\"));\n        order = request.getParameter(\"order\");\n    }\n\n    public String getContentRoot() {\n        return contentRoot;\n    }\n\n    public Date getEndDate() {\n        return Optional.ofNullable(endDate)\n                .map(date -> (Date) date.clone())\n                .orElse(null);\n    }\n\n    public String getOrder() {\n        return order;\n    }\n\n    public String getQueryParameters() {\n        List<String> expressions = new ArrayList<String>();\n\n        if (!StringUtils.isEmpty(type)) {\n            expressions.add(\"[cq:type]='\" + StringUtils.replace(type, \"'\", \"''\") + \"'\");\n        }\n        if (!StringUtils.isEmpty(user)) {\n            expressions.add(\"[cq:userid]='\" + StringUtils.replace(user, \"'\", \"''\") + \"'\");\n        }\n        if (StringUtils.isNotEmpty(contentRoot)) {\n            if (includeChildren) {\n                expressions.add(\"[cq:path] LIKE '\" + StringUtils.replace(contentRoot, \"'\", \"''\") + \"%'\");\n            } else {\n                expressions.add(\"[cq:path]='\" + StringUtils.replace(contentRoot, \"'\", \"''\") + \"'\");\n            }\n        }\n        if (startDate != null) {\n            expressions.add(\"[cq:time] > CAST('\" + getJcrSqlDate(startDate) + \"' AS DATE)\");\n        }\n        if (endDate != null) {\n            expressions.add(\"[cq:time] < CAST('\" + getJcrSqlDate(endDate) + \"' AS DATE)\");\n        }\n        String query = StringUtils.join(expressions, \" AND \");\n        if (!StringUtils.isEmpty(order)) {\n            query += \" ORDER BY \" + order;\n        }\n        return query;\n    }\n\n    public Date getStartDate() {\n        return Optional.ofNullable(startDate)\n                .map(date -> (Date) date.clone())\n                .orElse(null);\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getUser() {\n        return user;\n    }\n\n    public String getUserName(ResourceResolver resolver, String userId) throws RepositoryException {\n        if (!userNames.containsKey(userId)) {\n            final UserPropertiesManager upm = resolver.adaptTo(UserPropertiesManager.class);\n            UserProperties userProperties = upm.getUserProperties(userId, UserPropertiesService.PRIVATE_PROFILE);\n            String name = userId;\n            if (userProperties != null && !StringUtils.isEmpty(userProperties.getDisplayName())) {\n                name = userProperties.getDisplayName();\n            }\n            userNames.put(userId, name);\n        }\n        return userNames.get(userId);\n    }\n\n    public String getUserPath(ResourceResolver resolver, String userId)\n            throws UnsupportedRepositoryOperationException, RepositoryException {\n        if (!userPaths.containsKey(userId)) {\n            final UserManager userManager = resolver.adaptTo(UserManager.class);\n            if (userManager != null) {\n                final Authorizable usr = userManager.getAuthorizable(userId);\n                if (usr != null) {\n                    userPaths.put(userId, usr.getPath());\n                }\n            }\n        }\n        return userPaths.get(userId);\n    }\n\n    public boolean isIncludehildren() {\n        return includeChildren;\n    }\n\n    private Date loadDate(String dateStr) throws ParseException {\n        Date date = null;\n        if (!StringUtils.isEmpty(dateStr)) {\n            date = HTML5_DATETIME_FORMAT.parse(dateStr);\n        }\n        return date;\n    }\n\n    @Override\n    public String toString() {\n        return \"AuditLogSearchRequest [contentRoot=\" + contentRoot + \", includeChildren=\" + includeChildren + \", type=\"\n                + type + \", user=\" + user + \", startDate=\" + startDate + \", endDate=\" + endDate + \", order=\" + order\n                + \", userNames=\" + userNames + \", userPaths=\" + userPaths + \"]\";\n    }\n\n}\n"
      }
    ],
    "unresolved_context": [
      "com.google.gson.JsonArray",
      "com.google.gson.JsonObject",
      "com.google.gson.JsonPrimitive",
      "org.apache.commons.lang3.StringUtils",
      "org.apache.felix.scr.annotations.sling.SlingServlet",
      "org.apache.sling.api.SlingHttpServletRequest",
      "org.apache.sling.api.SlingHttpServletResponse",
      "org.apache.sling.api.resource.Resource",
      "org.apache.sling.api.resource.ResourceResolver",
      "org.apache.sling.api.resource.ValueMap",
      "org.apache.sling.api.servlets.HttpConstants",
      "org.apache.sling.api.servlets.SlingSafeMethodsServlet",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.NodeIterator",
      "javax.jcr.RepositoryException",
      "javax.jcr.Session",
      "javax.jcr.query.Query",
      "javax.jcr.query.QueryManager",
      "javax.servlet.ServletException",
      "java.io.IOException",
      "java.io.InputStream",
      "java.io.ObjectInputStream",
      "java.text.ParseException",
      "java.util.Date",
      "java.util.HashSet",
      "java.util.Set"
    ],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -22,7 +22,7 @@\n import com.google.gson.JsonObject;\n import com.google.gson.JsonPrimitive;\n \n-import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.felix.scr.annotations.sling.SlingServlet;\n import org.apache.sling.api.SlingHttpServletRequest;\n import org.apache.sling.api.SlingHttpServletResponse;"
  }
}