{
  "repo": {
    "name": "3Hren/blackhole",
    "buggy_commit": "57814ff45d7bcdf306f8f085d0f6ad34561419c5",
    "fixed_commit": "a57bedad01ead02147a9f94a3b3c4050fa2e81a9"
  },
  "input": {
    "language": "C++",
    "issue": {
      "issue_title": "Hide string formatter binary interface",
      "issue_description": "To achieve the possibility of changing string formatter implementation or bug fixes without breaking the ABI it's important to hide that ABI. All other formatters/sinks have already been written in that way.\n\nNote, that this change will break `blackhole::formatter::string_t` API/ABI as it were described in https://github.com/3Hren/blackhole/milestones, but for now it's okay, because nobody uses it explicitly except the Blackhole internals.\n"
    },
    "buggy_commit_message": "refactor(builder): move to experimental\n\nTo be able to correctly handle backward compatibility I need to\ndistinguish between stable and unstable components. When an user\nincludes an experimental component he/she is explicitly notified\nsemantically to be prepared for API/ABI breaking.",
    "buggy_file": {
      "buggy_filename": "src/formatter/string.cpp",
      "buggy_code": "#include \"blackhole/formatter/string.hpp\"\n\n#include <array>\n\n#include <boost/variant/apply_visitor.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/variant/variant.hpp>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/extensions/format.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n#include \"blackhole/record.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n#include \"blackhole/detail/formatter/string/parser.hpp\"\n#include \"blackhole/detail/formatter/string/token.hpp\"\n#include \"blackhole/detail/procname.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\n\nnamespace string = blackhole::detail::formatter::string;\nnamespace ph = string::ph;\n\nusing string::id;\nusing string::hex;\nusing string::num;\nusing string::name;\nusing string::user;\nusing string::required;\nusing string::optional;\n\nusing string::literal_t;\n\nnamespace {\n\ntypedef fmt::StringRef string_ref;\n\n}  // namespace\n\nclass token_t {\n    string::token_t inner;\n\npublic:\n    token_t(string::token_t inner) :\n        inner(std::move(inner))\n    {}\n\n    auto operator*() const noexcept -> const string::token_t& {\n        return inner;\n    }\n};\n\nnamespace {\n\nclass transform_visitor_t : public boost::static_visitor<string::token_t> {\n    const options_t& options;\n\npublic:\n    transform_visitor_t(const options_t& options) :\n        options(options)\n    {}\n\n    auto operator()(const ph::generic<required>& token) const -> string::token_t {\n        const auto it = options.find(token.name);\n\n        if (it != options.end()) {\n            const auto option = boost::get<option::optional_t>(it->second);\n\n            return ph::generic<optional>(token, option.prefix, option.suffix);\n        }\n\n        return token;\n    }\n\n    auto operator()(const ph::leftover_t& token) const -> string::token_t {\n        const auto it = options.find(token.name);\n\n        if (it != options.end()) {\n            const auto option = boost::get<option::leftover_t>(it->second);\n\n            return ph::leftover_t(token.name, option.unique, option.prefix, option.suffix,\n                option.pattern, option.separator);\n        }\n\n        return token;\n    }\n\n    template<typename T>\n    auto operator()(const T& token) const -> string::token_t {\n        return token;\n    }\n};\n\nstruct spec;\nstruct unspec;\n\ntemplate<typename Spec>\nclass view_visitor;\n\ntemplate<>\nclass view_visitor<spec> : public boost::static_visitor<> {\n    writer_t& writer;\n    const std::string& spec;\n\npublic:\n    view_visitor(writer_t& writer, const std::string& spec) noexcept :\n        writer(writer),\n        spec(spec)\n    {}\n\n    auto operator()(std::nullptr_t) const -> void {\n        writer.write(spec, \"none\");\n    }\n\n    template<typename T>\n    auto operator()(T value) const -> void {\n        writer.write(spec, value);\n    }\n\n    auto operator()(const string_view& value) const -> void {\n        writer.write(spec, value.data());\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) const -> void {\n        value(writer);\n    }\n};\n\ntemplate<>\nclass view_visitor<unspec> : public boost::static_visitor<> {\n    writer_t& writer;\n\npublic:\n    view_visitor(writer_t& writer) noexcept :\n        writer(writer)\n    {}\n\n    auto operator()(std::nullptr_t) const -> void {\n        writer.inner << \"none\";\n    }\n\n    template<typename T>\n    auto operator()(T value) const -> void {\n        writer.inner << value;\n    }\n\n    auto operator()(const string_view& value) const -> void {\n        writer.inner << string_ref(value.data(), value.size());\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) const -> void {\n        value(writer);\n    }\n};\n\nclass visitor_t : public boost::static_visitor<> {\n    writer_t& writer;\n    const record_t& record;\n    const severity_map& sevmap;\n\npublic:\n    visitor_t(writer_t& writer, const record_t& record, const severity_map& sevmap) noexcept :\n        writer(writer),\n        record(record),\n        sevmap(sevmap)\n    {}\n\n    auto operator()(const literal_t& token) const -> void {\n        writer.inner << token.value;\n    }\n\n    auto operator()(const ph::message_t& token) const -> void {\n        const auto& value = record.formatted();\n        writer.write(token.spec, string_ref(value.data(), value.size()));\n    }\n\n    auto operator()(const ph::process<id>& token) const -> void {\n        writer.write(token.spec, record.pid());\n    }\n\n    auto operator()(const ph::process<name>& token) const -> void {\n        writer.write(token.spec, detail::procname().data());\n    }\n\n    auto operator()(const ph::thread<id>& token) const -> void {\n        throw std::runtime_error(\"{thread:d} placeholder is not implemented yet\");\n    }\n\n    auto operator()(const ph::thread<hex>& token) const -> void {\n#ifdef __linux__\n        writer.write(token.spec, record.tid());\n#elif __APPLE__\n        writer.write(token.spec, reinterpret_cast<unsigned long>(record.tid()));\n#endif\n    }\n\n    auto operator()(const ph::thread<name>& token) const -> void {\n        std::array<char, 16> buffer;\n        const auto rc = ::pthread_getname_np(record.tid(), buffer.data(), buffer.size());\n\n        if (rc == 0) {\n            writer.write(token.spec, buffer.data());\n        } else {\n            writer.write(token.spec, \"<unnamed>\");\n        }\n    }\n\n    auto operator()(const ph::severity<num>& token) const -> void {\n        writer.write(token.spec, record.severity());\n    }\n\n    auto operator()(const ph::severity<user>& token) const -> void {\n        sevmap(record.severity(), token.spec, writer);\n    }\n\n    auto operator()(const ph::timestamp<num>& token) const -> void {\n        const auto timestamp = record.timestamp();\n        const auto usec = std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(timestamp.time_since_epoch()).count();\n\n        writer.write(token.spec, usec);\n    }\n\n    auto operator()(const ph::timestamp<user>& token) const -> void {\n        const auto timestamp = record.timestamp();\n        const auto time = record_t::clock_type::to_time_t(timestamp);\n        const auto usec = std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(timestamp.time_since_epoch()).count() % 1000000;\n\n        std::tm tm;\n        ::gmtime_r(&time, &tm);\n\n        fmt::MemoryWriter buffer;\n        token.generator(buffer, tm, static_cast<std::uint64_t>(usec));\n        writer.write(token.spec, string_ref(buffer.data(), buffer.size()));\n    }\n\n    auto operator()(const ph::generic<required>& token) const -> void {\n        if (auto value = find(token.name)) {\n            return boost::apply_visitor(view_visitor<spec>(writer, token.spec), value->inner().value);\n        }\n\n        throw std::logic_error(\"required attribute '\" + token.name + \"' not found\");\n    }\n\n    auto operator()(const ph::generic<optional>& token) const -> void {\n        if (auto value = find(token.name)) {\n            writer.write(token.prefix);\n            boost::apply_visitor(view_visitor<spec>(writer, token.spec), value->inner().value);\n            writer.write(token.suffix);\n        }\n    }\n\n    auto operator()(const ph::leftover_t& token) const -> void {\n        bool first = true;\n        writer_t kv;\n        const view_visitor<unspec> visitor(kv);\n\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                if (first) {\n                    first = false;\n                    writer.inner << token.prefix;\n                } else {\n                    writer.inner << token.separator;\n                }\n\n                // TODO: To correctly implement kv patterns we need a visitor with parameters. Or\n                // attribute (pair) type, instead of that `std::pair`.\n                kv.inner << string_ref(attribute.first.data(), attribute.first.size()) << \": \";\n                boost::apply_visitor(visitor, attribute.second.inner().value);\n\n                const auto view = kv.result();\n                writer.inner << string_ref(view.data(), view.size());\n\n                kv.inner.clear();\n            }\n        }\n\n        if (!first) {\n            writer.inner << token.suffix;\n        }\n    }\n\nprivate:\n    auto find(const std::string& name) const -> boost::optional<attribute::view_t> {\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                if (attribute.first == name) {\n                    return attribute.second;\n                }\n            }\n        }\n\n        return boost::none;\n    }\n};\n\nstatic auto tokenize(const std::string& pattern, const options_t& options) -> std::vector<token_t> {\n    std::vector<token_t> tokens;\n\n    for (const auto& reserved : {\"process\", \"thread\", \"message\", \"severity\", \"timestamp\"}) {\n        if (options.count(reserved) != 0) {\n            throw std::logic_error(\"placeholder '\" + std::string(reserved) +\n                \"' is reserved and can not be configured\");\n        }\n    }\n\n    string::parser_t parser(pattern);\n    while (auto token = parser.next()) {\n        tokens.emplace_back(boost::apply_visitor(transform_visitor_t(options), token.get()));\n    }\n\n    return tokens;\n}\n\n}  // namespace\n\nstring_t::string_t(std::string pattern, const options_t& options) :\n    pattern(std::move(pattern)),\n    sevmap([](int severity, const std::string& spec, writer_t& writer) {\n        writer.write(spec, severity);\n    }),\n    tokens(tokenize(this->pattern, options))\n{}\n\nstring_t::string_t(std::string pattern, severity_map sevmap, const options_t& options) :\n    pattern(std::move(pattern)),\n    sevmap(std::move(sevmap)),\n    tokens(tokenize(this->pattern, options))\n{}\n\nstring_t::string_t(string_t&& other) = default;\n\nstring_t::~string_t() {}\n\nauto\nstring_t::format(const record_t& record, writer_t& writer) -> void {\n    const visitor_t visitor(writer, record, sevmap);\n\n    for (const auto& token : tokens) {\n        boost::apply_visitor(visitor, *token);\n    }\n}\n\n}  // namespace formatter\n\nauto\nfactory<formatter::string_t>::type() -> const char* {\n    return \"string\";\n}\n\nauto\nfactory<formatter::string_t>::from(const config::node_t& config) -> formatter::string_t {\n    auto pattern = config[\"pattern\"].to_string().get();\n\n    if (auto mapping = config[\"sevmap\"]) {\n        std::vector<std::string> sevmap;\n        mapping.each([&](const config::node_t& config) {\n            sevmap.emplace_back(config.to_string());\n        });\n\n        auto fn = [=](std::size_t severity, const std::string& spec, writer_t& writer) {\n            if (severity < sevmap.size()) {\n                writer.write(spec, sevmap[severity]);\n            } else {\n                writer.write(spec, severity);\n            }\n        };\n\n        return formatter::string_t(std::move(pattern), std::move(fn));\n    }\n\n    return formatter::string_t(std::move(pattern));\n}\n\n}  // namespace v1\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "include/blackhole/formatter/string.hpp",
        "code": "#pragma once\n\n#include <functional>\n#include <memory>\n#include <string>\n\n#include \"blackhole/formatter.hpp\"\n#include \"blackhole/severity.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nclass record_t;\nclass writer_t;\n\ntemplate<typename>\nstruct factory;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\n\n/// Severity mapping function.\n///\n/// Default value just writes an integer representation.\n///\n/// \\param severity an integer representation of current log severity.\n/// \\param spec the format specification as it was provided with the initial pattern.\n/// \\param writer result writer.\ntypedef std::function<void(int severity, const std::string& spec, writer_t& writer)> severity_map;\n\n/// The string formatter is responsible for effective converting the given record to a string using\n/// precompiled pattern and options.\n///\n/// This formatter allows to specify the pattern using python-like syntax with braces and attribute\n/// names.\n///\n/// For example, the given pattern `{severity:d}, [{timestamp}]: {message}` would result in\n/// something like this: `1, [2015-11-18 15:50:12.630953]: HTTP1.1 - 200 OK`.\n///\n/// Let's explain what's going on when a log record passed such pattern.\n///\n/// There are three named arguments or attributes: severity, timestamp and message. The severity\n/// is represented as signed integer, because of `:d` format specifier. Other tho arguments haven't\n/// such specifiers, so they are represented using default types for each attribute. In our case\n/// the timestamp and message attributes are formatted as strings.\n///\n/// Considering message argument almost everything is clear, but for timestamp there are internal\n/// magic comes. There is default `%Y-%m-%d %H:%M:%S.%f` pattern for timestamp attributes which\n/// reuses `strftime` standard placeholders with an extension of microseconds - `%f`. It means\n/// that the given timestamp is formatted with 4-digit decimal year, 1-12 decimal month and so on.\n///\n/// See \\ref http://en.cppreference.com/w/cpp/chrono/c/strftime for more details.\n///\n/// The formatter uses python-like syntax with all its features, like aligning, floating point\n/// precision etc.\n///\n/// For example the `{re:+.3f}; {im:+.6f}` pattern is valid and results in `+3.140; -3.140000`\n/// message with `re: 3.14` and `im: -3.14` attributes provided.\n///\n/// For more information see \\ref http://cppformat.github.io/latest/syntax.html resource.\n///\n/// With a few predefined exceptions the formatter supports all userspace attributes. The exceptions\n/// are: message, severity, timestamp, process and thread. For these attributes there are special\n/// rules and it's impossible to override then even with the same name attribute.\n///\n/// For message attribute there are no special rules. It's still allowed to extend the specification\n/// using fill, align and other specifiers.\n///\n/// With timestamp attribute there is an extension of either explicitly providing formatting pattern\n/// or forcing the attibute to be printed as an integer.\n/// In the first case for example the pattern may be declared as `{timestamp:{%Y}s}` which results\n/// in only year formattinh using YYYY style.\n/// In the second case one can force the timestamp to be printed as microseconds passed since epoch.\n///\n/// Severity attribute can be formatted either as an integer or using the provided callback with the\n/// following signature: `auto(int, writer_t&) -> void` where the first argument means an actual\n/// severity level, the second one - streamed writer.\n///\n/// Process attribute can be represented as either an PID or process name using `:d` and `:s` types\n/// respectively: `{process:s}` and `{process:d}`.\n///\n/// At last the thread attribute can be formatted as either thread id in platform-independent hex\n/// representation by default or explicitly with `:x` type, thread id in platform-dependent way\n/// using `:d` type or as a thread name if specified, nil otherwise.\n///\n/// The formatter will throw an exception if an attribute name specified in pattern won't be found\n/// in the log record. Of course Blackhole catches this, but it results in dropping the entire\n/// message.\n/// To avoid this the formatter supports optional generic attributes, which can be specified using\n/// the `optional_t` option with an optional prefix and suffix literals printed if an attribute\n/// exists.\n/// For example an `{id}` pattern with the `[` prefix and `]` suffix options results in empty\n/// message if there is no `source` attribute in the record, `[42]` otherwise (where id = 42).\n///\n/// Blackhole also supports the leftover placeholder starting with `...` and meaning to print all\n/// userspace attributes in a reverse order they were provided.\n///\n/// # Performance\n///\n/// Internally the given pattern is compiled into the list of tokens during construction time. All\n/// further operations are performed using that list to achieve maximum performance.\n///\n/// All visited tokens are written directly into the given writer instance with an internal small\n/// stack-allocated buffer, growing using the heap on overflow.\nclass string_t : public formatter_t {\n    class inner_t;\n    std::unique_ptr<inner_t, auto(*)(inner_t*) -> void> inner;\n\npublic:\n    explicit string_t(const std::string& pattern);\n    string_t(const std::string& pattern, severity_map sevmap);\n\n    /// Configuration.\n\n    auto optional(const std::string& name, std::string prefix, std::string suffix) -> void;\n    auto leftover(const std::string& name, std::string prefix, std::string suffix,\n        std::string pattern, std::string separator, bool unique) -> void;\n\n    /// Formatting.\n\n    auto format(const record_t& record, writer_t& writer) -> void;\n};\n\n}  // namespace formatter\n\ntemplate<>\nstruct factory<formatter::string_t> {\n    static auto type() -> const char*;\n    static auto from(const config::node_t& config) -> formatter::string_t;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/attribute.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n#include <type_traits>\n\n#include <boost/mpl/contains.hpp>\n#include <boost/mpl/vector.hpp>\n\n#include \"blackhole/cpp17/string_view.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\n/// Trait that describes how to format user defined types provided as attributes.\ntemplate<typename T>\nstruct display_traits;\n\n/// Represents a trait for mapping an owned types to their associated lightweight view types.\n///\n/// By default all types are transparently mapped to itself, but Blackhole provides some\n/// specializations.\n///\n/// \\warning it is undefined behavior to add specializations for this trait.\ntemplate<typename T>\nstruct view_of {\n    typedef T type;\n};\n\n/// Forward.\nclass writer_t;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nclass value_t;\nclass view_t;\n\n/// Represents an attribute value holder.\n///\n/// Attribute value is an algebraic data type that can be initialized with one of the following\n/// predefined primitive types:\n///     - none marker;\n///     - boolean type (true or false);\n///     - signed integer types up to 64-bit size;\n///     - unsigned integer types up to 64-bit size;\n///     - floating point type;\n///     - owned string type;\n///     - and a function type, which can fill the specified writer with the value lazily.\n///\n/// The underlying value can be obtained through `blackhole::attribute::get` function with providing\n/// the desired result type. For example:\n///     blackhole::attribute::value_t value(42);\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(42 == actual);\n///\n/// As an alternative a visitor pattern is provided for enabling underlying value visitation. To\n/// enable this feature, implement the `value_t::visitor_t` interface and provide an instance of\n/// this implementation to the `apply` method.\nclass value_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef std::string    string_type;\n    typedef std::function<auto(writer_t& writer) -> void> function_type;\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<sizeof(function_type) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value containing tagged nullptr value.\n    value_t();\n\n    value_t(std::nullptr_t);\n\n    /// Constructs a value initialized with the given boolean value.\n    value_t(bool value);\n\n    /// Constructs a value initialized with the given signed integer.\n    value_t(char value);\n    value_t(short value);\n    value_t(int value);\n    value_t(long value);\n    value_t(long long value);\n\n    /// Constructs a value initialized with the given unsigned integer.\n    value_t(unsigned char value);\n    value_t(unsigned short value);\n    value_t(unsigned int value);\n    value_t(unsigned long value);\n    value_t(unsigned long long value);\n\n    value_t(double value);\n\n    /// Constructs a value from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    value_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    value_t(std::string value);\n\n    ~value_t();\n\n    value_t(const value_t& other);\n    value_t(value_t&& other);\n\n    auto operator=(const value_t& other) -> value_t&;\n    auto operator=(value_t&& other) -> value_t&;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n};\n\n/// Represents an attribute value holder view, containing only lightweight views of the actual\n/// values.\n///\n/// If an owned value is small enough to keep its copy - this class does it, otherwise keeping only\n/// view proxy values. For example for `std::string` values there is a lightweight mapping that\n/// holds only two members: a pointer to constant char and a size.\n///\n/// The underlying value can also be obtained through `blackhole::attribute::get` function with\n/// providing the desired result type. For example:\n///     blackhole::attribute::view_t value(\"le vinegret\");\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(\"le vinegret\" == actual);\n///\nclass view_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef string_view    string_type;\n\n    struct function_type {\n        const void* value;\n        std::reference_wrapper<auto(const void* value, writer_t& writer) -> void> fn;\n\n        auto operator()(writer_t& wr) const -> void {\n            fn(value, wr);\n        }\n\n        auto operator==(const function_type& other) const noexcept -> bool {\n            return value == other.value && fn.get() == other.fn.get();\n        }\n    };\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<2 * sizeof(void*) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value view containing tagged nullptr value.\n    view_t();\n\n    view_t(std::nullptr_t);\n\n    /// Constructs a value view initialized with the given boolean value.\n    view_t(bool value);\n\n    /// Constructs a value view initialized with the given signed integer.\n    view_t(char value);\n    view_t(short value);\n    view_t(int value);\n    view_t(long value);\n    view_t(long long value);\n\n    /// Constructs a value view initialized with the given unsigned integer.\n    view_t(unsigned char value);\n    view_t(unsigned short value);\n    view_t(unsigned int value);\n    view_t(unsigned long value);\n    view_t(unsigned long long value);\n\n    /// Constructs a value view from the given floating point value.\n    view_t(float value);\n    view_t(double value);\n\n    /// Constructs a value view from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    view_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    /// Constructs a value view from the given string view.\n    view_t(const string_type& value);\n\n    /// Constructs a value view from the given string.\n    view_t(const std::string& value);\n\n    /// Constructs a value view from the given owned attribute value.\n    view_t(const value_t& value);\n\n    /// Constructs a value view from a custom type that implements `display_traits` trait.\n    ///\n    /// \\sa display_traits for more information.\n    template<typename T>\n    view_t(const T& value, decltype(&display_traits<T>::apply)* = nullptr) {\n        construct(function_type{static_cast<const void*>(&value), std::ref(display<T>)});\n    }\n\n    view_t(const view_t& other) = default;\n    view_t(view_t&& other) = default;\n\n    ~view_t() = default;\n\n    auto operator=(const view_t& other) -> view_t& = default;\n    auto operator=(view_t&& other) -> view_t& = default;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    auto operator==(const view_t& other) const -> bool;\n    auto operator!=(const view_t& other) const -> bool;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n\n    template<typename T>\n    static auto display(const void* value, writer_t& wr) -> void {\n        display_traits<T>::apply(*static_cast<const T*>(value), wr);\n    }\n};\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const value_t& value) ->\n    typename std::enable_if<boost::mpl::contains<value_t::types, T>::value, const T&>::type;\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value view.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const view_t& value) ->\n    typename std::enable_if<boost::mpl::contains<view_t::types, T>::value, const T&>::type;\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/node.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\ntemplate<typename T>\nclass option;\n\n/// Represents the configuration tree node.\n///\n/// Blackhole operates with instances of this class while configuring the logging system from some\n/// generic source, from file for example. It assumes that the whole configuration can be described\n/// using tree data structure, like JSON, XML or YAML.\n/// To be able to initialize from your own data format you must create subclass and implement its\n/// converting methods as like as tree traversing using subscription operators.\nclass node_t {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\npublic:\n    virtual ~node_t() = 0;\n\n    /// Tries to convert the underlying object to bool.\n    virtual auto to_bool() const -> bool = 0;\n\n    /// Tries to convert the underlying object to signed integer.\n    virtual auto to_sint64() const -> std::int64_t = 0;\n\n    /// Tries to convert the underlying object to unsigned integer.\n    virtual auto to_uint64() const -> std::uint64_t = 0;\n\n    /// Tries to convert the underlying object to double.\n    virtual auto to_double() const -> double = 0;\n\n    /// Tries to convert the underlying object to string.\n    virtual auto to_string() const -> std::string = 0;\n\n    /// Assuming that the underlying object is an array, performs inner iteration over it by\n    /// applying the given function to each element.\n    ///\n    /// Should do nothing either if there is no underlying array or it is empty.\n    virtual auto each(const each_function& fn) -> void = 0;\n\n    /// Assuming that the underlying object is a map, performs inner iteration over it by applying\n    /// the given function to each key-value element.\n    ///\n    /// Should do nothing either if there is no underlying map or it is empty.\n    virtual auto each_map(const member_function& fn) -> void = 0;\n\n    /// Assuming that the underlying object is an array performs index operation returning the\n    /// option object with some node at the given index on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::size_t& idx) const -> option<node_t> = 0;\n\n    /// Assuming that the underlying object is a map performs tree traversing operation returning\n    /// option object with some node at the given key on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::string& key) const -> option<node_t> = 0;\n};\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/option.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include <boost/optional/optional_fwd.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\ntemplate<typename T>\nclass option;\n\ntemplate<>\nclass option<node_t> {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\nprivate:\n    std::unique_ptr<node_t> node;\n\npublic:\n    /// Constructs an option object that will contan nothing.\n    option() noexcept;\n\n    /// Constructs an option object that will contain the specified configuration node.\n    explicit option(std::unique_ptr<node_t> node) noexcept;\n\n    explicit operator bool() const noexcept;\n\n    /// Unwraps an option, yielding the content of an underlying config node object.\n    auto unwrap() const -> boost::optional<const node_t&>;\n\n    auto to_bool() const -> boost::optional<bool>;\n    auto to_sint64() const -> boost::optional<std::int64_t>;\n    auto to_uint64() const -> boost::optional<std::uint64_t>;\n    auto to_double() const -> boost::optional<double>;\n    auto to_string() const -> boost::optional<std::string>;\n\n    auto each(const each_function& fn) -> void;\n    auto each_map(const member_function& fn) -> void;\n\n    auto operator[](const std::size_t& idx) const -> option<node_t>;\n    auto operator[](const std::string& key) const -> option<node_t>;\n\nprivate:\n    template<typename F>\n    auto to(F&& fn) const -> decltype(fn());\n};\n\n/// Constructs an option of the specified configuration node type using given arguments.\ntemplate<typename T, typename... Args>\nauto make_option(Args&&... args) -> option<node_t> {\n    return option<node_t>(std::unique_ptr<T>(new T(std::forward<Args>(args)...)));\n}\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/extensions/format.hpp",
        "code": "/*\n Formatting library for C++\n\n Copyright (c) 2012 - 2015, Victor Zverovich\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FMT_FORMAT_H_\n#define FMT_FORMAT_H_\n\n#include <stdint.h>\n\n#include <cassert>\n#include <cmath>\n#include <cstddef>  // for std::ptrdiff_t\n#include <cstdio>\n#include <algorithm>\n#include <limits>\n#include <stdexcept>\n#include <string>\n#include <map>\n\n#ifndef FMT_USE_IOSTREAMS\n# define FMT_USE_IOSTREAMS 1\n#endif\n\n#if FMT_USE_IOSTREAMS\n# include <sstream>\n#endif\n\n#ifdef _SECURE_SCL\n# define FMT_SECURE_SCL _SECURE_SCL\n#else\n# define FMT_SECURE_SCL 0\n#endif\n\n#if FMT_SECURE_SCL\n# include <iterator>\n#endif\n\n#ifdef _MSC_VER\n# include <intrin.h>  // _BitScanReverse, _BitScanReverse64\n\nnamespace fmt {\nnamespace internal {\n# pragma intrinsic(_BitScanReverse)\ninline uint32_t clz(uint32_t x) {\n  unsigned long r = 0;\n  _BitScanReverse(&r, x);\n  return 31 - r;\n}\n# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)\n\n# ifdef _WIN64\n#  pragma intrinsic(_BitScanReverse64)\n# endif\n\ninline uint32_t clzll(uint64_t x) {\n  unsigned long r = 0;\n# ifdef _WIN64\n  _BitScanReverse64(&r, x);\n# else\n  // Scan the high 32 bits.\n  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))\n    return 63 - (r + 32);\n\n  // Scan the low 32 bits.\n  _BitScanReverse(&r, static_cast<uint32_t>(x));\n# endif\n  return 63 - r;\n}\n# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)\n}\n}\n#endif\n\n#ifdef __GNUC__\n# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)\n# define FMT_GCC_EXTENSION __extension__\n# if FMT_GCC_VERSION >= 406\n#  pragma GCC diagnostic push\n// Disable the warning about \"long long\" which is sometimes reported even\n// when using __extension__.\n#  pragma GCC diagnostic ignored \"-Wlong-long\"\n// Disable the warning about declaration shadowing because it affects too\n// many valid cases.\n#  pragma GCC diagnostic ignored \"-Wshadow\"\n# endif\n# if __cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__\n#  define FMT_HAS_GXX_CXX11 1\n# endif\n#else\n# define FMT_GCC_EXTENSION\n#endif\n\n#ifdef __clang__\n# pragma clang diagnostic push\n# pragma clang diagnostic ignored \"-Wdocumentation\"\n# pragma clang diagnostic ignored \"-Wdocumentation-unknown-command\"\n# pragma clang diagnostic ignored \"-Wswitch-enum\"\n# pragma clang diagnostic ignored \"-Wsign-conversion\"\n# pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n# pragma clang diagnostic ignored \"-Wmissing-noreturn\"\n# pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\n# pragma clang diagnostic ignored \"-Wunused-member-function\"\n#endif\n\n#ifdef __GNUC_LIBSTD__\n# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)\n#endif\n\n#ifdef __has_feature\n# define FMT_HAS_FEATURE(x) __has_feature(x)\n#else\n# define FMT_HAS_FEATURE(x) 0\n#endif\n\n#ifdef __has_builtin\n# define FMT_HAS_BUILTIN(x) __has_builtin(x)\n#else\n# define FMT_HAS_BUILTIN(x) 0\n#endif\n\n#ifdef __has_cpp_attribute\n# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n#else\n# define FMT_HAS_CPP_ATTRIBUTE(x) 0\n#endif\n\n#ifndef FMT_USE_VARIADIC_TEMPLATES\n// Variadic templates are available in GCC since version 4.4\n// (http://gcc.gnu.org/projects/cxx0x.html) and in Visual C++\n// since version 2013.\n# define FMT_USE_VARIADIC_TEMPLATES \\\n   (FMT_HAS_FEATURE(cxx_variadic_templates) || \\\n       (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1800)\n#endif\n\n#ifndef FMT_USE_RVALUE_REFERENCES\n// Don't use rvalue references when compiling with clang and an old libstdc++\n// as the latter doesn't provide std::move.\n# if defined(FMT_GNUC_LIBSTD_VERSION) && FMT_GNUC_LIBSTD_VERSION <= 402\n#  define FMT_USE_RVALUE_REFERENCES 0\n# else\n#  define FMT_USE_RVALUE_REFERENCES \\\n    (FMT_HAS_FEATURE(cxx_rvalue_references) || \\\n        (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1600)\n# endif\n#endif\n\n#if FMT_USE_RVALUE_REFERENCES\n# include <utility>  // for std::move\n#endif\n\n// Define FMT_USE_NOEXCEPT to make C++ Format use noexcept (C++11 feature).\n#ifndef FMT_USE_NOEXCEPT\n# define FMT_USE_NOEXCEPT 0\n#endif\n\n#ifndef FMT_NOEXCEPT\n# if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \\\n   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n   _MSC_VER >= 1900\n#  define FMT_NOEXCEPT noexcept\n# else\n#  define FMT_NOEXCEPT throw()\n# endif\n#endif\n\n// A macro to disallow the copy constructor and operator= functions\n// This should be used in the private: declarations for a class\n#ifndef FMT_USE_DELETED_FUNCTIONS\n# define FMT_USE_DELETED_FUNCTIONS 0\n#endif\n\n#if FMT_USE_DELETED_FUNCTIONS || FMT_HAS_FEATURE(cxx_deleted_functions) || \\\n  (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1800\n# define FMT_DELETED_OR_UNDEFINED  = delete\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&) = delete; \\\n    TypeName& operator=(const TypeName&) = delete\n#else\n# define FMT_DELETED_OR_UNDEFINED\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&); \\\n    TypeName& operator=(const TypeName&)\n#endif\n\n#ifndef FMT_USE_USER_DEFINED_LITERALS\n// All compilers which support UDLs also support variadic templates. This\n// makes the fmt::literals implementation easier. However, an explicit check\n// for variadic templates is added here just in case.\n# define FMT_USE_USER_DEFINED_LITERALS \\\n   FMT_USE_VARIADIC_TEMPLATES && \\\n   (FMT_HAS_FEATURE(cxx_user_literals) || \\\n       (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1900)\n#endif\n\n#ifndef FMT_ASSERT\n# define FMT_ASSERT(condition, message) assert((condition) && message)\n#endif\n\n/// Blackhole section {\n\nnamespace blackhole {\n\n/// } Blackhole section\n\nnamespace fmt {\n\n// Fix the warning about long long on older versions of GCC\n// that don't support the diagnostic pragma.\nFMT_GCC_EXTENSION typedef long long LongLong;\nFMT_GCC_EXTENSION typedef unsigned long long ULongLong;\n\n#if FMT_USE_RVALUE_REFERENCES\nusing std::move;\n#endif\n\ntemplate <typename Char>\nclass BasicWriter;\n\ntypedef BasicWriter<char> Writer;\ntypedef BasicWriter<wchar_t> WWriter;\n\ntemplate <typename Char>\nclass BasicFormatter;\n\ntemplate <typename Char, typename T>\nvoid format(BasicFormatter<Char> &f, const Char *&format_str, const T &value);\n\n/**\n  \\rst\n  A string reference. It can be constructed from a C string or ``std::string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +------------+-------------------------+\n  | Type       | Definition              |\n  +============+=========================+\n  | StringRef  | BasicStringRef<char>    |\n  +------------+-------------------------+\n  | WStringRef | BasicStringRef<wchar_t> |\n  +------------+-------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(StringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicStringRef {\n private:\n  const Char *data_;\n  std::size_t size_;\n\n public:\n  /** Constructs a string reference object from a C string and a size. */\n  BasicStringRef(const Char *s, std::size_t size) : data_(s), size_(size) {}\n\n  /**\n    \\rst\n    Constructs a string reference object from a C string computing\n    the size with ``std::char_traits<Char>::length``.\n    \\endrst\n   */\n  BasicStringRef(const Char *s)\n    : data_(s), size_(std::char_traits<Char>::length(s)) {}\n\n  /**\n    \\rst\n    Constructs a string reference from an ``std::string`` object.\n    \\endrst\n   */\n  BasicStringRef(const std::basic_string<Char> &s)\n  : data_(s.c_str()), size_(s.size()) {}\n\n  /**\n    \\rst\n    Converts a string reference to an ``std::string`` object.\n    \\endrst\n   */\n  std::basic_string<Char> to_string() const {\n    return std::basic_string<Char>(data_, size_);\n  }\n\n  /** Returns the pointer to a C string. */\n  const Char *data() const { return data_; }\n\n  /** Returns the string size. */\n  std::size_t size() const { return size_; }\n\n  // Lexicographically compare this string reference to other.\n  int compare(BasicStringRef other) const {\n    std::size_t size = std::min(size_, other.size_);\n    int result = std::char_traits<Char>::compare(data_, other.data_, size);\n    if (result == 0)\n      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);\n    return result;\n  }\n\n  friend bool operator==(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) == 0;\n  }\n  friend bool operator!=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) != 0;\n  }\n  friend bool operator<(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) < 0;\n  }\n  friend bool operator<=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) <= 0;\n  }\n  friend bool operator>(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) > 0;\n  }\n  friend bool operator>=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) >= 0;\n  }\n};\n\ntypedef BasicStringRef<char> StringRef;\ntypedef BasicStringRef<wchar_t> WStringRef;\n\n/**\n  \\rst\n  A reference to a null terminated string. It can be constructed from a C\n  string or ``std::string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +-------------+--------------------------+\n  | Type        | Definition               |\n  +=============+==========================+\n  | CStringRef  | BasicCStringRef<char>    |\n  +-------------+--------------------------+\n  | WCStringRef | BasicCStringRef<wchar_t> |\n  +-------------+--------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(CStringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicCStringRef {\n private:\n  const Char *data_;\n\n public:\n  /** Constructs a string reference object from a C string. */\n  BasicCStringRef(const Char *s) : data_(s) {}\n\n  /**\n    \\rst\n    Constructs a string reference from an ``std::string`` object.\n    \\endrst\n   */\n  BasicCStringRef(const std::basic_string<Char> &s) : data_(s.c_str()) {}\n\n  /** Returns the pointer to a C string. */\n  const Char *c_str() const { return data_; }\n};\n\ntypedef BasicCStringRef<char> CStringRef;\ntypedef BasicCStringRef<wchar_t> WCStringRef;\n\n/**\n  A formatting error such as invalid format string.\n*/\nclass FormatError : public std::runtime_error {\n public:\n  explicit FormatError(CStringRef message)\n  : std::runtime_error(message.c_str()) {}\n};\n\nnamespace internal {\n// The number of characters to store in the MemoryBuffer object itself\n// to avoid dynamic memory allocation.\nenum { INLINE_BUFFER_SIZE = 500 };\n\n#if FMT_SECURE_SCL\n// Use checked iterator to avoid warnings on MSVC.\ntemplate <typename T>\ninline stdext::checked_array_iterator<T*> make_ptr(T *ptr, std::size_t size) {\n  return stdext::checked_array_iterator<T*>(ptr, size);\n}\n#else\ntemplate <typename T>\ninline T *make_ptr(T *ptr, std::size_t) { return ptr; }\n#endif\n}  // namespace internal\n\n/**\n  \\rst\n  A buffer supporting a subset of ``std::vector``'s operations.\n  \\endrst\n */\ntemplate <typename T>\nclass Buffer {\n private:\n  FMT_DISALLOW_COPY_AND_ASSIGN(Buffer);\n\n protected:\n  T *ptr_;\n  std::size_t size_;\n  std::size_t capacity_;\n\n  Buffer(T *ptr = 0, std::size_t capacity = 0)\n    : ptr_(ptr), size_(0), capacity_(capacity) {}\n\n  /**\n    \\rst\n    Increases the buffer capacity to hold at least *size* elements updating\n    ``ptr_`` and ``capacity_``.\n    \\endrst\n   */\n  virtual void grow(std::size_t size) = 0;\n\n public:\n  virtual ~Buffer() {}\n\n  /** Returns the size of this buffer. */\n  std::size_t size() const { return size_; }\n\n  /** Returns the capacity of this buffer. */\n  std::size_t capacity() const { return capacity_; }\n\n  /**\n    Resizes the buffer. If T is a POD type new elements may not be initialized.\n   */\n  void resize(std::size_t new_size) {\n    if (new_size > capacity_)\n      grow(new_size);\n    size_ = new_size;\n  }\n\n  /**\n    \\rst\n    Reserves space to store at least *capacity* elements.\n    \\endrst\n   */\n  void reserve(std::size_t capacity) {\n    if (capacity > capacity_)\n      grow(capacity);\n  }\n\n  void clear() FMT_NOEXCEPT { size_ = 0; }\n\n  void push_back(const T &value) {\n    if (size_ == capacity_)\n      grow(size_ + 1);\n    ptr_[size_++] = value;\n  }\n\n  /** Appends data to the end of the buffer. */\n  template <typename U>\n  void append(const U *begin, const U *end);\n\n  T &operator[](std::size_t index) { return ptr_[index]; }\n  const T &operator[](std::size_t index) const { return ptr_[index]; }\n};\n\ntemplate <typename T>\ntemplate <typename U>\nvoid Buffer<T>::append(const U *begin, const U *end) {\n  std::ptrdiff_t num_elements = end - begin;\n  if (size_ + num_elements > capacity_)\n    grow(size_ + num_elements);\n  std::copy(begin, end, internal::make_ptr(ptr_, capacity_) + size_);\n  size_ += num_elements;\n}\n\nnamespace internal {\n\n// A memory buffer for POD types with the first SIZE elements stored in\n// the object itself.\ntemplate <typename T, std::size_t SIZE, typename Allocator = std::allocator<T> >\nclass MemoryBuffer : private Allocator, public Buffer<T> {\n private:\n  T data_[SIZE];\n\n  // Deallocate memory allocated by the buffer.\n  void deallocate() {\n    if (this->ptr_ != data_) Allocator::deallocate(this->ptr_, this->capacity_);\n  }\n\n protected:\n  void grow(std::size_t size);\n\n public:\n  explicit MemoryBuffer(const Allocator &alloc = Allocator())\n      : Allocator(alloc), Buffer<T>(data_, SIZE) {}\n  ~MemoryBuffer() { deallocate(); }\n\n#if FMT_USE_RVALUE_REFERENCES\n private:\n  // Move data from other to this buffer.\n  void move(MemoryBuffer &other) {\n    Allocator &this_alloc = *this, &other_alloc = other;\n    this_alloc = std::move(other_alloc);\n    this->size_ = other.size_;\n    this->capacity_ = other.capacity_;\n    if (other.ptr_ == other.data_) {\n      this->ptr_ = data_;\n      std::copy(other.data_,\n                other.data_ + this->size_, make_ptr(data_, this->capacity_));\n    } else {\n      this->ptr_ = other.ptr_;\n      // Set pointer to the inline array so that delete is not called\n      // when deallocating.\n      other.ptr_ = other.data_;\n    }\n  }\n\n public:\n  MemoryBuffer(MemoryBuffer &&other) {\n    move(other);\n  }\n\n  MemoryBuffer &operator=(MemoryBuffer &&other) {\n    assert(this != &other);\n    deallocate();\n    move(other);\n    return *this;\n  }\n#endif\n\n  // Returns a copy of the allocator associated with this buffer.\n  Allocator get_allocator() const { return *this; }\n};\n\ntemplate <typename T, std::size_t SIZE, typename Allocator>\nvoid MemoryBuffer<T, SIZE, Allocator>::grow(std::size_t size) {\n  std::size_t new_capacity =\n      (std::max)(size, this->capacity_ + this->capacity_ / 2);\n  T *new_ptr = this->allocate(new_capacity);\n  // The following code doesn't throw, so the raw pointer above doesn't leak.\n  std::copy(this->ptr_,\n            this->ptr_ + this->size_, make_ptr(new_ptr, new_capacity));\n  std::size_t old_capacity = this->capacity_;\n  T *old_ptr = this->ptr_;\n  this->capacity_ = new_capacity;\n  this->ptr_ = new_ptr;\n  // deallocate may throw (at least in principle), but it doesn't matter since\n  // the buffer already uses the new storage and will deallocate it in case\n  // of exception.\n  if (old_ptr != data_)\n    Allocator::deallocate(old_ptr, old_capacity);\n}\n\n// A fixed-size buffer.\ntemplate <typename Char>\nclass FixedBuffer : public fmt::Buffer<Char> {\n public:\n  FixedBuffer(Char *array, std::size_t size) : fmt::Buffer<Char>(array, size) {}\n\n protected:\n  void grow(std::size_t size);\n};\n\n#ifndef _MSC_VER\n// Portable version of signbit.\ninline int getsign(double x) {\n  // When compiled in C++11 mode signbit is no longer a macro but a function\n  // defined in namespace std and the macro is undefined.\n# ifdef signbit\n  return signbit(x);\n# else\n  return std::signbit(x);\n# endif\n}\n\n// Portable version of isinf.\n# ifdef isinf\ninline int isinfinity(double x) { return isinf(x); }\ninline int isinfinity(long double x) { return isinf(x); }\n# else\ninline int isinfinity(double x) { return std::isinf(x); }\ninline int isinfinity(long double x) { return std::isinf(x); }\n# endif\n\n// Portable version of isnan.\n# ifdef isnan\ninline int isnotanumber(double x) { return isnan(x); }\ninline int isnotanumber(long double x) { return isnan(x); }\n# else\ninline int isnotanumber(double x) { return std::isnan(x); }\ninline int isnotanumber(long double x) { return std::isnan(x); }\n# endif\n#else\ninline int getsign(double value) {\n  if (value < 0) return 1;\n  if (value == value) return 0;\n  int dec = 0, sign = 0;\n  char buffer[2];  // The buffer size must be >= 2 or _ecvt_s will fail.\n  _ecvt_s(buffer, sizeof(buffer), value, 0, &dec, &sign);\n  return sign;\n}\ninline int isinfinity(double x) { return !_finite(x); }\ninline int isinfinity(long double x) {\n  return !_finite(static_cast<double>(x));\n}\ninline int isnotanumber(double x) { return _isnan(x); }\ninline int isnotanumber(long double x) {\n    return _isnan(static_cast<double>(x));\n}\n#endif\n\ntemplate <typename Char>\nclass BasicCharTraits {\n public:\n#if FMT_SECURE_SCL\n  typedef stdext::checked_array_iterator<Char*> CharPtr;\n#else\n  typedef Char *CharPtr;\n#endif\n  static Char cast(wchar_t value) { return static_cast<Char>(value); }\n};\n\ntemplate <typename Char>\nclass CharTraits;\n\ntemplate <>\nclass CharTraits<char> : public BasicCharTraits<char> {\n private:\n  // Conversion from wchar_t to char is not allowed.\n  static char convert(wchar_t);\n\n public:\n  static char convert(char value) { return value; }\n\n  // Formats a floating-point number.\n  template <typename T>\n  static int format_float(char *buffer, std::size_t size,\n      const char *format, unsigned width, int precision, T value);\n};\n\ntemplate <>\nclass CharTraits<wchar_t> : public BasicCharTraits<wchar_t> {\n public:\n  static wchar_t convert(char value) { return value; }\n  static wchar_t convert(wchar_t value) { return value; }\n\n  template <typename T>\n  static int format_float(wchar_t *buffer, std::size_t size,\n      const wchar_t *format, unsigned width, int precision, T value);\n};\n\n// Checks if a number is negative - used to avoid warnings.\ntemplate <bool IsSigned>\nstruct SignChecker {\n  template <typename T>\n  static bool is_negative(T value) { return value < 0; }\n};\n\ntemplate <>\nstruct SignChecker<false> {\n  template <typename T>\n  static bool is_negative(T) { return false; }\n};\n\n// Returns true if value is negative, false otherwise.\n// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.\ntemplate <typename T>\ninline bool is_negative(T value) {\n  return SignChecker<std::numeric_limits<T>::is_signed>::is_negative(value);\n}\n\n// Selects uint32_t if FitsIn32Bits is true, uint64_t otherwise.\ntemplate <bool FitsIn32Bits>\nstruct TypeSelector { typedef uint32_t Type; };\n\ntemplate <>\nstruct TypeSelector<false> { typedef uint64_t Type; };\n\ntemplate <typename T>\nstruct IntTraits {\n  // Smallest of uint32_t and uint64_t that is large enough to represent\n  // all values of T.\n  typedef typename\n    TypeSelector<std::numeric_limits<T>::digits <= 32>::Type MainType;\n};\n\n// MakeUnsigned<T>::Type gives an unsigned type corresponding to integer type T.\ntemplate <typename T>\nstruct MakeUnsigned { typedef T Type; };\n\n#define FMT_SPECIALIZE_MAKE_UNSIGNED(T, U) \\\n  template <> \\\n  struct MakeUnsigned<T> { typedef U Type; }\n\nFMT_SPECIALIZE_MAKE_UNSIGNED(char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(signed char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(short, unsigned short);\nFMT_SPECIALIZE_MAKE_UNSIGNED(int, unsigned);\nFMT_SPECIALIZE_MAKE_UNSIGNED(long, unsigned long);\nFMT_SPECIALIZE_MAKE_UNSIGNED(LongLong, ULongLong);\n\nvoid report_unknown_type(char code, const char *type);\n\n// Static data is placed in this class template to allow header-only\n// configuration.\ntemplate <typename T = void>\nstruct BasicData {\n  static const uint32_t POWERS_OF_10_32[];\n  static const uint64_t POWERS_OF_10_64[];\n  static const char DIGITS[];\n};\n\ntypedef BasicData<> Data;\n\n#if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clz)\n# define FMT_BUILTIN_CLZ(n) __builtin_clz(n)\n#endif\n\n#if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clzll)\n# define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)\n#endif\n\n#ifdef FMT_BUILTIN_CLZLL\n// Returns the number of decimal digits in n. Leading zeros are not counted\n// except for n == 0 in which case count_digits returns 1.\ninline unsigned count_digits(uint64_t n) {\n  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.\n  unsigned t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;\n  return t - (n < Data::POWERS_OF_10_64[t]) + 1;\n}\n#else\n// Fallback version of count_digits used when __builtin_clz is not available.\ninline unsigned count_digits(uint64_t n) {\n  unsigned count = 1;\n  for (;;) {\n    // Integer division is slow so do it for a group of four digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    if (n < 10) return count;\n    if (n < 100) return count + 1;\n    if (n < 1000) return count + 2;\n    if (n < 10000) return count + 3;\n    n /= 10000u;\n    count += 4;\n  }\n}\n#endif\n\n#ifdef FMT_BUILTIN_CLZ\n// Optional version of count_digits for better performance on 32-bit platforms.\ninline unsigned count_digits(uint32_t n) {\n  uint32_t t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 >> 12;\n  return t - (n < Data::POWERS_OF_10_32[t]) + 1;\n}\n#endif\n\n// Formats a decimal unsigned integer value writing into buffer.\ntemplate <typename UInt, typename Char>\ninline void format_decimal(Char *buffer, UInt value, unsigned num_digits) {\n  buffer += num_digits;\n  while (value >= 100) {\n    // Integer division is slow so do it for a group of two digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    unsigned index = (value % 100) * 2;\n    value /= 100;\n    *--buffer = Data::DIGITS[index + 1];\n    *--buffer = Data::DIGITS[index];\n  }\n  if (value < 10) {\n    *--buffer = static_cast<char>('0' + value);\n    return;\n  }\n  unsigned index = static_cast<unsigned>(value * 2);\n  *--buffer = Data::DIGITS[index + 1];\n  *--buffer = Data::DIGITS[index];\n}\n\n#ifndef _WIN32\n# define FMT_USE_WINDOWS_H 0\n#elif !defined(FMT_USE_WINDOWS_H)\n# define FMT_USE_WINDOWS_H 1\n#endif\n\n// Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.\n// All the functionality that relies on it will be disabled too.\n#if FMT_USE_WINDOWS_H\n// A converter from UTF-8 to UTF-16.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF8ToUTF16 {\n private:\n  MemoryBuffer<wchar_t, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  explicit UTF8ToUTF16(StringRef s);\n  operator WStringRef() const { return WStringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const wchar_t *c_str() const { return &buffer_[0]; }\n  std::wstring str() const { return std::wstring(&buffer_[0], size()); }\n};\n\n// A converter from UTF-16 to UTF-8.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF16ToUTF8 {\n private:\n  MemoryBuffer<char, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  UTF16ToUTF8() {}\n  explicit UTF16ToUTF8(WStringRef s);\n  operator StringRef() const { return StringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const char *c_str() const { return &buffer_[0]; }\n  std::string str() const { return std::string(&buffer_[0], size()); }\n\n  // Performs conversion returning a system error code instead of\n  // throwing exception on conversion error. This method may still throw\n  // in case of memory allocation error.\n  int convert(WStringRef s);\n};\n\nvoid format_windows_error(fmt::Writer &out, int error_code,\n                          fmt::StringRef message) FMT_NOEXCEPT;\n#endif\n\nvoid format_system_error(fmt::Writer &out, int error_code,\n                         fmt::StringRef message) FMT_NOEXCEPT;\n\n// A formatting argument value.\nstruct Value {\n  template <typename Char>\n  struct StringValue {\n    const Char *value;\n    std::size_t size;\n  };\n\n  typedef void (*FormatFunc)(\n      void *formatter, const void *arg, void *format_str_ptr);\n\n  struct CustomValue {\n    const void *value;\n    FormatFunc format;\n  };\n\n  union {\n    int int_value;\n    unsigned uint_value;\n    LongLong long_long_value;\n    ULongLong ulong_long_value;\n    double double_value;\n    long double long_double_value;\n    const void *pointer;\n    StringValue<char> string;\n    StringValue<signed char> sstring;\n    StringValue<unsigned char> ustring;\n    StringValue<wchar_t> wstring;\n    CustomValue custom;\n  };\n\n  enum Type {\n    NONE, NAMED_ARG,\n    // Integer types should go first,\n    INT, UINT, LONG_LONG, ULONG_LONG, BOOL, CHAR, LAST_INTEGER_TYPE = CHAR,\n    // followed by floating-point types.\n    DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,\n    CSTRING, STRING, WSTRING, POINTER, CUSTOM\n  };\n};\n\n// A formatting argument. It is a POD type to allow storage in\n// internal::MemoryBuffer.\nstruct Arg : Value {\n  Type type;\n};\n\ntemplate <typename Char>\nstruct NamedArg;\n\ntemplate <typename T = void>\nstruct Null {};\n\n// A helper class template to enable or disable overloads taking wide\n// characters and strings in MakeValue.\ntemplate <typename T, typename Char>\nstruct WCharHelper {\n  typedef Null<T> Supported;\n  typedef T Unsupported;\n};\n\ntemplate <typename T>\nstruct WCharHelper<T, wchar_t> {\n  typedef T Supported;\n  typedef Null<T> Unsupported;\n};\n\ntemplate <typename T>\nclass IsConvertibleToInt {\n private:\n  typedef char yes[1];\n  typedef char no[2];\n\n  static const T &get();\n\n  static yes &convert(fmt::ULongLong);\n  static no &convert(...);\n\n public:\n  enum { value = (sizeof(convert(get())) == sizeof(yes)) };\n};\n\n#define FMT_CONVERTIBLE_TO_INT(Type) \\\n  template <> \\\n  class IsConvertibleToInt<Type> { \\\n   public: \\\n    enum { value = 1 }; \\\n  }\n\n// Silence warnings about convering float to int.\nFMT_CONVERTIBLE_TO_INT(float);\nFMT_CONVERTIBLE_TO_INT(double);\nFMT_CONVERTIBLE_TO_INT(long double);\n\ntemplate<bool B, class T = void>\nstruct EnableIf {};\n\ntemplate<class T>\nstruct EnableIf<true, T> { typedef T type; };\n\ntemplate<bool B, class T, class F>\nstruct Conditional { typedef T type; };\n\ntemplate<class T, class F>\nstruct Conditional<false, T, F> { typedef F type; };\n\n// A helper function to suppress bogus \"conditional expression is constant\"\n// warnings.\ntemplate <typename T>\ninline T check(T value) { return value; }\n\n// Makes an Arg object from any type.\ntemplate <typename Char>\nclass MakeValue : public Arg {\n private:\n  // The following two methods are private to disallow formatting of\n  // arbitrary pointers. If you want to output a pointer cast it to\n  // \"void *\" or \"const void *\". In particular, this forbids formatting\n  // of \"[const] volatile char *\" which is printed as bool by iostreams.\n  // Do not implement!\n  template <typename T>\n  MakeValue(const T *value);\n  template <typename T>\n  MakeValue(T *value);\n\n  // The following methods are private to disallow formatting of wide\n  // characters and strings into narrow strings as in\n  //   fmt::format(\"{}\", L\"test\");\n  // To fix this, use a wide format string: fmt::format(L\"{}\", L\"test\").\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Unsupported);\n#endif\n  MakeValue(typename WCharHelper<wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const std::wstring &, Char>::Unsupported);\n  MakeValue(typename WCharHelper<WStringRef, Char>::Unsupported);\n\n  void set_string(StringRef str) {\n    string.value = str.data();\n    string.size = str.size();\n  }\n\n  void set_string(WStringRef str) {\n    wstring.value = str.data();\n    wstring.size = str.size();\n  }\n\n  // Formats an argument of a custom type, such as a user-defined class.\n  template <typename T>\n  static void format_custom_arg(\n      void *formatter, const void *arg, void *format_str_ptr) {\n    format(*static_cast<BasicFormatter<Char>*>(formatter),\n           *static_cast<const Char**>(format_str_ptr),\n           *static_cast<const T*>(arg));\n  }\n\n public:\n  MakeValue() {}\n\n#define FMT_MAKE_VALUE_(Type, field, TYPE, rhs) \\\n  MakeValue(Type value) { field = rhs; } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n#define FMT_MAKE_VALUE(Type, field, TYPE) \\\n  FMT_MAKE_VALUE_(Type, field, TYPE, value)\n\n  FMT_MAKE_VALUE(bool, int_value, BOOL)\n  FMT_MAKE_VALUE(short, int_value, INT)\n  FMT_MAKE_VALUE(unsigned short, uint_value, UINT)\n  FMT_MAKE_VALUE(int, int_value, INT)\n  FMT_MAKE_VALUE(unsigned, uint_value, UINT)\n\n  MakeValue(long value) {\n    // To minimize the number of types we need to deal with, long is\n    // translated either to int or to long long depending on its size.\n    if (check(sizeof(long) == sizeof(int)))\n      int_value = static_cast<int>(value);\n    else\n      long_long_value = value;\n  }\n  static uint64_t type(long) {\n    return sizeof(long) == sizeof(int) ? Arg::INT : Arg::LONG_LONG;\n  }\n\n  MakeValue(unsigned long value) {\n    if (check(sizeof(unsigned long) == sizeof(unsigned)))\n      uint_value = static_cast<unsigned>(value);\n    else\n      ulong_long_value = value;\n  }\n  static uint64_t type(unsigned long) {\n    return sizeof(unsigned long) == sizeof(unsigned) ?\n          Arg::UINT : Arg::ULONG_LONG;\n  }\n\n  FMT_MAKE_VALUE(LongLong, long_long_value, LONG_LONG)\n  FMT_MAKE_VALUE(ULongLong, ulong_long_value, ULONG_LONG)\n  FMT_MAKE_VALUE(float, double_value, DOUBLE)\n  FMT_MAKE_VALUE(double, double_value, DOUBLE)\n  FMT_MAKE_VALUE(long double, long_double_value, LONG_DOUBLE)\n  FMT_MAKE_VALUE(signed char, int_value, CHAR)\n  FMT_MAKE_VALUE(unsigned char, int_value, CHAR)\n  FMT_MAKE_VALUE(char, int_value, CHAR)\n\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Supported value) {\n    int_value = value;\n  }\n  static uint64_t type(wchar_t) { return Arg::CHAR; }\n#endif\n\n#define FMT_MAKE_STR_VALUE(Type, TYPE) \\\n  MakeValue(Type value) { set_string(value); } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_VALUE(char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(const char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(const signed char *, sstring.value, CSTRING)\n  FMT_MAKE_VALUE(const unsigned char *, ustring.value, CSTRING)\n  FMT_MAKE_STR_VALUE(const std::string &, STRING)\n  FMT_MAKE_STR_VALUE(StringRef, STRING)\n  FMT_MAKE_VALUE_(CStringRef, string.value, CSTRING, value.c_str())\n\n#define FMT_MAKE_WSTR_VALUE(Type, TYPE) \\\n  MakeValue(typename WCharHelper<Type, Char>::Supported value) { \\\n    set_string(value); \\\n  } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_WSTR_VALUE(wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const std::wstring &, WSTRING)\n  FMT_MAKE_WSTR_VALUE(WStringRef, WSTRING)\n\n  FMT_MAKE_VALUE(void *, pointer, POINTER)\n  FMT_MAKE_VALUE(const void *, pointer, POINTER)\n\n  template <typename T>\n  MakeValue(const T &value,\n            typename EnableIf<!IsConvertibleToInt<T>::value, int>::type = 0) {\n    custom.value = &value;\n    custom.format = &format_custom_arg<T>;\n  }\n\n  template <typename T>\n  MakeValue(const T &value,\n            typename EnableIf<IsConvertibleToInt<T>::value, int>::type = 0) {\n    int_value = value;\n  }\n\n  template <typename T>\n  static uint64_t type(const T &) {\n    return IsConvertibleToInt<T>::value ? Arg::INT : Arg::CUSTOM;\n  }\n\n  // Additional template param `Char_` is needed here because make_type always\n  // uses MakeValue<char>.\n  template <typename Char_>\n  MakeValue(const NamedArg<Char_> &value) { pointer = &value; }\n\n  template <typename Char_>\n  static uint64_t type(const NamedArg<Char_> &) { return Arg::NAMED_ARG; }\n};\n\ntemplate <typename Char>\nstruct NamedArg : Arg {\n  BasicStringRef<Char> name;\n\n  template <typename T>\n  NamedArg(BasicStringRef<Char> argname, const T &value)\n  : Arg(MakeValue<Char>(value)), name(argname) {\n    type = static_cast<internal::Arg::Type>(MakeValue<Char>::type(value));\n  }\n};\n\n#define FMT_DISPATCH(call) static_cast<Impl*>(this)->call\n\n// An argument visitor.\n// To use ArgVisitor define a subclass that implements some or all of the\n// visit methods with the same signatures as the methods in ArgVisitor,\n// for example, visit_int(int).\n// Specify the subclass name as the Impl template parameter. Then calling\n// ArgVisitor::visit for some argument will dispatch to a visit method\n// specific to the argument type. For example, if the argument type is\n// double then visit_double(double) method of a subclass will be called.\n// If the subclass doesn't contain a method with this signature, then\n// a corresponding method of ArgVisitor will be called.\n//\n// Example:\n//  class MyArgVisitor : public ArgVisitor<MyArgVisitor, void> {\n//   public:\n//    void visit_int(int value) { print(\"{}\", value); }\n//    void visit_double(double value) { print(\"{}\", value ); }\n//  };\n//\n// ArgVisitor uses the curiously recurring template pattern:\n// http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\ntemplate <typename Impl, typename Result>\nclass ArgVisitor {\n public:\n  void report_unhandled_arg() {}\n\n  Result visit_unhandled_arg() {\n    FMT_DISPATCH(report_unhandled_arg());\n    return Result();\n  }\n\n  Result visit_int(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_long_long(LongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_uint(unsigned value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_ulong_long(ULongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_bool(bool value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_char(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  template <typename T>\n  Result visit_any_int(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  Result visit_double(double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n  Result visit_long_double(long double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n  template <typename T>\n  Result visit_any_double(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  Result visit_string(Arg::StringValue<char>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n  Result visit_wstring(Arg::StringValue<wchar_t>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n  Result visit_pointer(const void *) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n  Result visit_custom(Arg::CustomValue) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  Result visit(const Arg &arg) {\n    switch (arg.type) {\n    default:\n      FMT_ASSERT(false, \"invalid argument type\");\n      return Result();\n    case Arg::INT:\n      return FMT_DISPATCH(visit_int(arg.int_value));\n    case Arg::UINT:\n      return FMT_DISPATCH(visit_uint(arg.uint_value));\n    case Arg::LONG_LONG:\n      return FMT_DISPATCH(visit_long_long(arg.long_long_value));\n    case Arg::ULONG_LONG:\n      return FMT_DISPATCH(visit_ulong_long(arg.ulong_long_value));\n    case Arg::BOOL:\n      return FMT_DISPATCH(visit_bool(arg.int_value != 0));\n    case Arg::CHAR:\n      return FMT_DISPATCH(visit_char(arg.int_value));\n    case Arg::DOUBLE:\n      return FMT_DISPATCH(visit_double(arg.double_value));\n    case Arg::LONG_DOUBLE:\n      return FMT_DISPATCH(visit_long_double(arg.long_double_value));\n    case Arg::CSTRING: {\n      Arg::StringValue<char> str = arg.string;\n      str.size = 0;\n      return FMT_DISPATCH(visit_string(str));\n    }\n    case Arg::STRING:\n      return FMT_DISPATCH(visit_string(arg.string));\n    case Arg::WSTRING:\n      return FMT_DISPATCH(visit_wstring(arg.wstring));\n    case Arg::POINTER:\n      return FMT_DISPATCH(visit_pointer(arg.pointer));\n    case Arg::CUSTOM:\n      return FMT_DISPATCH(visit_custom(arg.custom));\n    }\n  }\n};\n\nclass RuntimeError : public std::runtime_error {\n protected:\n  RuntimeError() : std::runtime_error(\"\") {}\n};\n\ntemplate <typename Impl, typename Char>\nclass BasicArgFormatter;\n\ntemplate <typename Char>\nclass PrintfArgFormatter;\n\ntemplate <typename Char>\nclass ArgMap;\n}  // namespace internal\n\n/** An argument list. */\nclass ArgList {\n private:\n  // To reduce compiled code size per formatting function call, types of first\n  // MAX_PACKED_ARGS arguments are passed in the types_ field.\n  uint64_t types_;\n  union {\n    // If the number of arguments is less than MAX_PACKED_ARGS, the argument\n    // values are stored in values_, otherwise they are stored in args_.\n    // This is done to reduce compiled code size as storing larger objects\n    // may require more code (at least on x86-64) even if the same amount of\n    // data is actually copied to stack. It saves ~10% on the bloat test.\n    const internal::Value *values_;\n    const internal::Arg *args_;\n  };\n\n  internal::Arg::Type type(unsigned index) const {\n    unsigned shift = index * 4;\n    uint64_t mask = 0xf;\n    return static_cast<internal::Arg::Type>(\n          (types_ & (mask << shift)) >> shift);\n  }\n\n  template <typename Char>\n  friend class internal::ArgMap;\n\n public:\n  // Maximum number of arguments with packed types.\n  enum { MAX_PACKED_ARGS = 16 };\n\n  ArgList() : types_(0) {}\n\n  ArgList(ULongLong types, const internal::Value *values)\n  : types_(types), values_(values) {}\n  ArgList(ULongLong types, const internal::Arg *args)\n  : types_(types), args_(args) {}\n\n  /** Returns the argument at specified index. */\n  internal::Arg operator[](unsigned index) const {\n    using internal::Arg;\n    Arg arg;\n    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;\n    if (index < MAX_PACKED_ARGS) {\n      Arg::Type arg_type = type(index);\n      internal::Value &val = arg;\n      if (arg_type != Arg::NONE)\n        val = use_values ? values_[index] : args_[index];\n      arg.type = arg_type;\n      return arg;\n    }\n    if (use_values) {\n      // The index is greater than the number of arguments that can be stored\n      // in values, so return a \"none\" argument.\n      arg.type = Arg::NONE;\n      return arg;\n    }\n    for (unsigned i = MAX_PACKED_ARGS; i <= index; ++i) {\n      if (args_[i].type == Arg::NONE)\n        return args_[i];\n    }\n    return args_[index];\n  }\n};\n\nstruct FormatSpec;\n\nnamespace internal {\n\ntemplate <typename Char>\nclass ArgMap {\n private:\n  typedef std::map<fmt::BasicStringRef<Char>, internal::Arg> MapType;\n  typedef typename MapType::value_type Pair;\n\n  MapType map_;\n\n public:\n  void init(const ArgList &args);\n\n  const internal::Arg* find(const fmt::BasicStringRef<Char> &name) const {\n    typename MapType::const_iterator it = map_.find(name);\n    return it != map_.end() ? &it->second : 0;\n  }\n};\n\nclass FormatterBase {\n private:\n  ArgList args_;\n  int next_arg_index_;\n\n  // Returns the argument with specified index.\n  Arg do_get_arg(unsigned arg_index, const char *&error);\n\n protected:\n  const ArgList &args() const { return args_; }\n\n  explicit FormatterBase(const ArgList &args) {\n    args_ = args;\n    next_arg_index_ = 0;\n  }\n\n  // Returns the next argument.\n  Arg next_arg(const char *&error);\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified index.\n  Arg get_arg(unsigned arg_index, const char *&error);\n\n  bool check_no_auto_index(const char *&error);\n\n  template <typename Char>\n  void write(BasicWriter<Char> &w, const Char *start, const Char *end) {\n    if (start != end)\n      w << BasicStringRef<Char>(start, end - start);\n  }\n};\n\n// A printf formatter.\ntemplate <typename Char>\nclass PrintfFormatter : private FormatterBase {\n private:\n  void parse_flags(FormatSpec &spec, const Char *&s);\n\n  // Returns the argument with specified index or, if arg_index is equal\n  // to the maximum unsigned value, the next argument.\n  Arg get_arg(const Char *s,\n      unsigned arg_index = (std::numeric_limits<unsigned>::max)());\n\n  // Parses argument index, flags and width and returns the argument index.\n  unsigned parse_header(const Char *&s, FormatSpec &spec);\n\n public:\n  explicit PrintfFormatter(const ArgList &args) : FormatterBase(args) {}\n  void format(BasicWriter<Char> &writer, BasicCStringRef<Char> format_str);\n};\n}  // namespace internal\n\n// A formatter.\ntemplate <typename Char>\nclass BasicFormatter : private internal::FormatterBase {\n private:\n  BasicWriter<Char> &writer_;\n  internal::ArgMap<Char> map_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicFormatter);\n\n  using FormatterBase::get_arg;\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified name.\n  internal::Arg get_arg(BasicStringRef<Char> arg_name, const char *&error);\n\n  // Parses argument index and returns corresponding argument.\n  internal::Arg parse_arg_index(const Char *&s);\n\n  // Parses argument name and returns corresponding argument.\n  internal::Arg parse_arg_name(const Char *&s);\n\n public:\n  BasicFormatter(const ArgList &args, BasicWriter<Char> &w)\n    : FormatterBase(args), writer_(w) {}\n\n  BasicWriter<Char> &writer() { return writer_; }\n\n  void format(BasicCStringRef<Char> format_str);\n\n  const Char *format(const Char *&format_str, const internal::Arg &arg);\n};\n\nenum Alignment {\n  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC\n};\n\n// Flags.\nenum {\n  SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8,\n  CHAR_FLAG = 0x10  // Argument has char type - used in error reporting.\n};\n\n// An empty format specifier.\nstruct EmptySpec {};\n\n// A type specifier.\ntemplate <char TYPE>\nstruct TypeSpec : EmptySpec {\n  Alignment align() const { return ALIGN_DEFAULT; }\n  unsigned width() const { return 0; }\n  int precision() const { return -1; }\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n  char fill() const { return ' '; }\n};\n\n// A width specifier.\nstruct WidthSpec {\n  unsigned width_;\n  // Fill is always wchar_t and cast to char if necessary to avoid having\n  // two specialization of WidthSpec and its subclasses.\n  wchar_t fill_;\n\n  WidthSpec(unsigned width, wchar_t fill) : width_(width), fill_(fill) {}\n\n  unsigned width() const { return width_; }\n  wchar_t fill() const { return fill_; }\n};\n\n// An alignment specifier.\nstruct AlignSpec : WidthSpec {\n  Alignment align_;\n\n  AlignSpec(unsigned width, wchar_t fill, Alignment align = ALIGN_DEFAULT)\n  : WidthSpec(width, fill), align_(align) {}\n\n  Alignment align() const { return align_; }\n\n  int precision() const { return -1; }\n};\n\n// An alignment and type specifier.\ntemplate <char TYPE>\nstruct AlignTypeSpec : AlignSpec {\n  AlignTypeSpec(unsigned width, wchar_t fill) : AlignSpec(width, fill) {}\n\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n};\n\n// A full format specifier.\nstruct FormatSpec : AlignSpec {\n  unsigned flags_;\n  int precision_;\n  char type_;\n\n  FormatSpec(\n    unsigned width = 0, char type = 0, wchar_t fill = ' ')\n  : AlignSpec(width, fill), flags_(0), precision_(-1), type_(type) {}\n\n  bool flag(unsigned f) const { return (flags_ & f) != 0; }\n  int precision() const { return precision_; }\n  char type() const { return type_; }\n};\n\n// An integer format specifier.\ntemplate <typename T, typename SpecT = TypeSpec<0>, typename Char = char>\nclass IntFormatSpec : public SpecT {\n private:\n  T value_;\n\n public:\n  IntFormatSpec(T val, const SpecT &spec = SpecT())\n  : SpecT(spec), value_(val) {}\n\n  T value() const { return value_; }\n};\n\n// A string format specifier.\ntemplate <typename Char>\nclass StrFormatSpec : public AlignSpec {\n private:\n  const Char *str_;\n\n public:\n  template <typename FillChar>\n  StrFormatSpec(const Char *str, unsigned width, FillChar fill)\n  : AlignSpec(width, fill), str_(str) {\n    internal::CharTraits<Char>::convert(FillChar());\n  }\n\n  const Char *str() const { return str_; }\n};\n\n/**\n  Returns an integer format specifier to format the value in base 2.\n */\nIntFormatSpec<int, TypeSpec<'b'> > bin(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 8.\n */\nIntFormatSpec<int, TypeSpec<'o'> > oct(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 16 using\n  lower-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'x'> > hex(int value);\n\n/**\n  Returns an integer formatter format specifier to format in base 16 using\n  upper-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'X'> > hexu(int value);\n\n/**\n  \\rst\n  Returns an integer format specifier to pad the formatted argument with the\n  fill character to the specified width using the default (right) numeric\n  alignment.\n\n  **Example**::\n\n    MemoryWriter out;\n    out << pad(hex(0xcafe), 8, '0');\n    // out.str() == \"0000cafe\"\n\n  \\endrst\n */\ntemplate <char TYPE_CODE, typename Char>\nIntFormatSpec<int, AlignTypeSpec<TYPE_CODE>, Char> pad(\n    int value, unsigned width, Char fill = ' ');\n\n#define FMT_DEFINE_INT_FORMATTERS(TYPE) \\\ninline IntFormatSpec<TYPE, TypeSpec<'b'> > bin(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'b'> >(value, TypeSpec<'b'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'o'> > oct(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'o'> >(value, TypeSpec<'o'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'x'> > hex(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'x'> >(value, TypeSpec<'x'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'X'> > hexu(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'X'> >(value, TypeSpec<'X'>()); \\\n} \\\n \\\ntemplate <char TYPE_CODE> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> > pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE> > f, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> >( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, ' ')); \\\n} \\\n \\\n/* For compatibility with older compilers we provide two overloads for pad, */ \\\n/* one that takes a fill character and one that doesn't. In the future this */ \\\n/* can be replaced with one overload making the template argument Char      */ \\\n/* default to char (C++11). */ \\\ntemplate <char TYPE_CODE, typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char> pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE>, Char> f, \\\n    unsigned width, Char fill) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char>( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, fill)); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0> > pad( \\\n    TYPE value, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<0> >( \\\n      value, AlignTypeSpec<0>(width, ' ')); \\\n} \\\n \\\ntemplate <typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0>, Char> pad( \\\n   TYPE value, unsigned width, Char fill) { \\\n return IntFormatSpec<TYPE, AlignTypeSpec<0>, Char>( \\\n     value, AlignTypeSpec<0>(width, fill)); \\\n}\n\nFMT_DEFINE_INT_FORMATTERS(int)\nFMT_DEFINE_INT_FORMATTERS(long)\nFMT_DEFINE_INT_FORMATTERS(unsigned)\nFMT_DEFINE_INT_FORMATTERS(unsigned long)\nFMT_DEFINE_INT_FORMATTERS(LongLong)\nFMT_DEFINE_INT_FORMATTERS(ULongLong)\n\n/**\n  \\rst\n  Returns a string formatter that pads the formatted argument with the fill\n  character to the specified width using the default (left) string alignment.\n\n  **Example**::\n\n    std::string s = str(MemoryWriter() << pad(\"abc\", 8));\n    // s == \"abc     \"\n\n  \\endrst\n */\ntemplate <typename Char>\ninline StrFormatSpec<Char> pad(\n    const Char *str, unsigned width, Char fill = ' ') {\n  return StrFormatSpec<Char>(str, width, fill);\n}\n\ninline StrFormatSpec<wchar_t> pad(\n    const wchar_t *str, unsigned width, char fill = ' ') {\n  return StrFormatSpec<wchar_t>(str, width, fill);\n}\n\n// Generates a comma-separated list with results of applying f to\n// numbers 0..n-1.\n# define FMT_GEN(n, f) FMT_GEN##n(f)\n# define FMT_GEN1(f)  f(0)\n# define FMT_GEN2(f)  FMT_GEN1(f),  f(1)\n# define FMT_GEN3(f)  FMT_GEN2(f),  f(2)\n# define FMT_GEN4(f)  FMT_GEN3(f),  f(3)\n# define FMT_GEN5(f)  FMT_GEN4(f),  f(4)\n# define FMT_GEN6(f)  FMT_GEN5(f),  f(5)\n# define FMT_GEN7(f)  FMT_GEN6(f),  f(6)\n# define FMT_GEN8(f)  FMT_GEN7(f),  f(7)\n# define FMT_GEN9(f)  FMT_GEN8(f),  f(8)\n# define FMT_GEN10(f) FMT_GEN9(f),  f(9)\n# define FMT_GEN11(f) FMT_GEN10(f), f(10)\n# define FMT_GEN12(f) FMT_GEN11(f), f(11)\n# define FMT_GEN13(f) FMT_GEN12(f), f(12)\n# define FMT_GEN14(f) FMT_GEN13(f), f(13)\n# define FMT_GEN15(f) FMT_GEN14(f), f(14)\n\nnamespace internal {\ninline uint64_t make_type() { return 0; }\n\ntemplate <typename T>\ninline uint64_t make_type(const T &arg) { return MakeValue<char>::type(arg); }\n\ntemplate <unsigned N>\nstruct ArgArray {\n  // Computes the argument array size by adding 1 to N, which is the number of\n  // arguments, if N is zero, because array of zero size is invalid, or if N\n  // is greater than ArgList::MAX_PACKED_ARGS to accommodate for an extra\n  // argument that marks the end of the list.\n  enum { SIZE = N + (N == 0 || N >= ArgList::MAX_PACKED_ARGS ? 1 : 0) };\n\n  typedef typename Conditional<\n    (N < ArgList::MAX_PACKED_ARGS), Value, Arg>::type Type[SIZE];\n};\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate <typename Arg, typename... Args>\ninline uint64_t make_type(const Arg &first, const Args & ... tail) {\n  return make_type(first) | (make_type(tail...) << 4);\n}\n\ninline void do_set_types(Arg *) {}\n\ntemplate <typename T, typename... Args>\ninline void do_set_types(Arg *args, const T &arg, const Args & ... tail) {\n  args->type = static_cast<Arg::Type>(MakeValue<T>::type(arg));\n  do_set_types(args + 1, tail...);\n}\n\ntemplate <typename... Args>\ninline void set_types(Arg *array, const Args & ... args) {\n  if (check(sizeof...(Args) > ArgList::MAX_PACKED_ARGS))\n    do_set_types(array, args...);\n  array[sizeof...(Args)].type = Arg::NONE;\n}\n\ntemplate <typename... Args>\ninline void set_types(Value *, const Args & ...) {\n  // Do nothing as types are passed separately from values.\n}\n\ntemplate <typename Char, typename Value>\ninline void store_args(Value *) {}\n\ntemplate <typename Char, typename Arg, typename T, typename... Args>\ninline void store_args(Arg *args, const T &arg, const Args & ... tail) {\n  // Assign only the Value subobject of Arg and don't overwrite type (if any)\n  // that is assigned by set_types.\n  Value &value = *args;\n  value = MakeValue<Char>(arg);\n  store_args<Char>(args + 1, tail...);\n}\n\ntemplate <typename Char, typename... Args>\nArgList make_arg_list(typename ArgArray<sizeof...(Args)>::Type array,\n                      const Args & ... args) {\n  if (check(sizeof...(Args) >= ArgList::MAX_PACKED_ARGS))\n    set_types(array, args...);\n  store_args<Char>(array, args...);\n  return ArgList(make_type(args...), array);\n}\n#else\n\nstruct ArgType {\n  uint64_t type;\n\n  ArgType() : type(0) {}\n\n  template <typename T>\n  ArgType(const T &arg) : type(make_type(arg)) {}\n};\n\n# define FMT_ARG_TYPE_DEFAULT(n) ArgType t##n = ArgType()\n\ninline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n  return t0.type | (t1.type << 4) | (t2.type << 8) | (t3.type << 12) |\n      (t4.type << 16) | (t5.type << 20) | (t6.type << 24) | (t7.type << 28) |\n      (t8.type << 32) | (t9.type << 36) | (t10.type << 40) | (t11.type << 44) |\n      (t12.type << 48) | (t13.type << 52) | (t14.type << 56);\n}\n#endif\n}  // namespace internal\n\n# define FMT_MAKE_TEMPLATE_ARG(n) typename T##n\n# define FMT_MAKE_ARG_TYPE(n) T##n\n# define FMT_MAKE_ARG(n) const T##n &v##n\n# define FMT_MAKE_REF_char(n) fmt::internal::MakeValue<char>(v##n)\n# define FMT_MAKE_REF_wchar_t(n) fmt::internal::MakeValue<wchar_t>(v##n)\n\n#if FMT_USE_VARIADIC_TEMPLATES\n// Defines a variadic function returning void.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  template <typename... Args> \\\n  void func(arg_type arg0, const Args & ... args) { \\\n    typename fmt::internal::ArgArray<sizeof...(Args)>::Type array; \\\n    func(arg0, fmt::internal::make_arg_list<Char>(array, args...)); \\\n  }\n\n// Defines a variadic constructor.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  template <typename... Args> \\\n  ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \\\n    typename fmt::internal::ArgArray<sizeof...(Args)>::Type array; \\\n    func(arg0, arg1, fmt::internal::make_arg_list<Char>(array, args...)); \\\n  }\n\n#else\n\n# define FMT_MAKE_REF(n) fmt::internal::MakeValue<Char>(v##n)\n# define FMT_MAKE_REF2(n) v##n\n\n// Defines a wrapper for a function taking one argument of type arg_type\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP1(func, arg_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic function returning void on a pre-C++11 compiler.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  inline void func(arg_type arg) { func(arg, fmt::ArgList()); } \\\n  FMT_WRAP1(func, arg_type, 1) FMT_WRAP1(func, arg_type, 2) \\\n  FMT_WRAP1(func, arg_type, 3) FMT_WRAP1(func, arg_type, 4) \\\n  FMT_WRAP1(func, arg_type, 5) FMT_WRAP1(func, arg_type, 6) \\\n  FMT_WRAP1(func, arg_type, 7) FMT_WRAP1(func, arg_type, 8) \\\n  FMT_WRAP1(func, arg_type, 9) FMT_WRAP1(func, arg_type, 10)\n\n# define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg0, arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic constructor on a pre-C++11 compiler.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 1) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 2) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 3) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 4) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 5) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 6) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 7) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 8) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 9) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 10)\n#endif\n\n// Generates a comma-separated list with results of applying f to pairs\n// (argument, index).\n#define FMT_FOR_EACH1(f, x0) f(x0, 0)\n#define FMT_FOR_EACH2(f, x0, x1) \\\n  FMT_FOR_EACH1(f, x0), f(x1, 1)\n#define FMT_FOR_EACH3(f, x0, x1, x2) \\\n  FMT_FOR_EACH2(f, x0 ,x1), f(x2, 2)\n#define FMT_FOR_EACH4(f, x0, x1, x2, x3) \\\n  FMT_FOR_EACH3(f, x0, x1, x2), f(x3, 3)\n#define FMT_FOR_EACH5(f, x0, x1, x2, x3, x4) \\\n  FMT_FOR_EACH4(f, x0, x1, x2, x3), f(x4, 4)\n#define FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5) \\\n  FMT_FOR_EACH5(f, x0, x1, x2, x3, x4), f(x5, 5)\n#define FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6) \\\n  FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5), f(x6, 6)\n#define FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7) \\\n  FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6), f(x7, 7)\n#define FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8) \\\n  FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7), f(x8, 8)\n#define FMT_FOR_EACH10(f, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) \\\n  FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8), f(x9, 9)\n\n/**\n An error returned by an operating system or a language runtime,\n for example a file opening error.\n*/\nclass SystemError : public internal::RuntimeError {\n private:\n  void init(int err_code, CStringRef format_str, ArgList args);\n\n protected:\n  int error_code_;\n\n  typedef char Char;  // For FMT_VARIADIC_CTOR.\n\n  SystemError() {}\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::SystemError` object with the description\n   of the form\n\n   .. parsed-literal::\n     *<message>*: *<system-message>*\n\n   where *<message>* is the formatted message and *<system-message>* is\n   the system message corresponding to the error code.\n   *error_code* is a system error code as given by ``errno``.\n   If *error_code* is not a valid error code such as -1, the system message\n   may look like \"Unknown error -1\" and is platform-dependent.\n\n   **Example**::\n\n     // This throws a SystemError with the description\n     //   cannot open file 'madeup': No such file or directory\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     std::FILE *file = std::fopen(filename, \"r\");\n     if (!file)\n       throw fmt::SystemError(errno, \"cannot open file '{}'\", filename);\n   \\endrst\n  */\n  SystemError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_VARIADIC_CTOR(SystemError, init, int, CStringRef)\n\n  int error_code() const { return error_code_; }\n};\n\n/**\n  \\rst\n  This template provides operations for formatting and writing data into\n  a character stream. The output is stored in a buffer provided by a subclass\n  such as :class:`fmt::BasicMemoryWriter`.\n\n  You can use one of the following typedefs for common character types:\n\n  +---------+----------------------+\n  | Type    | Definition           |\n  +=========+======================+\n  | Writer  | BasicWriter<char>    |\n  +---------+----------------------+\n  | WWriter | BasicWriter<wchar_t> |\n  +---------+----------------------+\n\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicWriter {\n private:\n  // Output buffer.\n  Buffer<Char> &buffer_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicWriter);\n\n  typedef typename internal::CharTraits<Char>::CharPtr CharPtr;\n\n#if FMT_SECURE_SCL\n  // Returns pointer value.\n  static Char *get(CharPtr p) { return p.base(); }\n#else\n  static Char *get(Char *p) { return p; }\n#endif\n\n  // Fills the padding around the content and returns the pointer to the\n  // content area.\n  static CharPtr fill_padding(CharPtr buffer,\n      unsigned total_size, std::size_t content_size, wchar_t fill);\n\n  // Grows the buffer by n characters and returns a pointer to the newly\n  // allocated area.\n  CharPtr grow_buffer(std::size_t n) {\n    std::size_t size = buffer_.size();\n    buffer_.resize(size + n);\n    return internal::make_ptr(&buffer_[size], n);\n  }\n\n  // Writes an unsigned decimal integer.\n  template <typename UInt>\n  Char *write_unsigned_decimal(UInt value, unsigned prefix_size = 0) {\n    unsigned num_digits = internal::count_digits(value);\n    Char *ptr = get(grow_buffer(prefix_size + num_digits));\n    internal::format_decimal(ptr + prefix_size, value, num_digits);\n    return ptr;\n  }\n\n  // Writes a decimal integer.\n  template <typename Int>\n  void write_decimal(Int value) {\n    typename internal::IntTraits<Int>::MainType abs_value = value;\n    if (internal::is_negative(value)) {\n      abs_value = 0 - abs_value;\n      *write_unsigned_decimal(abs_value, 1) = '-';\n    } else {\n      write_unsigned_decimal(abs_value, 0);\n    }\n  }\n\n  // Prepare a buffer for integer formatting.\n  CharPtr prepare_int_buffer(unsigned num_digits,\n      const EmptySpec &, const char *prefix, unsigned prefix_size) {\n    unsigned size = prefix_size + num_digits;\n    CharPtr p = grow_buffer(size);\n    std::copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n\n  template <typename Spec>\n  CharPtr prepare_int_buffer(unsigned num_digits,\n    const Spec &spec, const char *prefix, unsigned prefix_size);\n\n  // Formats an integer.\n  template <typename T, typename Spec>\n  void write_int(T value, Spec spec);\n\n  // Formats a floating-point number (double or long double).\n  template <typename T>\n  void write_double(T value, const FormatSpec &spec);\n\n  // Writes a formatted string.\n  template <typename StrChar>\n  CharPtr write_str(\n      const StrChar *s, std::size_t size, const AlignSpec &spec);\n\n  template <typename StrChar>\n  void write_str(\n      const internal::Arg::StringValue<StrChar> &str, const FormatSpec &spec);\n\n  // This following methods are private to disallow writing wide characters\n  // and strings to a char stream. If you want to print a wide string as a\n  // pointer as std::ostream does, cast it to const void*.\n  // Do not implement!\n  void operator<<(typename internal::WCharHelper<wchar_t, Char>::Unsupported);\n  void operator<<(\n      typename internal::WCharHelper<const wchar_t *, Char>::Unsupported);\n\n  // Appends floating-point length specifier to the format string.\n  // The second argument is only used for overload resolution.\n  void append_float_length(Char *&format_ptr, long double) {\n    *format_ptr++ = 'L';\n  }\n\n  template<typename T>\n  void append_float_length(Char *&, T) {}\n\n  template <typename Impl, typename Char_>\n  friend class internal::BasicArgFormatter;\n\n  friend class internal::PrintfArgFormatter<Char>;\n\n protected:\n  /**\n    Constructs a ``BasicWriter`` object.\n   */\n  explicit BasicWriter(Buffer<Char> &b) : buffer_(b) {}\n\n public:\n  /**\n    \\rst\n    Destroys a ``BasicWriter`` object.\n    \\endrst\n   */\n  virtual ~BasicWriter() {}\n\n  /**\n    Returns the total number of characters written.\n   */\n  std::size_t size() const { return buffer_.size(); }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const Char *data() const FMT_NOEXCEPT { return &buffer_[0]; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const Char *c_str() const {\n    std::size_t size = buffer_.size();\n    buffer_.reserve(size + 1);\n    buffer_[size] = '\\0';\n    return &buffer_[0];\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an `std::string`.\n    \\endrst\n   */\n  std::basic_string<Char> str() const {\n    return std::basic_string<Char>(&buffer_[0], buffer_.size());\n  }\n\n  /**\n    \\rst\n    Writes formatted data.\n\n    *args* is an argument list representing arbitrary arguments.\n\n    **Example**::\n\n       MemoryWriter out;\n       out.write(\"Current point:\\n\");\n       out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n    This will write the following output to the ``out`` object:\n\n    .. code-block:: none\n\n       Current point:\n       (-3.140000, +3.140000)\n\n    The output can be accessed using :func:`data()`, :func:`c_str` or\n    :func:`str` methods.\n\n    See also :ref:`syntax`.\n    \\endrst\n   */\n  void write(BasicCStringRef<Char> format, ArgList args) {\n    BasicFormatter<Char>(args, *this).format(format);\n  }\n  FMT_VARIADIC_VOID(write, BasicCStringRef<Char>)\n\n  BasicWriter &operator<<(int value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned value) {\n    return *this << IntFormatSpec<unsigned>(value);\n  }\n  BasicWriter &operator<<(long value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned long value) {\n    return *this << IntFormatSpec<unsigned long>(value);\n  }\n  BasicWriter &operator<<(LongLong value) {\n    write_decimal(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(ULongLong value) {\n    return *this << IntFormatSpec<ULongLong>(value);\n  }\n\n  BasicWriter &operator<<(double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* using the general format for floating-point numbers\n    (``'g'``) and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(long double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    Writes a character to the stream.\n   */\n  BasicWriter &operator<<(char value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<wchar_t, Char>::Supported value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Writes *value* to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(fmt::BasicStringRef<Char> value) {\n    const Char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<StringRef, Char>::Supported value) {\n    const char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  template <typename T, typename Spec, typename FillChar>\n  BasicWriter &operator<<(IntFormatSpec<T, Spec, FillChar> spec) {\n    internal::CharTraits<Char>::convert(FillChar());\n    write_int(spec.value(), spec);\n    return *this;\n  }\n\n  template <typename StrChar>\n  BasicWriter &operator<<(const StrFormatSpec<StrChar> &spec) {\n    const StrChar *s = spec.str();\n    write_str(s, std::char_traits<Char>::length(s), spec);\n    return *this;\n  }\n\n  void clear() FMT_NOEXCEPT { buffer_.clear(); }\n};\n\ntemplate <typename Char>\ntemplate <typename StrChar>\ntypename BasicWriter<Char>::CharPtr BasicWriter<Char>::write_str(\n      const StrChar *s, std::size_t size, const AlignSpec &spec) {\n  CharPtr out = CharPtr();\n  if (spec.width() > size) {\n    out = grow_buffer(spec.width());\n    Char fill = internal::CharTraits<Char>::cast(spec.fill());\n    if (spec.align() == ALIGN_RIGHT) {\n      std::fill_n(out, spec.width() - size, fill);\n      out += spec.width() - size;\n    } else if (spec.align() == ALIGN_CENTER) {\n      out = fill_padding(out, spec.width(), size, fill);\n    } else {\n      std::fill_n(out + size, spec.width() - size, fill);\n    }\n  } else {\n    out = grow_buffer(size);\n  }\n  std::copy(s, s + size, out);\n  return out;\n}\n\ntemplate <typename Char>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::fill_padding(\n    CharPtr buffer, unsigned total_size,\n    std::size_t content_size, wchar_t fill) {\n  std::size_t padding = total_size - content_size;\n  std::size_t left_padding = padding / 2;\n  Char fill_char = internal::CharTraits<Char>::cast(fill);\n  std::fill_n(buffer, left_padding, fill_char);\n  buffer += left_padding;\n  CharPtr content = buffer;\n  std::fill_n(buffer + content_size, padding - left_padding, fill_char);\n  return content;\n}\n\ntemplate <typename Char>\ntemplate <typename Spec>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    // Octal prefix '0' is counted as a digit, so ignore it if precision\n    // is specified.\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size = prefix_size + spec.precision();\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}\n\ntemplate <typename Char>\ntemplate <typename T, typename Spec>\nvoid BasicWriter<Char>::write_int(T value, Spec spec) {\n  unsigned prefix_size = 0;\n  typedef typename internal::IntTraits<T>::MainType UnsignedType;\n  UnsignedType abs_value = value;\n  char prefix[4] = \"\";\n  if (internal::is_negative(value)) {\n    prefix[0] = '-';\n    ++prefix_size;\n    abs_value = 0 - abs_value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';\n    ++prefix_size;\n  }\n  switch (spec.type()) {\n  case 0: case 'd': {\n    unsigned num_digits = internal::count_digits(abs_value);\n    CharPtr p = prepare_int_buffer(\n      num_digits, spec, prefix, prefix_size) + 1 - num_digits;\n    internal::format_decimal(get(p), abs_value, num_digits);\n    break;\n  }\n  case 'x': case 'X': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 4) != 0);\n    Char *p = get(prepare_int_buffer(\n      num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    const char *digits = spec.type() == 'x' ?\n        \"0123456789abcdef\" : \"0123456789ABCDEF\";\n    do {\n      *p-- = digits[n & 0xf];\n    } while ((n >>= 4) != 0);\n    break;\n  }\n  case 'b': case 'B': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 1) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = '0' + (n & 1);\n    } while ((n >>= 1) != 0);\n    break;\n  }\n  case 'o': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG))\n      prefix[prefix_size++] = '0';\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 3) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = '0' + (n & 7);\n    } while ((n >>= 3) != 0);\n    break;\n  }\n  default:\n    internal::report_unknown_type(\n      spec.type(), spec.flag(CHAR_FLAG) ? \"char\" : \"integer\");\n    break;\n  }\n}\n\ntemplate <typename Char>\ntemplate <typename T>\nvoid BasicWriter<Char>::write_double(\n    T value, const FormatSpec &spec) {\n  // Check type.\n  char type = spec.type();\n  bool upper = false;\n  switch (type) {\n  case 0:\n    type = 'g';\n    break;\n  case 'e': case 'f': case 'g': case 'a':\n    break;\n  case 'F':\n#ifdef _MSC_VER\n    // MSVC's printf doesn't support 'F'.\n    type = 'f';\n#endif\n    // Fall through.\n  case 'E': case 'G': case 'A':\n    upper = true;\n    break;\n  default:\n    internal::report_unknown_type(type, \"double\");\n    break;\n  }\n\n  char sign = 0;\n  // Use getsign instead of value < 0 because the latter is always\n  // false for NaN.\n  if (internal::getsign(static_cast<double>(value))) {\n    sign = '-';\n    value = -value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';\n  }\n\n  if (internal::isnotanumber(value)) {\n    // Format NaN ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t nan_size = 4;\n    const char *nan = upper ? \" NAN\" : \" nan\";\n    if (!sign) {\n      --nan_size;\n      ++nan;\n    }\n    CharPtr out = write_str(nan, nan_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  if (internal::isinfinity(value)) {\n    // Format infinity ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t inf_size = 4;\n    const char *inf = upper ? \" INF\" : \" inf\";\n    if (!sign) {\n      --inf_size;\n      ++inf;\n    }\n    CharPtr out = write_str(inf, inf_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  std::size_t offset = buffer_.size();\n  unsigned width = spec.width();\n  if (sign) {\n    buffer_.reserve(buffer_.size() + (std::max)(width, 1u));\n    if (width > 0)\n      --width;\n    ++offset;\n  }\n\n  // Build format string.\n  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg\n  Char format[MAX_FORMAT_SIZE];\n  Char *format_ptr = format;\n  *format_ptr++ = '%';\n  unsigned width_for_sprintf = width;\n  if (spec.flag(HASH_FLAG))\n    *format_ptr++ = '#';\n  if (spec.align() == ALIGN_CENTER) {\n    width_for_sprintf = 0;\n  } else {\n    if (spec.align() == ALIGN_LEFT)\n      *format_ptr++ = '-';\n    if (width != 0)\n      *format_ptr++ = '*';\n  }\n  if (spec.precision() >= 0) {\n    *format_ptr++ = '.';\n    *format_ptr++ = '*';\n  }\n\n  append_float_length(format_ptr, value);\n  *format_ptr++ = type;\n  *format_ptr = '\\0';\n\n  // Format using snprintf.\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  for (;;) {\n    std::size_t buffer_size = buffer_.capacity() - offset;\n#ifdef _MSC_VER\n    // MSVC's vsnprintf_s doesn't work with zero size, so reserve\n    // space for at least one extra character to make the size non-zero.\n    // Note that the buffer's capacity will increase by more than 1.\n    if (buffer_size == 0) {\n      buffer_.reserve(offset + 1);\n      buffer_size = buffer_.capacity() - offset;\n    }\n#endif\n    Char *start = &buffer_[offset];\n    int n = internal::CharTraits<Char>::format_float(\n        start, buffer_size, format, width_for_sprintf, spec.precision(), value);\n    if (n >= 0 && offset + n < buffer_.capacity()) {\n      if (sign) {\n        if ((spec.align() != ALIGN_RIGHT && spec.align() != ALIGN_DEFAULT) ||\n            *start != ' ') {\n          *(start - 1) = sign;\n          sign = 0;\n        } else {\n          *(start - 1) = fill;\n        }\n        ++n;\n      }\n      if (spec.align() == ALIGN_CENTER &&\n          spec.width() > static_cast<unsigned>(n)) {\n        width = spec.width();\n        CharPtr p = grow_buffer(width);\n        std::copy(p, p + n, p + (width - n) / 2);\n        fill_padding(p, spec.width(), n, fill);\n        return;\n      }\n      if (spec.fill() != ' ' || sign) {\n        while (*start == ' ')\n          *start++ = fill;\n        if (sign)\n          *(start - 1) = sign;\n      }\n      grow_buffer(n);\n      return;\n    }\n    // If n is negative we ask to increase the capacity by at least 1,\n    // but as std::vector, the buffer grows exponentially.\n    buffer_.reserve(n >= 0 ? offset + n + 1 : buffer_.capacity() + 1);\n  }\n}\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a character stream. The output is stored in a memory buffer that grows\n  dynamically.\n\n  You can use one of the following typedefs for common character types\n  and the standard allocator:\n\n  +---------------+-----------------------------------------------------+\n  | Type          | Definition                                          |\n  +===============+=====================================================+\n  | MemoryWriter  | BasicMemoryWriter<char, std::allocator<char>>       |\n  +---------------+-----------------------------------------------------+\n  | WMemoryWriter | BasicMemoryWriter<wchar_t, std::allocator<wchar_t>> |\n  +---------------+-----------------------------------------------------+\n\n  **Example**::\n\n     MemoryWriter out;\n     out << \"The answer is \" << 42 << \"\\n\";\n     out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n  This will write the following output to the ``out`` object:\n\n  .. code-block:: none\n\n     The answer is 42\n     (-3.140000, +3.140000)\n\n  The output can be converted to an ``std::string`` with ``out.str()`` or\n  accessed as a C string with ``out.c_str()``.\n  \\endrst\n */\ntemplate <typename Char, typename Allocator = std::allocator<Char> >\nclass BasicMemoryWriter : public BasicWriter<Char> {\n private:\n  internal::MemoryBuffer<Char, internal::INLINE_BUFFER_SIZE, Allocator> buffer_;\n\n public:\n  explicit BasicMemoryWriter(const Allocator& alloc = Allocator())\n    : BasicWriter<Char>(buffer_), buffer_(alloc) {}\n\n#if FMT_USE_RVALUE_REFERENCES\n  /**\n    \\rst\n    Constructs a :class:`fmt::BasicMemoryWriter` object moving the content\n    of the other object to it.\n    \\endrst\n   */\n  BasicMemoryWriter(BasicMemoryWriter &&other)\n    : BasicWriter<Char>(buffer_), buffer_(std::move(other.buffer_)) {\n  }\n\n  /**\n    \\rst\n    Moves the content of the other ``BasicMemoryWriter`` object to this one.\n    \\endrst\n   */\n  BasicMemoryWriter &operator=(BasicMemoryWriter &&other) {\n    buffer_ = std::move(other.buffer_);\n    return *this;\n  }\n#endif\n};\n\ntypedef BasicMemoryWriter<char> MemoryWriter;\ntypedef BasicMemoryWriter<wchar_t> WMemoryWriter;\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a fixed-size array. For writing into a dynamically growing buffer\n  use :class:`fmt::BasicMemoryWriter`.\n\n  Any write method will throw ``std::runtime_error`` if the output doesn't fit\n  into the array.\n\n  You can use one of the following typedefs for common character types:\n\n  +--------------+---------------------------+\n  | Type         | Definition                |\n  +==============+===========================+\n  | ArrayWriter  | BasicArrayWriter<char>    |\n  +--------------+---------------------------+\n  | WArrayWriter | BasicArrayWriter<wchar_t> |\n  +--------------+---------------------------+\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicArrayWriter : public BasicWriter<Char> {\n private:\n  internal::FixedBuffer<Char> buffer_;\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   given size.\n   \\endrst\n   */\n  BasicArrayWriter(Char *array, std::size_t size)\n    : BasicWriter<Char>(buffer_), buffer_(array, size) {}\n\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   size known at compile time.\n   \\endrst\n   */\n  template <std::size_t SIZE>\n  explicit BasicArrayWriter(Char (&array)[SIZE])\n    : BasicWriter<Char>(buffer_), buffer_(array, SIZE) {}\n};\n\ntypedef BasicArrayWriter<char> ArrayWriter;\ntypedef BasicArrayWriter<wchar_t> WArrayWriter;\n\n// Formats a value.\ntemplate <typename Char, typename T>\nvoid format(BasicFormatter<Char> &f, const Char *&format_str, const T &value) {\n  std::basic_ostringstream<Char> os;\n  os << value;\n  std::basic_string<Char> str = os.str();\n  internal::Arg arg = internal::MakeValue<Char>(str);\n  arg.type = static_cast<internal::Arg::Type>(\n        internal::MakeValue<Char>::type(str));\n  format_str = f.format(format_str, arg);\n}\n\n// Reports a system error without throwing an exception.\n// Can be used to report errors from destructors.\nvoid report_system_error(int error_code, StringRef message) FMT_NOEXCEPT;\n\n#if FMT_USE_WINDOWS_H\n\n/** A Windows error. */\nclass WindowsError : public SystemError {\n private:\n  void init(int error_code, CStringRef format_str, ArgList args);\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::WindowsError` object with the description\n   of the form\n\n   .. parsed-literal::\n     *<message>*: *<system-message>*\n\n   where *<message>* is the formatted message and *<system-message>* is the\n   system message corresponding to the error code.\n   *error_code* is a Windows error code as given by ``GetLastError``.\n   If *error_code* is not a valid error code such as -1, the system message\n   will look like \"error -1\".\n\n   **Example**::\n\n     // This throws a WindowsError with the description\n     //   cannot open file 'madeup': The system cannot find the file specified.\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     LPOFSTRUCT of = LPOFSTRUCT();\n     HFILE file = OpenFile(filename, &of, OF_READ);\n     if (file == HFILE_ERROR) {\n       throw fmt::WindowsError(GetLastError(),\n                               \"cannot open file '{}'\", filename);\n     }\n   \\endrst\n  */\n  WindowsError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_VARIADIC_CTOR(WindowsError, init, int, CStringRef)\n};\n\n// Reports a Windows error without throwing an exception.\n// Can be used to report errors from destructors.\nvoid report_windows_error(int error_code, StringRef message) FMT_NOEXCEPT;\n\n#endif\n\nenum Color { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE };\n\n/**\n  Formats a string and prints it to stdout using ANSI escape sequences\n  to specify color (experimental).\n  Example:\n    PrintColored(fmt::RED, \"Elapsed time: {0:.2f} seconds\") << 1.23;\n */\nvoid print_colored(Color c, CStringRef format, ArgList args);\n\n/**\n  \\rst\n  Formats arguments and returns the result as a string.\n\n  **Example**::\n\n    std::string message = format(\"The answer is {}\", 42);\n  \\endrst\n*/\ninline std::string format(CStringRef format_str, ArgList args) {\n  MemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\ninline std::wstring format(WCStringRef format_str, ArgList args) {\n  WMemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\n/**\n  \\rst\n  Prints formatted data to the file *f*.\n\n  **Example**::\n\n    print(stderr, \"Don't {}!\", \"panic\");\n  \\endrst\n */\nvoid print(std::FILE *f, CStringRef format_str, ArgList args);\n\n/**\n  \\rst\n  Prints formatted data to ``stdout``.\n\n  **Example**::\n\n    print(\"Elapsed time: {0:.2f} seconds\", 1.23);\n  \\endrst\n */\nvoid print(CStringRef format_str, ArgList args);\n\ntemplate <typename Char>\nvoid printf(BasicWriter<Char> &w, BasicCStringRef<Char> format, ArgList args) {\n  internal::PrintfFormatter<Char>(args).format(w, format);\n}\n\n/**\n  \\rst\n  Formats arguments and returns the result as a string.\n\n  **Example**::\n\n    std::string message = fmt::sprintf(\"The answer is %d\", 42);\n  \\endrst\n*/\ninline std::string sprintf(CStringRef format, ArgList args) {\n  MemoryWriter w;\n  printf(w, format, args);\n  return w.str();\n}\n\ninline std::wstring sprintf(WCStringRef format, ArgList args) {\n  WMemoryWriter w;\n  printf(w, format, args);\n  return w.str();\n}\n\n/**\n  \\rst\n  Prints formatted data to the file *f*.\n\n  **Example**::\n\n    fmt::fprintf(stderr, \"Don't %s!\", \"panic\");\n  \\endrst\n */\nint fprintf(std::FILE *f, CStringRef format, ArgList args);\n\n/**\n  \\rst\n  Prints formatted data to ``stdout``.\n\n  **Example**::\n\n    fmt::printf(\"Elapsed time: %.2f seconds\", 1.23);\n  \\endrst\n */\ninline int printf(CStringRef format, ArgList args) {\n  return fprintf(stdout, format, args);\n}\n\n/**\n  Fast integer formatter.\n */\nclass FormatInt {\n private:\n  // Buffer should be large enough to hold all digits (digits10 + 1),\n  // a sign and a null character.\n  enum {BUFFER_SIZE = std::numeric_limits<ULongLong>::digits10 + 3};\n  mutable char buffer_[BUFFER_SIZE];\n  char *str_;\n\n  // Formats value in reverse and returns the number of digits.\n  char *format_decimal(ULongLong value) {\n    char *buffer_end = buffer_ + BUFFER_SIZE - 1;\n    while (value >= 100) {\n      // Integer division is slow so do it for a group of two digits instead\n      // of for every digit. The idea comes from the talk by Alexandrescu\n      // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n      unsigned index = (value % 100) * 2;\n      value /= 100;\n      *--buffer_end = internal::Data::DIGITS[index + 1];\n      *--buffer_end = internal::Data::DIGITS[index];\n    }\n    if (value < 10) {\n      *--buffer_end = static_cast<char>('0' + value);\n      return buffer_end;\n    }\n    unsigned index = static_cast<unsigned>(value * 2);\n    *--buffer_end = internal::Data::DIGITS[index + 1];\n    *--buffer_end = internal::Data::DIGITS[index];\n    return buffer_end;\n  }\n\n  void FormatSigned(LongLong value) {\n    ULongLong abs_value = static_cast<ULongLong>(value);\n    bool negative = value < 0;\n    if (negative)\n      abs_value = 0 - abs_value;\n    str_ = format_decimal(abs_value);\n    if (negative)\n      *--str_ = '-';\n  }\n\n public:\n  explicit FormatInt(int value) { FormatSigned(value); }\n  explicit FormatInt(long value) { FormatSigned(value); }\n  explicit FormatInt(LongLong value) { FormatSigned(value); }\n  explicit FormatInt(unsigned value) : str_(format_decimal(value)) {}\n  explicit FormatInt(unsigned long value) : str_(format_decimal(value)) {}\n  explicit FormatInt(ULongLong value) : str_(format_decimal(value)) {}\n\n  /**\n    Returns the number of characters written to the output buffer.\n   */\n  std::size_t size() const { return buffer_ - str_ + BUFFER_SIZE - 1; }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const char *data() const { return str_; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const char *c_str() const {\n    buffer_[BUFFER_SIZE - 1] = '\\0';\n    return str_;\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an ``std::string``.\n    \\endrst\n   */\n  std::string str() const { return std::string(str_, size()); }\n};\n\n// Formats a decimal integer value writing into buffer and returns\n// a pointer to the end of the formatted string. This function doesn't\n// write a terminating null character.\ntemplate <typename T>\ninline void format_decimal(char *&buffer, T value) {\n  typename internal::IntTraits<T>::MainType abs_value = value;\n  if (internal::is_negative(value)) {\n    *buffer++ = '-';\n    abs_value = 0 - abs_value;\n  }\n  if (abs_value < 100) {\n    if (abs_value < 10) {\n      *buffer++ = static_cast<char>('0' + abs_value);\n      return;\n    }\n    unsigned index = static_cast<unsigned>(abs_value * 2);\n    *buffer++ = internal::Data::DIGITS[index];\n    *buffer++ = internal::Data::DIGITS[index + 1];\n    return;\n  }\n  unsigned num_digits = internal::count_digits(abs_value);\n  internal::format_decimal(buffer, abs_value, num_digits);\n  buffer += num_digits;\n}\n\n/**\n  \\rst\n  Returns a named argument for formatting functions.\n\n  **Example**::\n\n    print(\"Elapsed time: {s:.2f} seconds\", arg(\"s\", 1.23));\n\n  \\endrst\n */\ntemplate <typename T>\ninline internal::NamedArg<char> arg(StringRef name, const T &arg) {\n  return internal::NamedArg<char>(name, arg);\n}\n\ntemplate <typename T>\ninline internal::NamedArg<wchar_t> arg(WStringRef name, const T &arg) {\n  return internal::NamedArg<wchar_t>(name, arg);\n}\n\n// The following two functions are deleted intentionally to disable\n// nested named arguments as in ``format(\"{}\", arg(\"a\", arg(\"b\", 42)))``.\ntemplate <typename Char>\nvoid arg(StringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\ntemplate <typename Char>\nvoid arg(WStringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\n}\n\n#if FMT_GCC_VERSION\n// Use the system_header pragma to suppress warnings about variadic macros\n// because suppressing -Wvariadic-macros with the diagnostic pragma doesn't\n// work. It is used at the end because we want to suppress as little warnings\n// as possible.\n# pragma GCC system_header\n#endif\n\n// This is used to work around VC++ bugs in handling variadic macros.\n#define FMT_EXPAND(args) args\n\n// Returns the number of arguments.\n// Based on https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s.\n#define FMT_NARG(...) FMT_NARG_(__VA_ARGS__, FMT_RSEQ_N())\n#define FMT_NARG_(...) FMT_EXPAND(FMT_ARG_N(__VA_ARGS__))\n#define FMT_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define FMT_RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n#define FMT_CONCAT(a, b) a##b\n#define FMT_FOR_EACH_(N, f, ...) \\\n  FMT_EXPAND(FMT_CONCAT(FMT_FOR_EACH, N)(f, __VA_ARGS__))\n#define FMT_FOR_EACH(f, ...) \\\n  FMT_EXPAND(FMT_FOR_EACH_(FMT_NARG(__VA_ARGS__), f, __VA_ARGS__))\n\n#define FMT_ADD_ARG_NAME(type, index) type arg##index\n#define FMT_GET_ARG_NAME(type, index) arg##index\n\n#if FMT_USE_VARIADIC_TEMPLATES\n# define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \\\n  template <typename... Args> \\\n  ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      const Args & ... args) { \\\n    typename fmt::internal::ArgArray<sizeof...(Args)>::Type array; \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \\\n      fmt::internal::make_arg_list<Char>(array, args...)); \\\n  }\n#else\n// Defines a wrapper for a function taking __VA_ARGS__ arguments\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP(Char, ReturnType, func, call, n, ...) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    fmt::internal::ArgArray<n>::Type arr = {FMT_GEN(n, FMT_MAKE_REF_##Char)}; \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), arr)); \\\n  }\n\n# define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__)) { \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList()); \\\n  } \\\n  FMT_WRAP(Char, ReturnType, func, call, 1, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 2, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 3, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 4, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 5, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 6, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 7, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 8, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 9, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 10, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 11, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 12, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 13, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 14, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 15, __VA_ARGS__)\n#endif  // FMT_USE_VARIADIC_TEMPLATES\n\n/**\n  \\rst\n  Defines a variadic function with the specified return type, function name\n  and argument types passed as variable arguments to this macro.\n\n  **Example**::\n\n    void print_error(const char *file, int line, const char *format,\n                     fmt::ArgList args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args);\n    }\n    FMT_VARIADIC(void, print_error, const char *, int, const char *)\n\n  ``FMT_VARIADIC`` is used for compatibility with legacy C++ compilers that\n  don't implement variadic templates. You don't have to use this macro if\n  you don't need legacy compiler support and can use variadic templates\n  directly::\n\n    template <typename... Args>\n    void print_error(const char *file, int line, const char *format,\n                     const Args & ... args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args...);\n    }\n  \\endrst\n */\n#define FMT_VARIADIC(ReturnType, func, ...) \\\n  FMT_VARIADIC_(char, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_W(ReturnType, func, ...) \\\n  FMT_VARIADIC_(wchar_t, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_CAPTURE_ARG_(id, index) ::fmt::arg(#id, id)\n\n#define FMT_CAPTURE_ARG_W_(id, index) ::fmt::arg(L###id, id)\n\n/**\n  \\rst\n  Convenient macro to capture the arguments' names and values into several\n  ``fmt::arg(name, value)``.\n\n  **Example**::\n\n    int x = 1, y = 2;\n    print(\"point: ({x}, {y})\", FMT_CAPTURE(x, y));\n    // same as:\n    // print(\"point: ({x}, {y})\", arg(\"x\", x), arg(\"y\", y));\n\n  \\endrst\n */\n#define FMT_CAPTURE(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_, __VA_ARGS__)\n\n#define FMT_CAPTURE_W(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_W_, __VA_ARGS__)\n\nnamespace fmt {\nFMT_VARIADIC(std::string, format, CStringRef)\nFMT_VARIADIC_W(std::wstring, format, WCStringRef)\nFMT_VARIADIC(void, print, CStringRef)\nFMT_VARIADIC(void, print, std::FILE *, CStringRef)\n\nFMT_VARIADIC(void, print_colored, Color, CStringRef)\nFMT_VARIADIC(std::string, sprintf, CStringRef)\nFMT_VARIADIC_W(std::wstring, sprintf, WCStringRef)\nFMT_VARIADIC(int, printf, CStringRef)\nFMT_VARIADIC(int, fprintf, std::FILE *, CStringRef)\n\n#if FMT_USE_IOSTREAMS\n/**\n  \\rst\n  Prints formatted data to the stream *os*.\n\n  **Example**::\n\n    print(cerr, \"Don't {}!\", \"panic\");\n  \\endrst\n */\nvoid print(std::ostream &os, CStringRef format_str, ArgList args);\nFMT_VARIADIC(void, print, std::ostream &, CStringRef)\n#endif\n}  // namespace fmt\n\n#if FMT_USE_USER_DEFINED_LITERALS\nnamespace fmt {\nnamespace internal {\n\ntemplate <typename Char>\nstruct UdlFormat {\n  const Char *str;\n\n  template <typename... Args>\n  auto operator()(Args && ... args) const\n                  -> decltype(format(str, std::forward<Args>(args)...)) {\n    return format(str, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename Char>\nstruct UdlArg {\n  const Char *str;\n\n  template <typename T>\n  NamedArg<Char> operator=(T &&value) const {\n    return {str, std::forward<T>(value)};\n  }\n};\n\n} // namespace internal\n\ninline namespace literals {\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::format`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    std::string message = \"The answer is {}\"_format(42);\n  \\endrst\n */\ninline internal::UdlFormat<char>\noperator\"\" _format(const char *s, std::size_t) { return {s}; }\ninline internal::UdlFormat<wchar_t>\noperator\"\" _format(const wchar_t *s, std::size_t) { return {s}; }\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::arg`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    print(\"Elapsed time: {s:.2f} seconds\", \"s\"_a=1.23);\n  \\endrst\n */\ninline internal::UdlArg<char>\noperator\"\" _a(const char *s, std::size_t) { return {s}; }\ninline internal::UdlArg<wchar_t>\noperator\"\" _a(const wchar_t *s, std::size_t) { return {s}; }\n\n} // inline namespace literals\n} // namespace fmt\n#endif // FMT_USE_USER_DEFINED_LITERALS\n\n}  // namespace blackhole\n\n// Restore warnings.\n#if FMT_GCC_VERSION >= 406\n# pragma GCC diagnostic pop\n#endif\n\n#ifdef __clang__\n# pragma clang diagnostic pop\n#endif\n\n#ifdef FMT_HEADER_ONLY\n# include \"format.cc\"\n#endif\n\n#endif  // FMT_FORMAT_H_\n"
      },
      {
        "filename": "include/blackhole/extensions/writer.hpp",
        "code": "#pragma once\n\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/extensions/format.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\n/// Represents stream writer backed up by cppformat.\nclass writer_t {\npublic:\n    fmt::MemoryWriter inner;\n\n    /// Formats the given arguments using the underlying formatter.\n    template<typename... Args>\n    inline auto write(const Args&... args) -> void {\n        inner.write(args...);\n    }\n\n    auto result() const noexcept -> string_view {\n        return string_view(inner.data(), inner.size());\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/record.hpp",
        "code": "#pragma once\n\n#include <chrono>\n#include <cstdint>\n#include <thread>\n\n#include \"blackhole/attributes.hpp\"\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/severity.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\nclass record_t {\npublic:\n    typedef std::chrono::system_clock clock_type;\n    typedef clock_type::time_point time_point;\n\nprivate:\n    struct inner_t;\n\n    typedef std::aligned_storage<64>::type storage_type;\n    storage_type storage;\n\npublic:\n    /// Creates a log record with the given severity, possibly unformatted message and attributes.\n    ///\n    /// The created record contains almost all information about the logging event associated except\n    /// the timestamp and formatted message.\n    ///\n    /// These missing attributes are set right after filtering pass with `activate` method.\n    ///\n    /// \\warning constructing from rvalue references is explicitly forbidden, specified objects must\n    ///     outlive the record created.\n    record_t(severity_t severity,\n        std::reference_wrapper<const string_view> message,\n        std::reference_wrapper<const attribute_pack> attributes);\n\n    auto message() const noexcept -> const string_view&;\n    auto severity() const noexcept -> severity_t;\n    auto timestamp() const noexcept -> time_point;\n\n    auto pid() const noexcept -> std::uint64_t;\n    auto tid() const noexcept -> std::thread::native_handle_type;\n\n    auto formatted() const noexcept -> const string_view&;\n    auto attributes() const noexcept -> const attribute_pack&;\n\n    /// Activate the record by setting the given formatted message accompanied by obtaining and\n    /// setting the current time point.\n    auto activate(const string_view& formatted = string_view()) noexcept -> void;\n\nprivate:\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/attribute.hpp",
        "code": "#pragma once\n\n#include <boost/variant/variant.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nstruct value_t::inner_t {\n    typedef boost::make_variant_over<value_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\nstruct view_t::inner_t {\n    typedef boost::make_variant_over<view_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/formatter/string/parser.hpp",
        "code": "#pragma once\n\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n#include <boost/optional/optional.hpp>\n\n#include \"blackhole/detail/formatter/string/error.hpp\"\n#include \"blackhole/detail/formatter/string/token.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace detail {\nnamespace formatter {\nnamespace string {\n\nclass factory_t;\n\nclass parser_t {\npublic:\n    typedef char char_type;\n    typedef std::basic_string<char_type> string_type;\n\nprivate:\n    typedef string_type::const_iterator const_iterator;\n\n    enum class state_t {\n        /// Undetermined state.\n        unknown,\n        /// Parsing literal.\n        literal,\n        /// Parsing placeholder.\n        placeholder,\n        /// Parser is broken.\n        broken\n    };\n\n    state_t state;\n\n    const std::string pattern;\n    const_iterator pos;\n\n    std::unordered_map<std::string, std::shared_ptr<factory_t>> factories;\n\npublic:\n    explicit parser_t(std::string pattern);\n\n    auto next() -> boost::optional<token_t>;\n\nprivate:\n    auto parse_spec() -> std::string;\n    auto parse_unknown() -> boost::optional<token_t>;\n    auto parse_literal() -> literal_t;\n    auto parse_placeholder() -> token_t;\n\n    /// Returns `true` on exact match with the given range from the current position.\n    ///\n    /// The given range may be larger than `std::distance(pos, std::end(pattern))`.\n    template<typename Range>\n    auto exact(const Range& range) const -> bool;\n\n    /// Returns `true` on exact match with the given range and position.\n    ///\n    /// The given range may be larger than `std::distance(pos, std::end(pattern))`.\n    ///\n    /// \\overload\n    template<typename Range>\n    auto exact(const_iterator pos, const Range& range) const -> bool;\n\n    /// Marks the parser as broken and throws an exception\n    template<class Exception, class... Args>\n    __attribute__((noreturn)) auto throw_(Args&&... args) -> void;\n};\n\n}  // namespace string\n}  // namespace formatter\n}  // namespace detail\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/formatter/string/token.hpp",
        "code": "#pragma once\n\n#include <string>\n\n#include <boost/variant/variant_fwd.hpp>\n\n#include \"blackhole/detail/datetime.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace detail {\nnamespace formatter {\nnamespace string {\n\n/// Helper named structs for making eye-candy code.\nstruct id;\nstruct hex;\nstruct num;\nstruct name;\nstruct user;\nstruct required;\nstruct optional;\n\n/// Represents string literal.\nstruct literal_t {\n    std::string value;\n};\n\nnamespace placeholder {\n\ntemplate<typename T>\nstruct generic;\n\ntemplate<>\nstruct generic<required> {\n    std::string name;\n    std::string spec;\n\n    generic(std::string name);\n    generic(std::string name, std::string spec);\n};\n\ntemplate<>\nstruct generic<optional> : public generic<required> {\n    std::string prefix;\n    std::string suffix;\n\n    generic(std::string name);\n    generic(std::string name, std::string spec);\n    generic(generic<required> token, std::string prefix, std::string suffix);\n};\n\nstruct message_t {\n    std::string spec;\n\n    message_t();\n    message_t(std::string spec);\n};\n\ntemplate<typename T>\nstruct severity {\n    std::string spec;\n\n    severity();\n    severity(std::string spec);\n};\n\ntemplate<typename T>\nstruct timestamp;\n\ntemplate<>\nstruct timestamp<num> {\n    std::string spec;\n\n    timestamp();\n    timestamp(std::string spec);\n};\n\ntemplate<>\nstruct timestamp<user> {\n    std::string pattern;\n    std::string spec;\n    datetime::generator_t generator;\n\n    timestamp();\n    timestamp(std::string pattern, std::string spec);\n};\n\ntemplate<typename T>\nstruct process {\n    std::string spec;\n\n    process();\n    process(std::string spec);\n};\n\ntemplate<typename T>\nstruct thread {\n    std::string spec;\n\n    thread();\n    thread(std::string spec);\n};\n\ntemplate<>\nstruct thread<hex> {\n    std::string spec;\n\n    thread();\n    thread(std::string spec);\n};\n\nstruct leftover_t {\n    std::string name;\n\n    bool unique;\n    std::string prefix;\n    std::string suffix;\n    std::string pattern;\n    std::string separator;\n\n    leftover_t();\n    leftover_t(std::string name);\n    leftover_t(std::string name, bool unique, std::string prefix, std::string suffix,\n        std::string pattern, std::string separator);\n};\n\n}  // namespace placeholder\n\nnamespace ph = placeholder;\n\ntypedef boost::variant<\n    literal_t,\n    ph::generic<required>,\n    ph::generic<optional>,\n    ph::leftover_t,\n    ph::process<id>,\n    ph::process<name>,\n    ph::thread<id>,\n    ph::thread<hex>,\n    ph::thread<name>,\n    ph::message_t,\n    ph::severity<num>,\n    ph::severity<user>,\n    ph::timestamp<num>,\n    ph::timestamp<user>\n> token_t;\n\n}  // namespace string\n}  // namespace formatter\n}  // namespace detail\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/procname.hpp",
        "code": "#pragma once\n\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace cpp17 {\n\ntemplate<typename Char, typename Traits> class basic_string_view;\ntypedef basic_string_view<char, std::char_traits<char>> string_view;\n\n}  // namespace cpp17\n\nnamespace detail {\n\nauto procname() -> cpp17::string_view;\n\n}  // namespace detail\n}  // namespace v1\n}  // namespace blackhole\n"
      }
    ],
    "unresolved_context": []
  },
  "output": {
    "language": "C++",
    "fixed_commit_message": "refactor(formatter/string): new interface\n\nThis commit changes the interface (and ABI) of the string formatter to\nmake it possible to change the implementation or add functionality\nwithout further breaking.\n\nStrictly speaking this commit just applies pointer to implementation\nidiom.\n\nCloses #83, but it\u2019s not complete yet, just proof of concept.",
    "fixed_file": {
      "fixed_filename": "src/formatter/string.cpp",
      "fixed_code": "#include \"blackhole/formatter/string.hpp\"\n\n#include <array>\n\n#include <boost/variant/apply_visitor.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/variant/variant.hpp>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/extensions/format.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n#include \"blackhole/record.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n#include \"blackhole/detail/formatter/string/parser.hpp\"\n#include \"blackhole/detail/formatter/string/token.hpp\"\n#include \"blackhole/detail/procname.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\n\nnamespace string = blackhole::detail::formatter::string;\nnamespace ph = string::ph;\n\nusing string::id;\nusing string::hex;\nusing string::num;\nusing string::name;\nusing string::user;\nusing string::required;\nusing string::optional;\n\nusing string::literal_t;\n\nnamespace {\n\ntypedef fmt::StringRef string_ref;\n\n}  // namespace\n\nnamespace {\n\nstruct spec;\nstruct unspec;\n\ntemplate<typename Spec>\nclass view_visitor;\n\ntemplate<>\nclass view_visitor<spec> : public boost::static_visitor<> {\n    writer_t& writer;\n    const std::string& spec;\n\npublic:\n    view_visitor(writer_t& writer, const std::string& spec) noexcept :\n        writer(writer),\n        spec(spec)\n    {}\n\n    auto operator()(std::nullptr_t) const -> void {\n        writer.write(spec, \"none\");\n    }\n\n    template<typename T>\n    auto operator()(T value) const -> void {\n        writer.write(spec, value);\n    }\n\n    auto operator()(const string_view& value) const -> void {\n        writer.write(spec, value.data());\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) const -> void {\n        value(writer);\n    }\n};\n\ntemplate<>\nclass view_visitor<unspec> : public boost::static_visitor<> {\n    writer_t& writer;\n\npublic:\n    view_visitor(writer_t& writer) noexcept :\n        writer(writer)\n    {}\n\n    auto operator()(std::nullptr_t) const -> void {\n        writer.inner << \"none\";\n    }\n\n    template<typename T>\n    auto operator()(T value) const -> void {\n        writer.inner << value;\n    }\n\n    auto operator()(const string_view& value) const -> void {\n        writer.inner << string_ref(value.data(), value.size());\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) const -> void {\n        value(writer);\n    }\n};\n\nclass visitor_t : public boost::static_visitor<> {\n    writer_t& writer;\n    const record_t& record;\n    const severity_map& sevmap;\n\npublic:\n    visitor_t(writer_t& writer, const record_t& record, const severity_map& sevmap) noexcept :\n        writer(writer),\n        record(record),\n        sevmap(sevmap)\n    {}\n\n    auto operator()(const literal_t& token) const -> void {\n        writer.inner << token.value;\n    }\n\n    auto operator()(const ph::message_t& token) const -> void {\n        const auto& value = record.formatted();\n        writer.write(token.spec, string_ref(value.data(), value.size()));\n    }\n\n    auto operator()(const ph::process<id>& token) const -> void {\n        writer.write(token.spec, record.pid());\n    }\n\n    auto operator()(const ph::process<name>& token) const -> void {\n        writer.write(token.spec, detail::procname().data());\n    }\n\n    auto operator()(const ph::thread<id>& token) const -> void {\n        throw std::runtime_error(\"{thread:d} placeholder is not implemented yet\");\n    }\n\n    auto operator()(const ph::thread<hex>& token) const -> void {\n#ifdef __linux__\n        writer.write(token.spec, record.tid());\n#elif __APPLE__\n        writer.write(token.spec, reinterpret_cast<unsigned long>(record.tid()));\n#endif\n    }\n\n    auto operator()(const ph::thread<name>& token) const -> void {\n        std::array<char, 16> buffer;\n        const auto rc = ::pthread_getname_np(record.tid(), buffer.data(), buffer.size());\n\n        if (rc == 0) {\n            writer.write(token.spec, buffer.data());\n        } else {\n            writer.write(token.spec, \"<unnamed>\");\n        }\n    }\n\n    auto operator()(const ph::severity<num>& token) const -> void {\n        writer.write(token.spec, record.severity());\n    }\n\n    auto operator()(const ph::severity<user>& token) const -> void {\n        sevmap(record.severity(), token.spec, writer);\n    }\n\n    auto operator()(const ph::timestamp<num>& token) const -> void {\n        const auto timestamp = record.timestamp();\n        const auto usec = std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(timestamp.time_since_epoch()).count();\n\n        writer.write(token.spec, usec);\n    }\n\n    auto operator()(const ph::timestamp<user>& token) const -> void {\n        const auto timestamp = record.timestamp();\n        const auto time = record_t::clock_type::to_time_t(timestamp);\n        const auto usec = std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(timestamp.time_since_epoch()).count() % 1000000;\n\n        std::tm tm;\n        ::gmtime_r(&time, &tm);\n\n        fmt::MemoryWriter buffer;\n        token.generator(buffer, tm, static_cast<std::uint64_t>(usec));\n        writer.write(token.spec, string_ref(buffer.data(), buffer.size()));\n    }\n\n    auto operator()(const ph::generic<required>& token) const -> void {\n        if (auto value = find(token.name)) {\n            return boost::apply_visitor(view_visitor<spec>(writer, token.spec), value->inner().value);\n        }\n\n        throw std::logic_error(\"required attribute '\" + token.name + \"' not found\");\n    }\n\n    auto operator()(const ph::generic<optional>& token) const -> void {\n        if (auto value = find(token.name)) {\n            writer.write(token.prefix);\n            boost::apply_visitor(view_visitor<spec>(writer, token.spec), value->inner().value);\n            writer.write(token.suffix);\n        }\n    }\n\n    auto operator()(const ph::leftover_t& token) const -> void {\n        bool first = true;\n        writer_t kv;\n        const view_visitor<unspec> visitor(kv);\n\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                if (first) {\n                    first = false;\n                    writer.inner << token.prefix;\n                } else {\n                    writer.inner << token.separator;\n                }\n\n                // TODO: To correctly implement kv patterns we need a visitor with parameters. Or\n                // attribute (pair) type, instead of that `std::pair`.\n                kv.inner << string_ref(attribute.first.data(), attribute.first.size()) << \": \";\n                boost::apply_visitor(visitor, attribute.second.inner().value);\n\n                const auto view = kv.result();\n                writer.inner << string_ref(view.data(), view.size());\n\n                kv.inner.clear();\n            }\n        }\n\n        if (!first) {\n            writer.inner << token.suffix;\n        }\n    }\n\nprivate:\n    auto find(const std::string& name) const -> boost::optional<attribute::view_t> {\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                if (attribute.first == name) {\n                    return attribute.second;\n                }\n            }\n        }\n\n        return boost::none;\n    }\n};\n\nauto tokenize(const std::string& pattern) -> std::vector<string::token_t> {\n    std::vector<string::token_t> tokens;\n    //\n    // for (const auto& reserved : {\"process\", \"thread\", \"message\", \"severity\", \"timestamp\"}) {\n    //     if (options.count(reserved) != 0) {\n    //         throw std::logic_error(\"placeholder '\" + std::string(reserved) +\n    //             \"' is reserved and can not be configured\");\n    //     }\n    // }\n\n    string::parser_t parser(pattern);\n    while (auto token = parser.next()) {\n        tokens.emplace_back(token.get());\n    }\n\n    return tokens;\n}\n\n}  // namespace\n\nclass string_t::inner_t {\npublic:\n    severity_map sevmap;\n    std::vector<string::token_t> tokens;\n};\n\nstring_t::string_t(const std::string& pattern) :\n    inner(new inner_t, [](inner_t* d) { delete d; })\n{\n    inner->sevmap = [](int severity, const std::string& spec, writer_t& writer) {\n        writer.write(spec, severity);\n    };\n\n    inner->tokens = tokenize(pattern);\n}\n\nstring_t::string_t(const std::string& pattern, severity_map sevmap) :\n    inner(new inner_t, [](inner_t* d) { delete d; })\n{\n    inner->sevmap = std::move(sevmap);\n    inner->tokens = tokenize(pattern);\n}\n\nstruct option_visitor {\n    typedef boost::optional<string::token_t> result_type;\n\n    const std::string& name;\n    std::string& prefix;\n    std::string& suffix;\n\n    auto operator()(const ph::generic<required>& token) const -> boost::optional<string::token_t> {\n        if (token.name == name) {\n            return boost::optional<string::token_t>(\n                ph::generic<optional>(token, std::move(prefix), std::move(suffix)));\n        }\n\n        return boost::none;\n    }\n\n    auto operator()(const ph::generic<optional>& token) const -> boost::optional<string::token_t> {\n        if (token.name == name) {\n            ph::generic<optional> result(token);\n            result.prefix = std::move(prefix);\n            result.suffix = std::move(suffix);\n            return boost::optional<string::token_t>(result);\n        }\n\n        return boost::none;\n    }\n\n    template<typename T>\n    auto operator()(const T& token) const -> boost::optional<string::token_t> {\n        return boost::none;\n    }\n};\n\nstruct leftover_visitor {\n    typedef boost::optional<string::token_t> result_type;\n\n    const std::string& name;\n    std::string& prefix;\n    std::string& suffix;\n    std::string& pattern;\n    std::string& separator;\n    bool unique;\n\n    auto operator()(const ph::leftover_t& token) const -> boost::optional<string::token_t> {\n        if (token.name == name) {\n            return boost::optional<string::token_t>(\n                ph::leftover_t(token.name, unique, prefix, suffix, pattern, separator));\n        }\n\n        return boost::none;\n    }\n\n\n    template<typename T>\n    auto operator()(const T& token) const -> boost::optional<string::token_t> {\n        return boost::none;\n    }\n};\n\n// TODO: Decompose `throw std::invalid_argument(\"token not found\");` case.\n// TODO: Check and decompose name is not reserved. Maybe by wrapping `name` with type. Test.\n// TODO: Both algorithms are similar. Decompose.\nauto string_t::optional(const std::string& name, std::string prefix, std::string suffix) -> void {\n\n    const option_visitor visitor{name, prefix, suffix};\n\n    for (auto& token : inner->tokens) {\n        if (auto value = boost::apply_visitor(visitor, token)) {\n            token = value.get();\n            return;\n        }\n    }\n\n    throw std::invalid_argument(\"token not found\");\n}\n\nauto string_t::leftover(const std::string& name, std::string prefix, std::string suffix,\n    std::string pattern, std::string separator, bool unique) -> void\n{\n    const leftover_visitor visitor{name, prefix, suffix, pattern, separator, unique};\n\n    for (auto& token : inner->tokens) {\n        if (auto value = boost::apply_visitor(visitor, token)) {\n            token = value.get();\n            return;\n        }\n    }\n\n    throw std::invalid_argument(\"token not found\");\n}\n\nauto string_t::format(const record_t& record, writer_t& writer) -> void {\n    const visitor_t visitor(writer, record, inner->sevmap);\n\n    for (const auto& token : inner->tokens) {\n        boost::apply_visitor(visitor, token);\n    }\n}\n\n}  // namespace formatter\n\nauto factory<formatter::string_t>::type() -> const char* {\n    return \"string\";\n}\n\nauto factory<formatter::string_t>::from(const config::node_t& config) -> formatter::string_t {\n    auto pattern = config[\"pattern\"].to_string().get();\n\n    if (auto mapping = config[\"sevmap\"]) {\n        std::vector<std::string> sevmap;\n        mapping.each([&](const config::node_t& config) {\n            sevmap.emplace_back(config.to_string());\n        });\n\n        auto fn = [=](std::size_t severity, const std::string& spec, writer_t& writer) {\n            if (severity < sevmap.size()) {\n                writer.write(spec, sevmap[severity]);\n            } else {\n                writer.write(spec, severity);\n            }\n        };\n\n        return formatter::string_t(std::move(pattern));\n    }\n\n    return formatter::string_t(std::move(pattern));\n}\n\n}  // namespace v1\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "include/blackhole/formatter/string.hpp",
        "code": "#pragma once\n\n#include <functional>\n#include <memory>\n#include <string>\n\n#include \"blackhole/formatter.hpp\"\n#include \"blackhole/severity.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nclass record_t;\nclass writer_t;\n\ntemplate<typename>\nstruct factory;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\n\n/// Severity mapping function.\n///\n/// Default value just writes an integer representation.\n///\n/// \\param severity an integer representation of current log severity.\n/// \\param spec the format specification as it was provided with the initial pattern.\n/// \\param writer result writer.\ntypedef std::function<void(int severity, const std::string& spec, writer_t& writer)> severity_map;\n\n/// The string formatter is responsible for effective converting the given record to a string using\n/// precompiled pattern and options.\n///\n/// This formatter allows to specify the pattern using python-like syntax with braces and attribute\n/// names.\n///\n/// For example, the given pattern `{severity:d}, [{timestamp}]: {message}` would result in\n/// something like this: `1, [2015-11-18 15:50:12.630953]: HTTP1.1 - 200 OK`.\n///\n/// Let's explain what's going on when a log record passed such pattern.\n///\n/// There are three named arguments or attributes: severity, timestamp and message. The severity\n/// is represented as signed integer, because of `:d` format specifier. Other tho arguments haven't\n/// such specifiers, so they are represented using default types for each attribute. In our case\n/// the timestamp and message attributes are formatted as strings.\n///\n/// Considering message argument almost everything is clear, but for timestamp there are internal\n/// magic comes. There is default `%Y-%m-%d %H:%M:%S.%f` pattern for timestamp attributes which\n/// reuses `strftime` standard placeholders with an extension of microseconds - `%f`. It means\n/// that the given timestamp is formatted with 4-digit decimal year, 1-12 decimal month and so on.\n///\n/// See \\ref http://en.cppreference.com/w/cpp/chrono/c/strftime for more details.\n///\n/// The formatter uses python-like syntax with all its features, like aligning, floating point\n/// precision etc.\n///\n/// For example the `{re:+.3f}; {im:+.6f}` pattern is valid and results in `+3.140; -3.140000`\n/// message with `re: 3.14` and `im: -3.14` attributes provided.\n///\n/// For more information see \\ref http://cppformat.github.io/latest/syntax.html resource.\n///\n/// With a few predefined exceptions the formatter supports all userspace attributes. The exceptions\n/// are: message, severity, timestamp, process and thread. For these attributes there are special\n/// rules and it's impossible to override then even with the same name attribute.\n///\n/// For message attribute there are no special rules. It's still allowed to extend the specification\n/// using fill, align and other specifiers.\n///\n/// With timestamp attribute there is an extension of either explicitly providing formatting pattern\n/// or forcing the attibute to be printed as an integer.\n/// In the first case for example the pattern may be declared as `{timestamp:{%Y}s}` which results\n/// in only year formattinh using YYYY style.\n/// In the second case one can force the timestamp to be printed as microseconds passed since epoch.\n///\n/// Severity attribute can be formatted either as an integer or using the provided callback with the\n/// following signature: `auto(int, writer_t&) -> void` where the first argument means an actual\n/// severity level, the second one - streamed writer.\n///\n/// Process attribute can be represented as either an PID or process name using `:d` and `:s` types\n/// respectively: `{process:s}` and `{process:d}`.\n///\n/// At last the thread attribute can be formatted as either thread id in platform-independent hex\n/// representation by default or explicitly with `:x` type, thread id in platform-dependent way\n/// using `:d` type or as a thread name if specified, nil otherwise.\n///\n/// The formatter will throw an exception if an attribute name specified in pattern won't be found\n/// in the log record. Of course Blackhole catches this, but it results in dropping the entire\n/// message.\n/// To avoid this the formatter supports optional generic attributes, which can be specified using\n/// the `optional_t` option with an optional prefix and suffix literals printed if an attribute\n/// exists.\n/// For example an `{id}` pattern with the `[` prefix and `]` suffix options results in empty\n/// message if there is no `source` attribute in the record, `[42]` otherwise (where id = 42).\n///\n/// Blackhole also supports the leftover placeholder starting with `...` and meaning to print all\n/// userspace attributes in a reverse order they were provided.\n///\n/// # Performance\n///\n/// Internally the given pattern is compiled into the list of tokens during construction time. All\n/// further operations are performed using that list to achieve maximum performance.\n///\n/// All visited tokens are written directly into the given writer instance with an internal small\n/// stack-allocated buffer, growing using the heap on overflow.\nclass string_t : public formatter_t {\n    class inner_t;\n    std::unique_ptr<inner_t, auto(*)(inner_t*) -> void> inner;\n\npublic:\n    explicit string_t(const std::string& pattern);\n    string_t(const std::string& pattern, severity_map sevmap);\n\n    /// Configuration.\n\n    auto optional(const std::string& name, std::string prefix, std::string suffix) -> void;\n    auto leftover(const std::string& name, std::string prefix, std::string suffix,\n        std::string pattern, std::string separator, bool unique) -> void;\n\n    /// Formatting.\n\n    auto format(const record_t& record, writer_t& writer) -> void;\n};\n\n}  // namespace formatter\n\ntemplate<>\nstruct factory<formatter::string_t> {\n    static auto type() -> const char*;\n    static auto from(const config::node_t& config) -> formatter::string_t;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/attribute.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n#include <type_traits>\n\n#include <boost/mpl/contains.hpp>\n#include <boost/mpl/vector.hpp>\n\n#include \"blackhole/cpp17/string_view.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\n/// Trait that describes how to format user defined types provided as attributes.\ntemplate<typename T>\nstruct display_traits;\n\n/// Represents a trait for mapping an owned types to their associated lightweight view types.\n///\n/// By default all types are transparently mapped to itself, but Blackhole provides some\n/// specializations.\n///\n/// \\warning it is undefined behavior to add specializations for this trait.\ntemplate<typename T>\nstruct view_of {\n    typedef T type;\n};\n\n/// Forward.\nclass writer_t;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nclass value_t;\nclass view_t;\n\n/// Represents an attribute value holder.\n///\n/// Attribute value is an algebraic data type that can be initialized with one of the following\n/// predefined primitive types:\n///     - none marker;\n///     - boolean type (true or false);\n///     - signed integer types up to 64-bit size;\n///     - unsigned integer types up to 64-bit size;\n///     - floating point type;\n///     - owned string type;\n///     - and a function type, which can fill the specified writer with the value lazily.\n///\n/// The underlying value can be obtained through `blackhole::attribute::get` function with providing\n/// the desired result type. For example:\n///     blackhole::attribute::value_t value(42);\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(42 == actual);\n///\n/// As an alternative a visitor pattern is provided for enabling underlying value visitation. To\n/// enable this feature, implement the `value_t::visitor_t` interface and provide an instance of\n/// this implementation to the `apply` method.\nclass value_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef std::string    string_type;\n    typedef std::function<auto(writer_t& writer) -> void> function_type;\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<sizeof(function_type) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value containing tagged nullptr value.\n    value_t();\n\n    value_t(std::nullptr_t);\n\n    /// Constructs a value initialized with the given boolean value.\n    value_t(bool value);\n\n    /// Constructs a value initialized with the given signed integer.\n    value_t(char value);\n    value_t(short value);\n    value_t(int value);\n    value_t(long value);\n    value_t(long long value);\n\n    /// Constructs a value initialized with the given unsigned integer.\n    value_t(unsigned char value);\n    value_t(unsigned short value);\n    value_t(unsigned int value);\n    value_t(unsigned long value);\n    value_t(unsigned long long value);\n\n    value_t(double value);\n\n    /// Constructs a value from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    value_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    value_t(std::string value);\n\n    ~value_t();\n\n    value_t(const value_t& other);\n    value_t(value_t&& other);\n\n    auto operator=(const value_t& other) -> value_t&;\n    auto operator=(value_t&& other) -> value_t&;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n};\n\n/// Represents an attribute value holder view, containing only lightweight views of the actual\n/// values.\n///\n/// If an owned value is small enough to keep its copy - this class does it, otherwise keeping only\n/// view proxy values. For example for `std::string` values there is a lightweight mapping that\n/// holds only two members: a pointer to constant char and a size.\n///\n/// The underlying value can also be obtained through `blackhole::attribute::get` function with\n/// providing the desired result type. For example:\n///     blackhole::attribute::view_t value(\"le vinegret\");\n///     const auto actual = blackhole::attribute::get<std::int64_t>(value);\n///\n///     assert(\"le vinegret\" == actual);\n///\nclass view_t {\npublic:\n    /// Available types.\n    typedef std::nullptr_t null_type;\n    typedef bool           bool_type;\n    typedef std::int64_t   sint64_type;\n    typedef std::uint64_t  uint64_type;\n    typedef double         double_type;\n    typedef string_view    string_type;\n\n    struct function_type {\n        const void* value;\n        std::reference_wrapper<auto(const void* value, writer_t& writer) -> void> fn;\n\n        auto operator()(writer_t& wr) const -> void {\n            fn(value, wr);\n        }\n\n        auto operator==(const function_type& other) const noexcept -> bool {\n            return value == other.value && fn.get() == other.fn.get();\n        }\n    };\n\n    /// The type sequence of all available types.\n    typedef boost::mpl::vector<\n        null_type,\n        bool_type,\n        sint64_type,\n        uint64_type,\n        double_type,\n        string_type,\n        function_type\n    > types;\n\n    /// Visitor interface.\n    class visitor_t {\n    public:\n        virtual ~visitor_t() = 0;\n        virtual auto operator()(const null_type&) -> void = 0;\n        virtual auto operator()(const bool_type&) -> void = 0;\n        virtual auto operator()(const sint64_type&) -> void = 0;\n        virtual auto operator()(const uint64_type&) -> void = 0;\n        virtual auto operator()(const double_type&) -> void = 0;\n        virtual auto operator()(const string_type&) -> void = 0;\n        virtual auto operator()(const function_type&) -> void = 0;\n    };\n\n    struct inner_t;\n\nprivate:\n    typedef std::aligned_storage<2 * sizeof(void*) + sizeof(int)>::type storage_type;\n\n    /// The underlying type.\n    storage_type storage;\n\npublic:\n    /// Constructs a null value view containing tagged nullptr value.\n    view_t();\n\n    view_t(std::nullptr_t);\n\n    /// Constructs a value view initialized with the given boolean value.\n    view_t(bool value);\n\n    /// Constructs a value view initialized with the given signed integer.\n    view_t(char value);\n    view_t(short value);\n    view_t(int value);\n    view_t(long value);\n    view_t(long long value);\n\n    /// Constructs a value view initialized with the given unsigned integer.\n    view_t(unsigned char value);\n    view_t(unsigned short value);\n    view_t(unsigned int value);\n    view_t(unsigned long value);\n    view_t(unsigned long long value);\n\n    /// Constructs a value view from the given floating point value.\n    view_t(float value);\n    view_t(double value);\n\n    /// Constructs a value view from the given string literal not including the terminating null\n    /// character.\n    ///\n    /// \\note this overload is required to prevent implicit conversion literal values to bool.\n    template<std::size_t N>\n    view_t(const char(&value)[N]) { construct(string_type{value, N - 1}); }\n\n    /// Constructs a value view from the given string view.\n    view_t(const string_type& value);\n\n    /// Constructs a value view from the given string.\n    view_t(const std::string& value);\n\n    /// Constructs a value view from the given owned attribute value.\n    view_t(const value_t& value);\n\n    /// Constructs a value view from a custom type that implements `display_traits` trait.\n    ///\n    /// \\sa display_traits for more information.\n    template<typename T>\n    view_t(const T& value, decltype(&display_traits<T>::apply)* = nullptr) {\n        construct(function_type{static_cast<const void*>(&value), std::ref(display<T>)});\n    }\n\n    view_t(const view_t& other) = default;\n    view_t(view_t&& other) = default;\n\n    ~view_t() = default;\n\n    auto operator=(const view_t& other) -> view_t& = default;\n    auto operator=(view_t&& other) -> view_t& = default;\n\n    /// Applies the given visitor to perform pattern matching.\n    auto apply(const visitor_t& visitor) const -> void;\n\n    auto operator==(const view_t& other) const -> bool;\n    auto operator!=(const view_t& other) const -> bool;\n\n    /// Returns the internal underlying value.\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n\nprivate:\n    template<typename T>\n    auto construct(T&& value) -> void;\n\n    template<typename T>\n    static auto display(const void* value, writer_t& wr) -> void {\n        display_traits<T>::apply(*static_cast<const T*>(value), wr);\n    }\n};\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const value_t& value) ->\n    typename std::enable_if<boost::mpl::contains<value_t::types, T>::value, const T&>::type;\n\n/// Retrieves a value of a specified, but yet restricted type, from a given attribute value view.\n///\n/// \\throws std::bad_cast if the content is not of the specified type T.\ntemplate<typename T>\nauto get(const view_t& value) ->\n    typename std::enable_if<boost::mpl::contains<view_t::types, T>::value, const T&>::type;\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/node.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\ntemplate<typename T>\nclass option;\n\n/// Represents the configuration tree node.\n///\n/// Blackhole operates with instances of this class while configuring the logging system from some\n/// generic source, from file for example. It assumes that the whole configuration can be described\n/// using tree data structure, like JSON, XML or YAML.\n/// To be able to initialize from your own data format you must create subclass and implement its\n/// converting methods as like as tree traversing using subscription operators.\nclass node_t {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\npublic:\n    virtual ~node_t() = 0;\n\n    /// Tries to convert the underlying object to bool.\n    virtual auto to_bool() const -> bool = 0;\n\n    /// Tries to convert the underlying object to signed integer.\n    virtual auto to_sint64() const -> std::int64_t = 0;\n\n    /// Tries to convert the underlying object to unsigned integer.\n    virtual auto to_uint64() const -> std::uint64_t = 0;\n\n    /// Tries to convert the underlying object to double.\n    virtual auto to_double() const -> double = 0;\n\n    /// Tries to convert the underlying object to string.\n    virtual auto to_string() const -> std::string = 0;\n\n    /// Assuming that the underlying object is an array, performs inner iteration over it by\n    /// applying the given function to each element.\n    ///\n    /// Should do nothing either if there is no underlying array or it is empty.\n    virtual auto each(const each_function& fn) -> void = 0;\n\n    /// Assuming that the underlying object is a map, performs inner iteration over it by applying\n    /// the given function to each key-value element.\n    ///\n    /// Should do nothing either if there is no underlying map or it is empty.\n    virtual auto each_map(const member_function& fn) -> void = 0;\n\n    /// Assuming that the underlying object is an array performs index operation returning the\n    /// option object with some node at the given index on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::size_t& idx) const -> option<node_t> = 0;\n\n    /// Assuming that the underlying object is a map performs tree traversing operation returning\n    /// option object with some node at the given key on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::string& key) const -> option<node_t> = 0;\n};\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/option.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include <boost/optional/optional_fwd.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\ntemplate<typename T>\nclass option;\n\ntemplate<>\nclass option<node_t> {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\nprivate:\n    std::unique_ptr<node_t> node;\n\npublic:\n    /// Constructs an option object that will contan nothing.\n    option() noexcept;\n\n    /// Constructs an option object that will contain the specified configuration node.\n    explicit option(std::unique_ptr<node_t> node) noexcept;\n\n    explicit operator bool() const noexcept;\n\n    /// Unwraps an option, yielding the content of an underlying config node object.\n    auto unwrap() const -> boost::optional<const node_t&>;\n\n    auto to_bool() const -> boost::optional<bool>;\n    auto to_sint64() const -> boost::optional<std::int64_t>;\n    auto to_uint64() const -> boost::optional<std::uint64_t>;\n    auto to_double() const -> boost::optional<double>;\n    auto to_string() const -> boost::optional<std::string>;\n\n    auto each(const each_function& fn) -> void;\n    auto each_map(const member_function& fn) -> void;\n\n    auto operator[](const std::size_t& idx) const -> option<node_t>;\n    auto operator[](const std::string& key) const -> option<node_t>;\n\nprivate:\n    template<typename F>\n    auto to(F&& fn) const -> decltype(fn());\n};\n\n/// Constructs an option of the specified configuration node type using given arguments.\ntemplate<typename T, typename... Args>\nauto make_option(Args&&... args) -> option<node_t> {\n    return option<node_t>(std::unique_ptr<T>(new T(std::forward<Args>(args)...)));\n}\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/extensions/format.hpp",
        "code": "/*\n Formatting library for C++\n\n Copyright (c) 2012 - 2015, Victor Zverovich\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FMT_FORMAT_H_\n#define FMT_FORMAT_H_\n\n#include <stdint.h>\n\n#include <cassert>\n#include <cmath>\n#include <cstddef>  // for std::ptrdiff_t\n#include <cstdio>\n#include <algorithm>\n#include <limits>\n#include <stdexcept>\n#include <string>\n#include <map>\n\n#ifndef FMT_USE_IOSTREAMS\n# define FMT_USE_IOSTREAMS 1\n#endif\n\n#if FMT_USE_IOSTREAMS\n# include <sstream>\n#endif\n\n#ifdef _SECURE_SCL\n# define FMT_SECURE_SCL _SECURE_SCL\n#else\n# define FMT_SECURE_SCL 0\n#endif\n\n#if FMT_SECURE_SCL\n# include <iterator>\n#endif\n\n#ifdef _MSC_VER\n# include <intrin.h>  // _BitScanReverse, _BitScanReverse64\n\nnamespace fmt {\nnamespace internal {\n# pragma intrinsic(_BitScanReverse)\ninline uint32_t clz(uint32_t x) {\n  unsigned long r = 0;\n  _BitScanReverse(&r, x);\n  return 31 - r;\n}\n# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)\n\n# ifdef _WIN64\n#  pragma intrinsic(_BitScanReverse64)\n# endif\n\ninline uint32_t clzll(uint64_t x) {\n  unsigned long r = 0;\n# ifdef _WIN64\n  _BitScanReverse64(&r, x);\n# else\n  // Scan the high 32 bits.\n  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))\n    return 63 - (r + 32);\n\n  // Scan the low 32 bits.\n  _BitScanReverse(&r, static_cast<uint32_t>(x));\n# endif\n  return 63 - r;\n}\n# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)\n}\n}\n#endif\n\n#ifdef __GNUC__\n# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)\n# define FMT_GCC_EXTENSION __extension__\n# if FMT_GCC_VERSION >= 406\n#  pragma GCC diagnostic push\n// Disable the warning about \"long long\" which is sometimes reported even\n// when using __extension__.\n#  pragma GCC diagnostic ignored \"-Wlong-long\"\n// Disable the warning about declaration shadowing because it affects too\n// many valid cases.\n#  pragma GCC diagnostic ignored \"-Wshadow\"\n# endif\n# if __cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__\n#  define FMT_HAS_GXX_CXX11 1\n# endif\n#else\n# define FMT_GCC_EXTENSION\n#endif\n\n#ifdef __clang__\n# pragma clang diagnostic push\n# pragma clang diagnostic ignored \"-Wdocumentation\"\n# pragma clang diagnostic ignored \"-Wdocumentation-unknown-command\"\n# pragma clang diagnostic ignored \"-Wswitch-enum\"\n# pragma clang diagnostic ignored \"-Wsign-conversion\"\n# pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n# pragma clang diagnostic ignored \"-Wmissing-noreturn\"\n# pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\n# pragma clang diagnostic ignored \"-Wunused-member-function\"\n#endif\n\n#ifdef __GNUC_LIBSTD__\n# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)\n#endif\n\n#ifdef __has_feature\n# define FMT_HAS_FEATURE(x) __has_feature(x)\n#else\n# define FMT_HAS_FEATURE(x) 0\n#endif\n\n#ifdef __has_builtin\n# define FMT_HAS_BUILTIN(x) __has_builtin(x)\n#else\n# define FMT_HAS_BUILTIN(x) 0\n#endif\n\n#ifdef __has_cpp_attribute\n# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n#else\n# define FMT_HAS_CPP_ATTRIBUTE(x) 0\n#endif\n\n#ifndef FMT_USE_VARIADIC_TEMPLATES\n// Variadic templates are available in GCC since version 4.4\n// (http://gcc.gnu.org/projects/cxx0x.html) and in Visual C++\n// since version 2013.\n# define FMT_USE_VARIADIC_TEMPLATES \\\n   (FMT_HAS_FEATURE(cxx_variadic_templates) || \\\n       (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1800)\n#endif\n\n#ifndef FMT_USE_RVALUE_REFERENCES\n// Don't use rvalue references when compiling with clang and an old libstdc++\n// as the latter doesn't provide std::move.\n# if defined(FMT_GNUC_LIBSTD_VERSION) && FMT_GNUC_LIBSTD_VERSION <= 402\n#  define FMT_USE_RVALUE_REFERENCES 0\n# else\n#  define FMT_USE_RVALUE_REFERENCES \\\n    (FMT_HAS_FEATURE(cxx_rvalue_references) || \\\n        (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1600)\n# endif\n#endif\n\n#if FMT_USE_RVALUE_REFERENCES\n# include <utility>  // for std::move\n#endif\n\n// Define FMT_USE_NOEXCEPT to make C++ Format use noexcept (C++11 feature).\n#ifndef FMT_USE_NOEXCEPT\n# define FMT_USE_NOEXCEPT 0\n#endif\n\n#ifndef FMT_NOEXCEPT\n# if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \\\n   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n   _MSC_VER >= 1900\n#  define FMT_NOEXCEPT noexcept\n# else\n#  define FMT_NOEXCEPT throw()\n# endif\n#endif\n\n// A macro to disallow the copy constructor and operator= functions\n// This should be used in the private: declarations for a class\n#ifndef FMT_USE_DELETED_FUNCTIONS\n# define FMT_USE_DELETED_FUNCTIONS 0\n#endif\n\n#if FMT_USE_DELETED_FUNCTIONS || FMT_HAS_FEATURE(cxx_deleted_functions) || \\\n  (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1800\n# define FMT_DELETED_OR_UNDEFINED  = delete\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&) = delete; \\\n    TypeName& operator=(const TypeName&) = delete\n#else\n# define FMT_DELETED_OR_UNDEFINED\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&); \\\n    TypeName& operator=(const TypeName&)\n#endif\n\n#ifndef FMT_USE_USER_DEFINED_LITERALS\n// All compilers which support UDLs also support variadic templates. This\n// makes the fmt::literals implementation easier. However, an explicit check\n// for variadic templates is added here just in case.\n# define FMT_USE_USER_DEFINED_LITERALS \\\n   FMT_USE_VARIADIC_TEMPLATES && \\\n   (FMT_HAS_FEATURE(cxx_user_literals) || \\\n       (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1900)\n#endif\n\n#ifndef FMT_ASSERT\n# define FMT_ASSERT(condition, message) assert((condition) && message)\n#endif\n\n/// Blackhole section {\n\nnamespace blackhole {\n\n/// } Blackhole section\n\nnamespace fmt {\n\n// Fix the warning about long long on older versions of GCC\n// that don't support the diagnostic pragma.\nFMT_GCC_EXTENSION typedef long long LongLong;\nFMT_GCC_EXTENSION typedef unsigned long long ULongLong;\n\n#if FMT_USE_RVALUE_REFERENCES\nusing std::move;\n#endif\n\ntemplate <typename Char>\nclass BasicWriter;\n\ntypedef BasicWriter<char> Writer;\ntypedef BasicWriter<wchar_t> WWriter;\n\ntemplate <typename Char>\nclass BasicFormatter;\n\ntemplate <typename Char, typename T>\nvoid format(BasicFormatter<Char> &f, const Char *&format_str, const T &value);\n\n/**\n  \\rst\n  A string reference. It can be constructed from a C string or ``std::string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +------------+-------------------------+\n  | Type       | Definition              |\n  +============+=========================+\n  | StringRef  | BasicStringRef<char>    |\n  +------------+-------------------------+\n  | WStringRef | BasicStringRef<wchar_t> |\n  +------------+-------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(StringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicStringRef {\n private:\n  const Char *data_;\n  std::size_t size_;\n\n public:\n  /** Constructs a string reference object from a C string and a size. */\n  BasicStringRef(const Char *s, std::size_t size) : data_(s), size_(size) {}\n\n  /**\n    \\rst\n    Constructs a string reference object from a C string computing\n    the size with ``std::char_traits<Char>::length``.\n    \\endrst\n   */\n  BasicStringRef(const Char *s)\n    : data_(s), size_(std::char_traits<Char>::length(s)) {}\n\n  /**\n    \\rst\n    Constructs a string reference from an ``std::string`` object.\n    \\endrst\n   */\n  BasicStringRef(const std::basic_string<Char> &s)\n  : data_(s.c_str()), size_(s.size()) {}\n\n  /**\n    \\rst\n    Converts a string reference to an ``std::string`` object.\n    \\endrst\n   */\n  std::basic_string<Char> to_string() const {\n    return std::basic_string<Char>(data_, size_);\n  }\n\n  /** Returns the pointer to a C string. */\n  const Char *data() const { return data_; }\n\n  /** Returns the string size. */\n  std::size_t size() const { return size_; }\n\n  // Lexicographically compare this string reference to other.\n  int compare(BasicStringRef other) const {\n    std::size_t size = std::min(size_, other.size_);\n    int result = std::char_traits<Char>::compare(data_, other.data_, size);\n    if (result == 0)\n      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);\n    return result;\n  }\n\n  friend bool operator==(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) == 0;\n  }\n  friend bool operator!=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) != 0;\n  }\n  friend bool operator<(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) < 0;\n  }\n  friend bool operator<=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) <= 0;\n  }\n  friend bool operator>(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) > 0;\n  }\n  friend bool operator>=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) >= 0;\n  }\n};\n\ntypedef BasicStringRef<char> StringRef;\ntypedef BasicStringRef<wchar_t> WStringRef;\n\n/**\n  \\rst\n  A reference to a null terminated string. It can be constructed from a C\n  string or ``std::string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +-------------+--------------------------+\n  | Type        | Definition               |\n  +=============+==========================+\n  | CStringRef  | BasicCStringRef<char>    |\n  +-------------+--------------------------+\n  | WCStringRef | BasicCStringRef<wchar_t> |\n  +-------------+--------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(CStringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicCStringRef {\n private:\n  const Char *data_;\n\n public:\n  /** Constructs a string reference object from a C string. */\n  BasicCStringRef(const Char *s) : data_(s) {}\n\n  /**\n    \\rst\n    Constructs a string reference from an ``std::string`` object.\n    \\endrst\n   */\n  BasicCStringRef(const std::basic_string<Char> &s) : data_(s.c_str()) {}\n\n  /** Returns the pointer to a C string. */\n  const Char *c_str() const { return data_; }\n};\n\ntypedef BasicCStringRef<char> CStringRef;\ntypedef BasicCStringRef<wchar_t> WCStringRef;\n\n/**\n  A formatting error such as invalid format string.\n*/\nclass FormatError : public std::runtime_error {\n public:\n  explicit FormatError(CStringRef message)\n  : std::runtime_error(message.c_str()) {}\n};\n\nnamespace internal {\n// The number of characters to store in the MemoryBuffer object itself\n// to avoid dynamic memory allocation.\nenum { INLINE_BUFFER_SIZE = 500 };\n\n#if FMT_SECURE_SCL\n// Use checked iterator to avoid warnings on MSVC.\ntemplate <typename T>\ninline stdext::checked_array_iterator<T*> make_ptr(T *ptr, std::size_t size) {\n  return stdext::checked_array_iterator<T*>(ptr, size);\n}\n#else\ntemplate <typename T>\ninline T *make_ptr(T *ptr, std::size_t) { return ptr; }\n#endif\n}  // namespace internal\n\n/**\n  \\rst\n  A buffer supporting a subset of ``std::vector``'s operations.\n  \\endrst\n */\ntemplate <typename T>\nclass Buffer {\n private:\n  FMT_DISALLOW_COPY_AND_ASSIGN(Buffer);\n\n protected:\n  T *ptr_;\n  std::size_t size_;\n  std::size_t capacity_;\n\n  Buffer(T *ptr = 0, std::size_t capacity = 0)\n    : ptr_(ptr), size_(0), capacity_(capacity) {}\n\n  /**\n    \\rst\n    Increases the buffer capacity to hold at least *size* elements updating\n    ``ptr_`` and ``capacity_``.\n    \\endrst\n   */\n  virtual void grow(std::size_t size) = 0;\n\n public:\n  virtual ~Buffer() {}\n\n  /** Returns the size of this buffer. */\n  std::size_t size() const { return size_; }\n\n  /** Returns the capacity of this buffer. */\n  std::size_t capacity() const { return capacity_; }\n\n  /**\n    Resizes the buffer. If T is a POD type new elements may not be initialized.\n   */\n  void resize(std::size_t new_size) {\n    if (new_size > capacity_)\n      grow(new_size);\n    size_ = new_size;\n  }\n\n  /**\n    \\rst\n    Reserves space to store at least *capacity* elements.\n    \\endrst\n   */\n  void reserve(std::size_t capacity) {\n    if (capacity > capacity_)\n      grow(capacity);\n  }\n\n  void clear() FMT_NOEXCEPT { size_ = 0; }\n\n  void push_back(const T &value) {\n    if (size_ == capacity_)\n      grow(size_ + 1);\n    ptr_[size_++] = value;\n  }\n\n  /** Appends data to the end of the buffer. */\n  template <typename U>\n  void append(const U *begin, const U *end);\n\n  T &operator[](std::size_t index) { return ptr_[index]; }\n  const T &operator[](std::size_t index) const { return ptr_[index]; }\n};\n\ntemplate <typename T>\ntemplate <typename U>\nvoid Buffer<T>::append(const U *begin, const U *end) {\n  std::ptrdiff_t num_elements = end - begin;\n  if (size_ + num_elements > capacity_)\n    grow(size_ + num_elements);\n  std::copy(begin, end, internal::make_ptr(ptr_, capacity_) + size_);\n  size_ += num_elements;\n}\n\nnamespace internal {\n\n// A memory buffer for POD types with the first SIZE elements stored in\n// the object itself.\ntemplate <typename T, std::size_t SIZE, typename Allocator = std::allocator<T> >\nclass MemoryBuffer : private Allocator, public Buffer<T> {\n private:\n  T data_[SIZE];\n\n  // Deallocate memory allocated by the buffer.\n  void deallocate() {\n    if (this->ptr_ != data_) Allocator::deallocate(this->ptr_, this->capacity_);\n  }\n\n protected:\n  void grow(std::size_t size);\n\n public:\n  explicit MemoryBuffer(const Allocator &alloc = Allocator())\n      : Allocator(alloc), Buffer<T>(data_, SIZE) {}\n  ~MemoryBuffer() { deallocate(); }\n\n#if FMT_USE_RVALUE_REFERENCES\n private:\n  // Move data from other to this buffer.\n  void move(MemoryBuffer &other) {\n    Allocator &this_alloc = *this, &other_alloc = other;\n    this_alloc = std::move(other_alloc);\n    this->size_ = other.size_;\n    this->capacity_ = other.capacity_;\n    if (other.ptr_ == other.data_) {\n      this->ptr_ = data_;\n      std::copy(other.data_,\n                other.data_ + this->size_, make_ptr(data_, this->capacity_));\n    } else {\n      this->ptr_ = other.ptr_;\n      // Set pointer to the inline array so that delete is not called\n      // when deallocating.\n      other.ptr_ = other.data_;\n    }\n  }\n\n public:\n  MemoryBuffer(MemoryBuffer &&other) {\n    move(other);\n  }\n\n  MemoryBuffer &operator=(MemoryBuffer &&other) {\n    assert(this != &other);\n    deallocate();\n    move(other);\n    return *this;\n  }\n#endif\n\n  // Returns a copy of the allocator associated with this buffer.\n  Allocator get_allocator() const { return *this; }\n};\n\ntemplate <typename T, std::size_t SIZE, typename Allocator>\nvoid MemoryBuffer<T, SIZE, Allocator>::grow(std::size_t size) {\n  std::size_t new_capacity =\n      (std::max)(size, this->capacity_ + this->capacity_ / 2);\n  T *new_ptr = this->allocate(new_capacity);\n  // The following code doesn't throw, so the raw pointer above doesn't leak.\n  std::copy(this->ptr_,\n            this->ptr_ + this->size_, make_ptr(new_ptr, new_capacity));\n  std::size_t old_capacity = this->capacity_;\n  T *old_ptr = this->ptr_;\n  this->capacity_ = new_capacity;\n  this->ptr_ = new_ptr;\n  // deallocate may throw (at least in principle), but it doesn't matter since\n  // the buffer already uses the new storage and will deallocate it in case\n  // of exception.\n  if (old_ptr != data_)\n    Allocator::deallocate(old_ptr, old_capacity);\n}\n\n// A fixed-size buffer.\ntemplate <typename Char>\nclass FixedBuffer : public fmt::Buffer<Char> {\n public:\n  FixedBuffer(Char *array, std::size_t size) : fmt::Buffer<Char>(array, size) {}\n\n protected:\n  void grow(std::size_t size);\n};\n\n#ifndef _MSC_VER\n// Portable version of signbit.\ninline int getsign(double x) {\n  // When compiled in C++11 mode signbit is no longer a macro but a function\n  // defined in namespace std and the macro is undefined.\n# ifdef signbit\n  return signbit(x);\n# else\n  return std::signbit(x);\n# endif\n}\n\n// Portable version of isinf.\n# ifdef isinf\ninline int isinfinity(double x) { return isinf(x); }\ninline int isinfinity(long double x) { return isinf(x); }\n# else\ninline int isinfinity(double x) { return std::isinf(x); }\ninline int isinfinity(long double x) { return std::isinf(x); }\n# endif\n\n// Portable version of isnan.\n# ifdef isnan\ninline int isnotanumber(double x) { return isnan(x); }\ninline int isnotanumber(long double x) { return isnan(x); }\n# else\ninline int isnotanumber(double x) { return std::isnan(x); }\ninline int isnotanumber(long double x) { return std::isnan(x); }\n# endif\n#else\ninline int getsign(double value) {\n  if (value < 0) return 1;\n  if (value == value) return 0;\n  int dec = 0, sign = 0;\n  char buffer[2];  // The buffer size must be >= 2 or _ecvt_s will fail.\n  _ecvt_s(buffer, sizeof(buffer), value, 0, &dec, &sign);\n  return sign;\n}\ninline int isinfinity(double x) { return !_finite(x); }\ninline int isinfinity(long double x) {\n  return !_finite(static_cast<double>(x));\n}\ninline int isnotanumber(double x) { return _isnan(x); }\ninline int isnotanumber(long double x) {\n    return _isnan(static_cast<double>(x));\n}\n#endif\n\ntemplate <typename Char>\nclass BasicCharTraits {\n public:\n#if FMT_SECURE_SCL\n  typedef stdext::checked_array_iterator<Char*> CharPtr;\n#else\n  typedef Char *CharPtr;\n#endif\n  static Char cast(wchar_t value) { return static_cast<Char>(value); }\n};\n\ntemplate <typename Char>\nclass CharTraits;\n\ntemplate <>\nclass CharTraits<char> : public BasicCharTraits<char> {\n private:\n  // Conversion from wchar_t to char is not allowed.\n  static char convert(wchar_t);\n\n public:\n  static char convert(char value) { return value; }\n\n  // Formats a floating-point number.\n  template <typename T>\n  static int format_float(char *buffer, std::size_t size,\n      const char *format, unsigned width, int precision, T value);\n};\n\ntemplate <>\nclass CharTraits<wchar_t> : public BasicCharTraits<wchar_t> {\n public:\n  static wchar_t convert(char value) { return value; }\n  static wchar_t convert(wchar_t value) { return value; }\n\n  template <typename T>\n  static int format_float(wchar_t *buffer, std::size_t size,\n      const wchar_t *format, unsigned width, int precision, T value);\n};\n\n// Checks if a number is negative - used to avoid warnings.\ntemplate <bool IsSigned>\nstruct SignChecker {\n  template <typename T>\n  static bool is_negative(T value) { return value < 0; }\n};\n\ntemplate <>\nstruct SignChecker<false> {\n  template <typename T>\n  static bool is_negative(T) { return false; }\n};\n\n// Returns true if value is negative, false otherwise.\n// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.\ntemplate <typename T>\ninline bool is_negative(T value) {\n  return SignChecker<std::numeric_limits<T>::is_signed>::is_negative(value);\n}\n\n// Selects uint32_t if FitsIn32Bits is true, uint64_t otherwise.\ntemplate <bool FitsIn32Bits>\nstruct TypeSelector { typedef uint32_t Type; };\n\ntemplate <>\nstruct TypeSelector<false> { typedef uint64_t Type; };\n\ntemplate <typename T>\nstruct IntTraits {\n  // Smallest of uint32_t and uint64_t that is large enough to represent\n  // all values of T.\n  typedef typename\n    TypeSelector<std::numeric_limits<T>::digits <= 32>::Type MainType;\n};\n\n// MakeUnsigned<T>::Type gives an unsigned type corresponding to integer type T.\ntemplate <typename T>\nstruct MakeUnsigned { typedef T Type; };\n\n#define FMT_SPECIALIZE_MAKE_UNSIGNED(T, U) \\\n  template <> \\\n  struct MakeUnsigned<T> { typedef U Type; }\n\nFMT_SPECIALIZE_MAKE_UNSIGNED(char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(signed char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(short, unsigned short);\nFMT_SPECIALIZE_MAKE_UNSIGNED(int, unsigned);\nFMT_SPECIALIZE_MAKE_UNSIGNED(long, unsigned long);\nFMT_SPECIALIZE_MAKE_UNSIGNED(LongLong, ULongLong);\n\nvoid report_unknown_type(char code, const char *type);\n\n// Static data is placed in this class template to allow header-only\n// configuration.\ntemplate <typename T = void>\nstruct BasicData {\n  static const uint32_t POWERS_OF_10_32[];\n  static const uint64_t POWERS_OF_10_64[];\n  static const char DIGITS[];\n};\n\ntypedef BasicData<> Data;\n\n#if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clz)\n# define FMT_BUILTIN_CLZ(n) __builtin_clz(n)\n#endif\n\n#if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clzll)\n# define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)\n#endif\n\n#ifdef FMT_BUILTIN_CLZLL\n// Returns the number of decimal digits in n. Leading zeros are not counted\n// except for n == 0 in which case count_digits returns 1.\ninline unsigned count_digits(uint64_t n) {\n  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.\n  unsigned t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;\n  return t - (n < Data::POWERS_OF_10_64[t]) + 1;\n}\n#else\n// Fallback version of count_digits used when __builtin_clz is not available.\ninline unsigned count_digits(uint64_t n) {\n  unsigned count = 1;\n  for (;;) {\n    // Integer division is slow so do it for a group of four digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    if (n < 10) return count;\n    if (n < 100) return count + 1;\n    if (n < 1000) return count + 2;\n    if (n < 10000) return count + 3;\n    n /= 10000u;\n    count += 4;\n  }\n}\n#endif\n\n#ifdef FMT_BUILTIN_CLZ\n// Optional version of count_digits for better performance on 32-bit platforms.\ninline unsigned count_digits(uint32_t n) {\n  uint32_t t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 >> 12;\n  return t - (n < Data::POWERS_OF_10_32[t]) + 1;\n}\n#endif\n\n// Formats a decimal unsigned integer value writing into buffer.\ntemplate <typename UInt, typename Char>\ninline void format_decimal(Char *buffer, UInt value, unsigned num_digits) {\n  buffer += num_digits;\n  while (value >= 100) {\n    // Integer division is slow so do it for a group of two digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    unsigned index = (value % 100) * 2;\n    value /= 100;\n    *--buffer = Data::DIGITS[index + 1];\n    *--buffer = Data::DIGITS[index];\n  }\n  if (value < 10) {\n    *--buffer = static_cast<char>('0' + value);\n    return;\n  }\n  unsigned index = static_cast<unsigned>(value * 2);\n  *--buffer = Data::DIGITS[index + 1];\n  *--buffer = Data::DIGITS[index];\n}\n\n#ifndef _WIN32\n# define FMT_USE_WINDOWS_H 0\n#elif !defined(FMT_USE_WINDOWS_H)\n# define FMT_USE_WINDOWS_H 1\n#endif\n\n// Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.\n// All the functionality that relies on it will be disabled too.\n#if FMT_USE_WINDOWS_H\n// A converter from UTF-8 to UTF-16.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF8ToUTF16 {\n private:\n  MemoryBuffer<wchar_t, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  explicit UTF8ToUTF16(StringRef s);\n  operator WStringRef() const { return WStringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const wchar_t *c_str() const { return &buffer_[0]; }\n  std::wstring str() const { return std::wstring(&buffer_[0], size()); }\n};\n\n// A converter from UTF-16 to UTF-8.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF16ToUTF8 {\n private:\n  MemoryBuffer<char, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  UTF16ToUTF8() {}\n  explicit UTF16ToUTF8(WStringRef s);\n  operator StringRef() const { return StringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const char *c_str() const { return &buffer_[0]; }\n  std::string str() const { return std::string(&buffer_[0], size()); }\n\n  // Performs conversion returning a system error code instead of\n  // throwing exception on conversion error. This method may still throw\n  // in case of memory allocation error.\n  int convert(WStringRef s);\n};\n\nvoid format_windows_error(fmt::Writer &out, int error_code,\n                          fmt::StringRef message) FMT_NOEXCEPT;\n#endif\n\nvoid format_system_error(fmt::Writer &out, int error_code,\n                         fmt::StringRef message) FMT_NOEXCEPT;\n\n// A formatting argument value.\nstruct Value {\n  template <typename Char>\n  struct StringValue {\n    const Char *value;\n    std::size_t size;\n  };\n\n  typedef void (*FormatFunc)(\n      void *formatter, const void *arg, void *format_str_ptr);\n\n  struct CustomValue {\n    const void *value;\n    FormatFunc format;\n  };\n\n  union {\n    int int_value;\n    unsigned uint_value;\n    LongLong long_long_value;\n    ULongLong ulong_long_value;\n    double double_value;\n    long double long_double_value;\n    const void *pointer;\n    StringValue<char> string;\n    StringValue<signed char> sstring;\n    StringValue<unsigned char> ustring;\n    StringValue<wchar_t> wstring;\n    CustomValue custom;\n  };\n\n  enum Type {\n    NONE, NAMED_ARG,\n    // Integer types should go first,\n    INT, UINT, LONG_LONG, ULONG_LONG, BOOL, CHAR, LAST_INTEGER_TYPE = CHAR,\n    // followed by floating-point types.\n    DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,\n    CSTRING, STRING, WSTRING, POINTER, CUSTOM\n  };\n};\n\n// A formatting argument. It is a POD type to allow storage in\n// internal::MemoryBuffer.\nstruct Arg : Value {\n  Type type;\n};\n\ntemplate <typename Char>\nstruct NamedArg;\n\ntemplate <typename T = void>\nstruct Null {};\n\n// A helper class template to enable or disable overloads taking wide\n// characters and strings in MakeValue.\ntemplate <typename T, typename Char>\nstruct WCharHelper {\n  typedef Null<T> Supported;\n  typedef T Unsupported;\n};\n\ntemplate <typename T>\nstruct WCharHelper<T, wchar_t> {\n  typedef T Supported;\n  typedef Null<T> Unsupported;\n};\n\ntemplate <typename T>\nclass IsConvertibleToInt {\n private:\n  typedef char yes[1];\n  typedef char no[2];\n\n  static const T &get();\n\n  static yes &convert(fmt::ULongLong);\n  static no &convert(...);\n\n public:\n  enum { value = (sizeof(convert(get())) == sizeof(yes)) };\n};\n\n#define FMT_CONVERTIBLE_TO_INT(Type) \\\n  template <> \\\n  class IsConvertibleToInt<Type> { \\\n   public: \\\n    enum { value = 1 }; \\\n  }\n\n// Silence warnings about convering float to int.\nFMT_CONVERTIBLE_TO_INT(float);\nFMT_CONVERTIBLE_TO_INT(double);\nFMT_CONVERTIBLE_TO_INT(long double);\n\ntemplate<bool B, class T = void>\nstruct EnableIf {};\n\ntemplate<class T>\nstruct EnableIf<true, T> { typedef T type; };\n\ntemplate<bool B, class T, class F>\nstruct Conditional { typedef T type; };\n\ntemplate<class T, class F>\nstruct Conditional<false, T, F> { typedef F type; };\n\n// A helper function to suppress bogus \"conditional expression is constant\"\n// warnings.\ntemplate <typename T>\ninline T check(T value) { return value; }\n\n// Makes an Arg object from any type.\ntemplate <typename Char>\nclass MakeValue : public Arg {\n private:\n  // The following two methods are private to disallow formatting of\n  // arbitrary pointers. If you want to output a pointer cast it to\n  // \"void *\" or \"const void *\". In particular, this forbids formatting\n  // of \"[const] volatile char *\" which is printed as bool by iostreams.\n  // Do not implement!\n  template <typename T>\n  MakeValue(const T *value);\n  template <typename T>\n  MakeValue(T *value);\n\n  // The following methods are private to disallow formatting of wide\n  // characters and strings into narrow strings as in\n  //   fmt::format(\"{}\", L\"test\");\n  // To fix this, use a wide format string: fmt::format(L\"{}\", L\"test\").\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Unsupported);\n#endif\n  MakeValue(typename WCharHelper<wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const std::wstring &, Char>::Unsupported);\n  MakeValue(typename WCharHelper<WStringRef, Char>::Unsupported);\n\n  void set_string(StringRef str) {\n    string.value = str.data();\n    string.size = str.size();\n  }\n\n  void set_string(WStringRef str) {\n    wstring.value = str.data();\n    wstring.size = str.size();\n  }\n\n  // Formats an argument of a custom type, such as a user-defined class.\n  template <typename T>\n  static void format_custom_arg(\n      void *formatter, const void *arg, void *format_str_ptr) {\n    format(*static_cast<BasicFormatter<Char>*>(formatter),\n           *static_cast<const Char**>(format_str_ptr),\n           *static_cast<const T*>(arg));\n  }\n\n public:\n  MakeValue() {}\n\n#define FMT_MAKE_VALUE_(Type, field, TYPE, rhs) \\\n  MakeValue(Type value) { field = rhs; } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n#define FMT_MAKE_VALUE(Type, field, TYPE) \\\n  FMT_MAKE_VALUE_(Type, field, TYPE, value)\n\n  FMT_MAKE_VALUE(bool, int_value, BOOL)\n  FMT_MAKE_VALUE(short, int_value, INT)\n  FMT_MAKE_VALUE(unsigned short, uint_value, UINT)\n  FMT_MAKE_VALUE(int, int_value, INT)\n  FMT_MAKE_VALUE(unsigned, uint_value, UINT)\n\n  MakeValue(long value) {\n    // To minimize the number of types we need to deal with, long is\n    // translated either to int or to long long depending on its size.\n    if (check(sizeof(long) == sizeof(int)))\n      int_value = static_cast<int>(value);\n    else\n      long_long_value = value;\n  }\n  static uint64_t type(long) {\n    return sizeof(long) == sizeof(int) ? Arg::INT : Arg::LONG_LONG;\n  }\n\n  MakeValue(unsigned long value) {\n    if (check(sizeof(unsigned long) == sizeof(unsigned)))\n      uint_value = static_cast<unsigned>(value);\n    else\n      ulong_long_value = value;\n  }\n  static uint64_t type(unsigned long) {\n    return sizeof(unsigned long) == sizeof(unsigned) ?\n          Arg::UINT : Arg::ULONG_LONG;\n  }\n\n  FMT_MAKE_VALUE(LongLong, long_long_value, LONG_LONG)\n  FMT_MAKE_VALUE(ULongLong, ulong_long_value, ULONG_LONG)\n  FMT_MAKE_VALUE(float, double_value, DOUBLE)\n  FMT_MAKE_VALUE(double, double_value, DOUBLE)\n  FMT_MAKE_VALUE(long double, long_double_value, LONG_DOUBLE)\n  FMT_MAKE_VALUE(signed char, int_value, CHAR)\n  FMT_MAKE_VALUE(unsigned char, int_value, CHAR)\n  FMT_MAKE_VALUE(char, int_value, CHAR)\n\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Supported value) {\n    int_value = value;\n  }\n  static uint64_t type(wchar_t) { return Arg::CHAR; }\n#endif\n\n#define FMT_MAKE_STR_VALUE(Type, TYPE) \\\n  MakeValue(Type value) { set_string(value); } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_VALUE(char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(const char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(const signed char *, sstring.value, CSTRING)\n  FMT_MAKE_VALUE(const unsigned char *, ustring.value, CSTRING)\n  FMT_MAKE_STR_VALUE(const std::string &, STRING)\n  FMT_MAKE_STR_VALUE(StringRef, STRING)\n  FMT_MAKE_VALUE_(CStringRef, string.value, CSTRING, value.c_str())\n\n#define FMT_MAKE_WSTR_VALUE(Type, TYPE) \\\n  MakeValue(typename WCharHelper<Type, Char>::Supported value) { \\\n    set_string(value); \\\n  } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_WSTR_VALUE(wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const std::wstring &, WSTRING)\n  FMT_MAKE_WSTR_VALUE(WStringRef, WSTRING)\n\n  FMT_MAKE_VALUE(void *, pointer, POINTER)\n  FMT_MAKE_VALUE(const void *, pointer, POINTER)\n\n  template <typename T>\n  MakeValue(const T &value,\n            typename EnableIf<!IsConvertibleToInt<T>::value, int>::type = 0) {\n    custom.value = &value;\n    custom.format = &format_custom_arg<T>;\n  }\n\n  template <typename T>\n  MakeValue(const T &value,\n            typename EnableIf<IsConvertibleToInt<T>::value, int>::type = 0) {\n    int_value = value;\n  }\n\n  template <typename T>\n  static uint64_t type(const T &) {\n    return IsConvertibleToInt<T>::value ? Arg::INT : Arg::CUSTOM;\n  }\n\n  // Additional template param `Char_` is needed here because make_type always\n  // uses MakeValue<char>.\n  template <typename Char_>\n  MakeValue(const NamedArg<Char_> &value) { pointer = &value; }\n\n  template <typename Char_>\n  static uint64_t type(const NamedArg<Char_> &) { return Arg::NAMED_ARG; }\n};\n\ntemplate <typename Char>\nstruct NamedArg : Arg {\n  BasicStringRef<Char> name;\n\n  template <typename T>\n  NamedArg(BasicStringRef<Char> argname, const T &value)\n  : Arg(MakeValue<Char>(value)), name(argname) {\n    type = static_cast<internal::Arg::Type>(MakeValue<Char>::type(value));\n  }\n};\n\n#define FMT_DISPATCH(call) static_cast<Impl*>(this)->call\n\n// An argument visitor.\n// To use ArgVisitor define a subclass that implements some or all of the\n// visit methods with the same signatures as the methods in ArgVisitor,\n// for example, visit_int(int).\n// Specify the subclass name as the Impl template parameter. Then calling\n// ArgVisitor::visit for some argument will dispatch to a visit method\n// specific to the argument type. For example, if the argument type is\n// double then visit_double(double) method of a subclass will be called.\n// If the subclass doesn't contain a method with this signature, then\n// a corresponding method of ArgVisitor will be called.\n//\n// Example:\n//  class MyArgVisitor : public ArgVisitor<MyArgVisitor, void> {\n//   public:\n//    void visit_int(int value) { print(\"{}\", value); }\n//    void visit_double(double value) { print(\"{}\", value ); }\n//  };\n//\n// ArgVisitor uses the curiously recurring template pattern:\n// http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\ntemplate <typename Impl, typename Result>\nclass ArgVisitor {\n public:\n  void report_unhandled_arg() {}\n\n  Result visit_unhandled_arg() {\n    FMT_DISPATCH(report_unhandled_arg());\n    return Result();\n  }\n\n  Result visit_int(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_long_long(LongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_uint(unsigned value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_ulong_long(ULongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_bool(bool value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  Result visit_char(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n  template <typename T>\n  Result visit_any_int(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  Result visit_double(double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n  Result visit_long_double(long double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n  template <typename T>\n  Result visit_any_double(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  Result visit_string(Arg::StringValue<char>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n  Result visit_wstring(Arg::StringValue<wchar_t>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n  Result visit_pointer(const void *) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n  Result visit_custom(Arg::CustomValue) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  Result visit(const Arg &arg) {\n    switch (arg.type) {\n    default:\n      FMT_ASSERT(false, \"invalid argument type\");\n      return Result();\n    case Arg::INT:\n      return FMT_DISPATCH(visit_int(arg.int_value));\n    case Arg::UINT:\n      return FMT_DISPATCH(visit_uint(arg.uint_value));\n    case Arg::LONG_LONG:\n      return FMT_DISPATCH(visit_long_long(arg.long_long_value));\n    case Arg::ULONG_LONG:\n      return FMT_DISPATCH(visit_ulong_long(arg.ulong_long_value));\n    case Arg::BOOL:\n      return FMT_DISPATCH(visit_bool(arg.int_value != 0));\n    case Arg::CHAR:\n      return FMT_DISPATCH(visit_char(arg.int_value));\n    case Arg::DOUBLE:\n      return FMT_DISPATCH(visit_double(arg.double_value));\n    case Arg::LONG_DOUBLE:\n      return FMT_DISPATCH(visit_long_double(arg.long_double_value));\n    case Arg::CSTRING: {\n      Arg::StringValue<char> str = arg.string;\n      str.size = 0;\n      return FMT_DISPATCH(visit_string(str));\n    }\n    case Arg::STRING:\n      return FMT_DISPATCH(visit_string(arg.string));\n    case Arg::WSTRING:\n      return FMT_DISPATCH(visit_wstring(arg.wstring));\n    case Arg::POINTER:\n      return FMT_DISPATCH(visit_pointer(arg.pointer));\n    case Arg::CUSTOM:\n      return FMT_DISPATCH(visit_custom(arg.custom));\n    }\n  }\n};\n\nclass RuntimeError : public std::runtime_error {\n protected:\n  RuntimeError() : std::runtime_error(\"\") {}\n};\n\ntemplate <typename Impl, typename Char>\nclass BasicArgFormatter;\n\ntemplate <typename Char>\nclass PrintfArgFormatter;\n\ntemplate <typename Char>\nclass ArgMap;\n}  // namespace internal\n\n/** An argument list. */\nclass ArgList {\n private:\n  // To reduce compiled code size per formatting function call, types of first\n  // MAX_PACKED_ARGS arguments are passed in the types_ field.\n  uint64_t types_;\n  union {\n    // If the number of arguments is less than MAX_PACKED_ARGS, the argument\n    // values are stored in values_, otherwise they are stored in args_.\n    // This is done to reduce compiled code size as storing larger objects\n    // may require more code (at least on x86-64) even if the same amount of\n    // data is actually copied to stack. It saves ~10% on the bloat test.\n    const internal::Value *values_;\n    const internal::Arg *args_;\n  };\n\n  internal::Arg::Type type(unsigned index) const {\n    unsigned shift = index * 4;\n    uint64_t mask = 0xf;\n    return static_cast<internal::Arg::Type>(\n          (types_ & (mask << shift)) >> shift);\n  }\n\n  template <typename Char>\n  friend class internal::ArgMap;\n\n public:\n  // Maximum number of arguments with packed types.\n  enum { MAX_PACKED_ARGS = 16 };\n\n  ArgList() : types_(0) {}\n\n  ArgList(ULongLong types, const internal::Value *values)\n  : types_(types), values_(values) {}\n  ArgList(ULongLong types, const internal::Arg *args)\n  : types_(types), args_(args) {}\n\n  /** Returns the argument at specified index. */\n  internal::Arg operator[](unsigned index) const {\n    using internal::Arg;\n    Arg arg;\n    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;\n    if (index < MAX_PACKED_ARGS) {\n      Arg::Type arg_type = type(index);\n      internal::Value &val = arg;\n      if (arg_type != Arg::NONE)\n        val = use_values ? values_[index] : args_[index];\n      arg.type = arg_type;\n      return arg;\n    }\n    if (use_values) {\n      // The index is greater than the number of arguments that can be stored\n      // in values, so return a \"none\" argument.\n      arg.type = Arg::NONE;\n      return arg;\n    }\n    for (unsigned i = MAX_PACKED_ARGS; i <= index; ++i) {\n      if (args_[i].type == Arg::NONE)\n        return args_[i];\n    }\n    return args_[index];\n  }\n};\n\nstruct FormatSpec;\n\nnamespace internal {\n\ntemplate <typename Char>\nclass ArgMap {\n private:\n  typedef std::map<fmt::BasicStringRef<Char>, internal::Arg> MapType;\n  typedef typename MapType::value_type Pair;\n\n  MapType map_;\n\n public:\n  void init(const ArgList &args);\n\n  const internal::Arg* find(const fmt::BasicStringRef<Char> &name) const {\n    typename MapType::const_iterator it = map_.find(name);\n    return it != map_.end() ? &it->second : 0;\n  }\n};\n\nclass FormatterBase {\n private:\n  ArgList args_;\n  int next_arg_index_;\n\n  // Returns the argument with specified index.\n  Arg do_get_arg(unsigned arg_index, const char *&error);\n\n protected:\n  const ArgList &args() const { return args_; }\n\n  explicit FormatterBase(const ArgList &args) {\n    args_ = args;\n    next_arg_index_ = 0;\n  }\n\n  // Returns the next argument.\n  Arg next_arg(const char *&error);\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified index.\n  Arg get_arg(unsigned arg_index, const char *&error);\n\n  bool check_no_auto_index(const char *&error);\n\n  template <typename Char>\n  void write(BasicWriter<Char> &w, const Char *start, const Char *end) {\n    if (start != end)\n      w << BasicStringRef<Char>(start, end - start);\n  }\n};\n\n// A printf formatter.\ntemplate <typename Char>\nclass PrintfFormatter : private FormatterBase {\n private:\n  void parse_flags(FormatSpec &spec, const Char *&s);\n\n  // Returns the argument with specified index or, if arg_index is equal\n  // to the maximum unsigned value, the next argument.\n  Arg get_arg(const Char *s,\n      unsigned arg_index = (std::numeric_limits<unsigned>::max)());\n\n  // Parses argument index, flags and width and returns the argument index.\n  unsigned parse_header(const Char *&s, FormatSpec &spec);\n\n public:\n  explicit PrintfFormatter(const ArgList &args) : FormatterBase(args) {}\n  void format(BasicWriter<Char> &writer, BasicCStringRef<Char> format_str);\n};\n}  // namespace internal\n\n// A formatter.\ntemplate <typename Char>\nclass BasicFormatter : private internal::FormatterBase {\n private:\n  BasicWriter<Char> &writer_;\n  internal::ArgMap<Char> map_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicFormatter);\n\n  using FormatterBase::get_arg;\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified name.\n  internal::Arg get_arg(BasicStringRef<Char> arg_name, const char *&error);\n\n  // Parses argument index and returns corresponding argument.\n  internal::Arg parse_arg_index(const Char *&s);\n\n  // Parses argument name and returns corresponding argument.\n  internal::Arg parse_arg_name(const Char *&s);\n\n public:\n  BasicFormatter(const ArgList &args, BasicWriter<Char> &w)\n    : FormatterBase(args), writer_(w) {}\n\n  BasicWriter<Char> &writer() { return writer_; }\n\n  void format(BasicCStringRef<Char> format_str);\n\n  const Char *format(const Char *&format_str, const internal::Arg &arg);\n};\n\nenum Alignment {\n  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC\n};\n\n// Flags.\nenum {\n  SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8,\n  CHAR_FLAG = 0x10  // Argument has char type - used in error reporting.\n};\n\n// An empty format specifier.\nstruct EmptySpec {};\n\n// A type specifier.\ntemplate <char TYPE>\nstruct TypeSpec : EmptySpec {\n  Alignment align() const { return ALIGN_DEFAULT; }\n  unsigned width() const { return 0; }\n  int precision() const { return -1; }\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n  char fill() const { return ' '; }\n};\n\n// A width specifier.\nstruct WidthSpec {\n  unsigned width_;\n  // Fill is always wchar_t and cast to char if necessary to avoid having\n  // two specialization of WidthSpec and its subclasses.\n  wchar_t fill_;\n\n  WidthSpec(unsigned width, wchar_t fill) : width_(width), fill_(fill) {}\n\n  unsigned width() const { return width_; }\n  wchar_t fill() const { return fill_; }\n};\n\n// An alignment specifier.\nstruct AlignSpec : WidthSpec {\n  Alignment align_;\n\n  AlignSpec(unsigned width, wchar_t fill, Alignment align = ALIGN_DEFAULT)\n  : WidthSpec(width, fill), align_(align) {}\n\n  Alignment align() const { return align_; }\n\n  int precision() const { return -1; }\n};\n\n// An alignment and type specifier.\ntemplate <char TYPE>\nstruct AlignTypeSpec : AlignSpec {\n  AlignTypeSpec(unsigned width, wchar_t fill) : AlignSpec(width, fill) {}\n\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n};\n\n// A full format specifier.\nstruct FormatSpec : AlignSpec {\n  unsigned flags_;\n  int precision_;\n  char type_;\n\n  FormatSpec(\n    unsigned width = 0, char type = 0, wchar_t fill = ' ')\n  : AlignSpec(width, fill), flags_(0), precision_(-1), type_(type) {}\n\n  bool flag(unsigned f) const { return (flags_ & f) != 0; }\n  int precision() const { return precision_; }\n  char type() const { return type_; }\n};\n\n// An integer format specifier.\ntemplate <typename T, typename SpecT = TypeSpec<0>, typename Char = char>\nclass IntFormatSpec : public SpecT {\n private:\n  T value_;\n\n public:\n  IntFormatSpec(T val, const SpecT &spec = SpecT())\n  : SpecT(spec), value_(val) {}\n\n  T value() const { return value_; }\n};\n\n// A string format specifier.\ntemplate <typename Char>\nclass StrFormatSpec : public AlignSpec {\n private:\n  const Char *str_;\n\n public:\n  template <typename FillChar>\n  StrFormatSpec(const Char *str, unsigned width, FillChar fill)\n  : AlignSpec(width, fill), str_(str) {\n    internal::CharTraits<Char>::convert(FillChar());\n  }\n\n  const Char *str() const { return str_; }\n};\n\n/**\n  Returns an integer format specifier to format the value in base 2.\n */\nIntFormatSpec<int, TypeSpec<'b'> > bin(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 8.\n */\nIntFormatSpec<int, TypeSpec<'o'> > oct(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 16 using\n  lower-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'x'> > hex(int value);\n\n/**\n  Returns an integer formatter format specifier to format in base 16 using\n  upper-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'X'> > hexu(int value);\n\n/**\n  \\rst\n  Returns an integer format specifier to pad the formatted argument with the\n  fill character to the specified width using the default (right) numeric\n  alignment.\n\n  **Example**::\n\n    MemoryWriter out;\n    out << pad(hex(0xcafe), 8, '0');\n    // out.str() == \"0000cafe\"\n\n  \\endrst\n */\ntemplate <char TYPE_CODE, typename Char>\nIntFormatSpec<int, AlignTypeSpec<TYPE_CODE>, Char> pad(\n    int value, unsigned width, Char fill = ' ');\n\n#define FMT_DEFINE_INT_FORMATTERS(TYPE) \\\ninline IntFormatSpec<TYPE, TypeSpec<'b'> > bin(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'b'> >(value, TypeSpec<'b'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'o'> > oct(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'o'> >(value, TypeSpec<'o'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'x'> > hex(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'x'> >(value, TypeSpec<'x'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'X'> > hexu(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'X'> >(value, TypeSpec<'X'>()); \\\n} \\\n \\\ntemplate <char TYPE_CODE> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> > pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE> > f, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> >( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, ' ')); \\\n} \\\n \\\n/* For compatibility with older compilers we provide two overloads for pad, */ \\\n/* one that takes a fill character and one that doesn't. In the future this */ \\\n/* can be replaced with one overload making the template argument Char      */ \\\n/* default to char (C++11). */ \\\ntemplate <char TYPE_CODE, typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char> pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE>, Char> f, \\\n    unsigned width, Char fill) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char>( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, fill)); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0> > pad( \\\n    TYPE value, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<0> >( \\\n      value, AlignTypeSpec<0>(width, ' ')); \\\n} \\\n \\\ntemplate <typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0>, Char> pad( \\\n   TYPE value, unsigned width, Char fill) { \\\n return IntFormatSpec<TYPE, AlignTypeSpec<0>, Char>( \\\n     value, AlignTypeSpec<0>(width, fill)); \\\n}\n\nFMT_DEFINE_INT_FORMATTERS(int)\nFMT_DEFINE_INT_FORMATTERS(long)\nFMT_DEFINE_INT_FORMATTERS(unsigned)\nFMT_DEFINE_INT_FORMATTERS(unsigned long)\nFMT_DEFINE_INT_FORMATTERS(LongLong)\nFMT_DEFINE_INT_FORMATTERS(ULongLong)\n\n/**\n  \\rst\n  Returns a string formatter that pads the formatted argument with the fill\n  character to the specified width using the default (left) string alignment.\n\n  **Example**::\n\n    std::string s = str(MemoryWriter() << pad(\"abc\", 8));\n    // s == \"abc     \"\n\n  \\endrst\n */\ntemplate <typename Char>\ninline StrFormatSpec<Char> pad(\n    const Char *str, unsigned width, Char fill = ' ') {\n  return StrFormatSpec<Char>(str, width, fill);\n}\n\ninline StrFormatSpec<wchar_t> pad(\n    const wchar_t *str, unsigned width, char fill = ' ') {\n  return StrFormatSpec<wchar_t>(str, width, fill);\n}\n\n// Generates a comma-separated list with results of applying f to\n// numbers 0..n-1.\n# define FMT_GEN(n, f) FMT_GEN##n(f)\n# define FMT_GEN1(f)  f(0)\n# define FMT_GEN2(f)  FMT_GEN1(f),  f(1)\n# define FMT_GEN3(f)  FMT_GEN2(f),  f(2)\n# define FMT_GEN4(f)  FMT_GEN3(f),  f(3)\n# define FMT_GEN5(f)  FMT_GEN4(f),  f(4)\n# define FMT_GEN6(f)  FMT_GEN5(f),  f(5)\n# define FMT_GEN7(f)  FMT_GEN6(f),  f(6)\n# define FMT_GEN8(f)  FMT_GEN7(f),  f(7)\n# define FMT_GEN9(f)  FMT_GEN8(f),  f(8)\n# define FMT_GEN10(f) FMT_GEN9(f),  f(9)\n# define FMT_GEN11(f) FMT_GEN10(f), f(10)\n# define FMT_GEN12(f) FMT_GEN11(f), f(11)\n# define FMT_GEN13(f) FMT_GEN12(f), f(12)\n# define FMT_GEN14(f) FMT_GEN13(f), f(13)\n# define FMT_GEN15(f) FMT_GEN14(f), f(14)\n\nnamespace internal {\ninline uint64_t make_type() { return 0; }\n\ntemplate <typename T>\ninline uint64_t make_type(const T &arg) { return MakeValue<char>::type(arg); }\n\ntemplate <unsigned N>\nstruct ArgArray {\n  // Computes the argument array size by adding 1 to N, which is the number of\n  // arguments, if N is zero, because array of zero size is invalid, or if N\n  // is greater than ArgList::MAX_PACKED_ARGS to accommodate for an extra\n  // argument that marks the end of the list.\n  enum { SIZE = N + (N == 0 || N >= ArgList::MAX_PACKED_ARGS ? 1 : 0) };\n\n  typedef typename Conditional<\n    (N < ArgList::MAX_PACKED_ARGS), Value, Arg>::type Type[SIZE];\n};\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate <typename Arg, typename... Args>\ninline uint64_t make_type(const Arg &first, const Args & ... tail) {\n  return make_type(first) | (make_type(tail...) << 4);\n}\n\ninline void do_set_types(Arg *) {}\n\ntemplate <typename T, typename... Args>\ninline void do_set_types(Arg *args, const T &arg, const Args & ... tail) {\n  args->type = static_cast<Arg::Type>(MakeValue<T>::type(arg));\n  do_set_types(args + 1, tail...);\n}\n\ntemplate <typename... Args>\ninline void set_types(Arg *array, const Args & ... args) {\n  if (check(sizeof...(Args) > ArgList::MAX_PACKED_ARGS))\n    do_set_types(array, args...);\n  array[sizeof...(Args)].type = Arg::NONE;\n}\n\ntemplate <typename... Args>\ninline void set_types(Value *, const Args & ...) {\n  // Do nothing as types are passed separately from values.\n}\n\ntemplate <typename Char, typename Value>\ninline void store_args(Value *) {}\n\ntemplate <typename Char, typename Arg, typename T, typename... Args>\ninline void store_args(Arg *args, const T &arg, const Args & ... tail) {\n  // Assign only the Value subobject of Arg and don't overwrite type (if any)\n  // that is assigned by set_types.\n  Value &value = *args;\n  value = MakeValue<Char>(arg);\n  store_args<Char>(args + 1, tail...);\n}\n\ntemplate <typename Char, typename... Args>\nArgList make_arg_list(typename ArgArray<sizeof...(Args)>::Type array,\n                      const Args & ... args) {\n  if (check(sizeof...(Args) >= ArgList::MAX_PACKED_ARGS))\n    set_types(array, args...);\n  store_args<Char>(array, args...);\n  return ArgList(make_type(args...), array);\n}\n#else\n\nstruct ArgType {\n  uint64_t type;\n\n  ArgType() : type(0) {}\n\n  template <typename T>\n  ArgType(const T &arg) : type(make_type(arg)) {}\n};\n\n# define FMT_ARG_TYPE_DEFAULT(n) ArgType t##n = ArgType()\n\ninline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n  return t0.type | (t1.type << 4) | (t2.type << 8) | (t3.type << 12) |\n      (t4.type << 16) | (t5.type << 20) | (t6.type << 24) | (t7.type << 28) |\n      (t8.type << 32) | (t9.type << 36) | (t10.type << 40) | (t11.type << 44) |\n      (t12.type << 48) | (t13.type << 52) | (t14.type << 56);\n}\n#endif\n}  // namespace internal\n\n# define FMT_MAKE_TEMPLATE_ARG(n) typename T##n\n# define FMT_MAKE_ARG_TYPE(n) T##n\n# define FMT_MAKE_ARG(n) const T##n &v##n\n# define FMT_MAKE_REF_char(n) fmt::internal::MakeValue<char>(v##n)\n# define FMT_MAKE_REF_wchar_t(n) fmt::internal::MakeValue<wchar_t>(v##n)\n\n#if FMT_USE_VARIADIC_TEMPLATES\n// Defines a variadic function returning void.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  template <typename... Args> \\\n  void func(arg_type arg0, const Args & ... args) { \\\n    typename fmt::internal::ArgArray<sizeof...(Args)>::Type array; \\\n    func(arg0, fmt::internal::make_arg_list<Char>(array, args...)); \\\n  }\n\n// Defines a variadic constructor.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  template <typename... Args> \\\n  ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \\\n    typename fmt::internal::ArgArray<sizeof...(Args)>::Type array; \\\n    func(arg0, arg1, fmt::internal::make_arg_list<Char>(array, args...)); \\\n  }\n\n#else\n\n# define FMT_MAKE_REF(n) fmt::internal::MakeValue<Char>(v##n)\n# define FMT_MAKE_REF2(n) v##n\n\n// Defines a wrapper for a function taking one argument of type arg_type\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP1(func, arg_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic function returning void on a pre-C++11 compiler.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  inline void func(arg_type arg) { func(arg, fmt::ArgList()); } \\\n  FMT_WRAP1(func, arg_type, 1) FMT_WRAP1(func, arg_type, 2) \\\n  FMT_WRAP1(func, arg_type, 3) FMT_WRAP1(func, arg_type, 4) \\\n  FMT_WRAP1(func, arg_type, 5) FMT_WRAP1(func, arg_type, 6) \\\n  FMT_WRAP1(func, arg_type, 7) FMT_WRAP1(func, arg_type, 8) \\\n  FMT_WRAP1(func, arg_type, 9) FMT_WRAP1(func, arg_type, 10)\n\n# define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg0, arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic constructor on a pre-C++11 compiler.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 1) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 2) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 3) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 4) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 5) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 6) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 7) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 8) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 9) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 10)\n#endif\n\n// Generates a comma-separated list with results of applying f to pairs\n// (argument, index).\n#define FMT_FOR_EACH1(f, x0) f(x0, 0)\n#define FMT_FOR_EACH2(f, x0, x1) \\\n  FMT_FOR_EACH1(f, x0), f(x1, 1)\n#define FMT_FOR_EACH3(f, x0, x1, x2) \\\n  FMT_FOR_EACH2(f, x0 ,x1), f(x2, 2)\n#define FMT_FOR_EACH4(f, x0, x1, x2, x3) \\\n  FMT_FOR_EACH3(f, x0, x1, x2), f(x3, 3)\n#define FMT_FOR_EACH5(f, x0, x1, x2, x3, x4) \\\n  FMT_FOR_EACH4(f, x0, x1, x2, x3), f(x4, 4)\n#define FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5) \\\n  FMT_FOR_EACH5(f, x0, x1, x2, x3, x4), f(x5, 5)\n#define FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6) \\\n  FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5), f(x6, 6)\n#define FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7) \\\n  FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6), f(x7, 7)\n#define FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8) \\\n  FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7), f(x8, 8)\n#define FMT_FOR_EACH10(f, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) \\\n  FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8), f(x9, 9)\n\n/**\n An error returned by an operating system or a language runtime,\n for example a file opening error.\n*/\nclass SystemError : public internal::RuntimeError {\n private:\n  void init(int err_code, CStringRef format_str, ArgList args);\n\n protected:\n  int error_code_;\n\n  typedef char Char;  // For FMT_VARIADIC_CTOR.\n\n  SystemError() {}\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::SystemError` object with the description\n   of the form\n\n   .. parsed-literal::\n     *<message>*: *<system-message>*\n\n   where *<message>* is the formatted message and *<system-message>* is\n   the system message corresponding to the error code.\n   *error_code* is a system error code as given by ``errno``.\n   If *error_code* is not a valid error code such as -1, the system message\n   may look like \"Unknown error -1\" and is platform-dependent.\n\n   **Example**::\n\n     // This throws a SystemError with the description\n     //   cannot open file 'madeup': No such file or directory\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     std::FILE *file = std::fopen(filename, \"r\");\n     if (!file)\n       throw fmt::SystemError(errno, \"cannot open file '{}'\", filename);\n   \\endrst\n  */\n  SystemError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_VARIADIC_CTOR(SystemError, init, int, CStringRef)\n\n  int error_code() const { return error_code_; }\n};\n\n/**\n  \\rst\n  This template provides operations for formatting and writing data into\n  a character stream. The output is stored in a buffer provided by a subclass\n  such as :class:`fmt::BasicMemoryWriter`.\n\n  You can use one of the following typedefs for common character types:\n\n  +---------+----------------------+\n  | Type    | Definition           |\n  +=========+======================+\n  | Writer  | BasicWriter<char>    |\n  +---------+----------------------+\n  | WWriter | BasicWriter<wchar_t> |\n  +---------+----------------------+\n\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicWriter {\n private:\n  // Output buffer.\n  Buffer<Char> &buffer_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicWriter);\n\n  typedef typename internal::CharTraits<Char>::CharPtr CharPtr;\n\n#if FMT_SECURE_SCL\n  // Returns pointer value.\n  static Char *get(CharPtr p) { return p.base(); }\n#else\n  static Char *get(Char *p) { return p; }\n#endif\n\n  // Fills the padding around the content and returns the pointer to the\n  // content area.\n  static CharPtr fill_padding(CharPtr buffer,\n      unsigned total_size, std::size_t content_size, wchar_t fill);\n\n  // Grows the buffer by n characters and returns a pointer to the newly\n  // allocated area.\n  CharPtr grow_buffer(std::size_t n) {\n    std::size_t size = buffer_.size();\n    buffer_.resize(size + n);\n    return internal::make_ptr(&buffer_[size], n);\n  }\n\n  // Writes an unsigned decimal integer.\n  template <typename UInt>\n  Char *write_unsigned_decimal(UInt value, unsigned prefix_size = 0) {\n    unsigned num_digits = internal::count_digits(value);\n    Char *ptr = get(grow_buffer(prefix_size + num_digits));\n    internal::format_decimal(ptr + prefix_size, value, num_digits);\n    return ptr;\n  }\n\n  // Writes a decimal integer.\n  template <typename Int>\n  void write_decimal(Int value) {\n    typename internal::IntTraits<Int>::MainType abs_value = value;\n    if (internal::is_negative(value)) {\n      abs_value = 0 - abs_value;\n      *write_unsigned_decimal(abs_value, 1) = '-';\n    } else {\n      write_unsigned_decimal(abs_value, 0);\n    }\n  }\n\n  // Prepare a buffer for integer formatting.\n  CharPtr prepare_int_buffer(unsigned num_digits,\n      const EmptySpec &, const char *prefix, unsigned prefix_size) {\n    unsigned size = prefix_size + num_digits;\n    CharPtr p = grow_buffer(size);\n    std::copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n\n  template <typename Spec>\n  CharPtr prepare_int_buffer(unsigned num_digits,\n    const Spec &spec, const char *prefix, unsigned prefix_size);\n\n  // Formats an integer.\n  template <typename T, typename Spec>\n  void write_int(T value, Spec spec);\n\n  // Formats a floating-point number (double or long double).\n  template <typename T>\n  void write_double(T value, const FormatSpec &spec);\n\n  // Writes a formatted string.\n  template <typename StrChar>\n  CharPtr write_str(\n      const StrChar *s, std::size_t size, const AlignSpec &spec);\n\n  template <typename StrChar>\n  void write_str(\n      const internal::Arg::StringValue<StrChar> &str, const FormatSpec &spec);\n\n  // This following methods are private to disallow writing wide characters\n  // and strings to a char stream. If you want to print a wide string as a\n  // pointer as std::ostream does, cast it to const void*.\n  // Do not implement!\n  void operator<<(typename internal::WCharHelper<wchar_t, Char>::Unsupported);\n  void operator<<(\n      typename internal::WCharHelper<const wchar_t *, Char>::Unsupported);\n\n  // Appends floating-point length specifier to the format string.\n  // The second argument is only used for overload resolution.\n  void append_float_length(Char *&format_ptr, long double) {\n    *format_ptr++ = 'L';\n  }\n\n  template<typename T>\n  void append_float_length(Char *&, T) {}\n\n  template <typename Impl, typename Char_>\n  friend class internal::BasicArgFormatter;\n\n  friend class internal::PrintfArgFormatter<Char>;\n\n protected:\n  /**\n    Constructs a ``BasicWriter`` object.\n   */\n  explicit BasicWriter(Buffer<Char> &b) : buffer_(b) {}\n\n public:\n  /**\n    \\rst\n    Destroys a ``BasicWriter`` object.\n    \\endrst\n   */\n  virtual ~BasicWriter() {}\n\n  /**\n    Returns the total number of characters written.\n   */\n  std::size_t size() const { return buffer_.size(); }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const Char *data() const FMT_NOEXCEPT { return &buffer_[0]; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const Char *c_str() const {\n    std::size_t size = buffer_.size();\n    buffer_.reserve(size + 1);\n    buffer_[size] = '\\0';\n    return &buffer_[0];\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an `std::string`.\n    \\endrst\n   */\n  std::basic_string<Char> str() const {\n    return std::basic_string<Char>(&buffer_[0], buffer_.size());\n  }\n\n  /**\n    \\rst\n    Writes formatted data.\n\n    *args* is an argument list representing arbitrary arguments.\n\n    **Example**::\n\n       MemoryWriter out;\n       out.write(\"Current point:\\n\");\n       out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n    This will write the following output to the ``out`` object:\n\n    .. code-block:: none\n\n       Current point:\n       (-3.140000, +3.140000)\n\n    The output can be accessed using :func:`data()`, :func:`c_str` or\n    :func:`str` methods.\n\n    See also :ref:`syntax`.\n    \\endrst\n   */\n  void write(BasicCStringRef<Char> format, ArgList args) {\n    BasicFormatter<Char>(args, *this).format(format);\n  }\n  FMT_VARIADIC_VOID(write, BasicCStringRef<Char>)\n\n  BasicWriter &operator<<(int value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned value) {\n    return *this << IntFormatSpec<unsigned>(value);\n  }\n  BasicWriter &operator<<(long value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned long value) {\n    return *this << IntFormatSpec<unsigned long>(value);\n  }\n  BasicWriter &operator<<(LongLong value) {\n    write_decimal(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(ULongLong value) {\n    return *this << IntFormatSpec<ULongLong>(value);\n  }\n\n  BasicWriter &operator<<(double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* using the general format for floating-point numbers\n    (``'g'``) and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(long double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    Writes a character to the stream.\n   */\n  BasicWriter &operator<<(char value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<wchar_t, Char>::Supported value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Writes *value* to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(fmt::BasicStringRef<Char> value) {\n    const Char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<StringRef, Char>::Supported value) {\n    const char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  template <typename T, typename Spec, typename FillChar>\n  BasicWriter &operator<<(IntFormatSpec<T, Spec, FillChar> spec) {\n    internal::CharTraits<Char>::convert(FillChar());\n    write_int(spec.value(), spec);\n    return *this;\n  }\n\n  template <typename StrChar>\n  BasicWriter &operator<<(const StrFormatSpec<StrChar> &spec) {\n    const StrChar *s = spec.str();\n    write_str(s, std::char_traits<Char>::length(s), spec);\n    return *this;\n  }\n\n  void clear() FMT_NOEXCEPT { buffer_.clear(); }\n};\n\ntemplate <typename Char>\ntemplate <typename StrChar>\ntypename BasicWriter<Char>::CharPtr BasicWriter<Char>::write_str(\n      const StrChar *s, std::size_t size, const AlignSpec &spec) {\n  CharPtr out = CharPtr();\n  if (spec.width() > size) {\n    out = grow_buffer(spec.width());\n    Char fill = internal::CharTraits<Char>::cast(spec.fill());\n    if (spec.align() == ALIGN_RIGHT) {\n      std::fill_n(out, spec.width() - size, fill);\n      out += spec.width() - size;\n    } else if (spec.align() == ALIGN_CENTER) {\n      out = fill_padding(out, spec.width(), size, fill);\n    } else {\n      std::fill_n(out + size, spec.width() - size, fill);\n    }\n  } else {\n    out = grow_buffer(size);\n  }\n  std::copy(s, s + size, out);\n  return out;\n}\n\ntemplate <typename Char>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::fill_padding(\n    CharPtr buffer, unsigned total_size,\n    std::size_t content_size, wchar_t fill) {\n  std::size_t padding = total_size - content_size;\n  std::size_t left_padding = padding / 2;\n  Char fill_char = internal::CharTraits<Char>::cast(fill);\n  std::fill_n(buffer, left_padding, fill_char);\n  buffer += left_padding;\n  CharPtr content = buffer;\n  std::fill_n(buffer + content_size, padding - left_padding, fill_char);\n  return content;\n}\n\ntemplate <typename Char>\ntemplate <typename Spec>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    // Octal prefix '0' is counted as a digit, so ignore it if precision\n    // is specified.\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size = prefix_size + spec.precision();\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}\n\ntemplate <typename Char>\ntemplate <typename T, typename Spec>\nvoid BasicWriter<Char>::write_int(T value, Spec spec) {\n  unsigned prefix_size = 0;\n  typedef typename internal::IntTraits<T>::MainType UnsignedType;\n  UnsignedType abs_value = value;\n  char prefix[4] = \"\";\n  if (internal::is_negative(value)) {\n    prefix[0] = '-';\n    ++prefix_size;\n    abs_value = 0 - abs_value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';\n    ++prefix_size;\n  }\n  switch (spec.type()) {\n  case 0: case 'd': {\n    unsigned num_digits = internal::count_digits(abs_value);\n    CharPtr p = prepare_int_buffer(\n      num_digits, spec, prefix, prefix_size) + 1 - num_digits;\n    internal::format_decimal(get(p), abs_value, num_digits);\n    break;\n  }\n  case 'x': case 'X': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 4) != 0);\n    Char *p = get(prepare_int_buffer(\n      num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    const char *digits = spec.type() == 'x' ?\n        \"0123456789abcdef\" : \"0123456789ABCDEF\";\n    do {\n      *p-- = digits[n & 0xf];\n    } while ((n >>= 4) != 0);\n    break;\n  }\n  case 'b': case 'B': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 1) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = '0' + (n & 1);\n    } while ((n >>= 1) != 0);\n    break;\n  }\n  case 'o': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG))\n      prefix[prefix_size++] = '0';\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 3) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = '0' + (n & 7);\n    } while ((n >>= 3) != 0);\n    break;\n  }\n  default:\n    internal::report_unknown_type(\n      spec.type(), spec.flag(CHAR_FLAG) ? \"char\" : \"integer\");\n    break;\n  }\n}\n\ntemplate <typename Char>\ntemplate <typename T>\nvoid BasicWriter<Char>::write_double(\n    T value, const FormatSpec &spec) {\n  // Check type.\n  char type = spec.type();\n  bool upper = false;\n  switch (type) {\n  case 0:\n    type = 'g';\n    break;\n  case 'e': case 'f': case 'g': case 'a':\n    break;\n  case 'F':\n#ifdef _MSC_VER\n    // MSVC's printf doesn't support 'F'.\n    type = 'f';\n#endif\n    // Fall through.\n  case 'E': case 'G': case 'A':\n    upper = true;\n    break;\n  default:\n    internal::report_unknown_type(type, \"double\");\n    break;\n  }\n\n  char sign = 0;\n  // Use getsign instead of value < 0 because the latter is always\n  // false for NaN.\n  if (internal::getsign(static_cast<double>(value))) {\n    sign = '-';\n    value = -value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';\n  }\n\n  if (internal::isnotanumber(value)) {\n    // Format NaN ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t nan_size = 4;\n    const char *nan = upper ? \" NAN\" : \" nan\";\n    if (!sign) {\n      --nan_size;\n      ++nan;\n    }\n    CharPtr out = write_str(nan, nan_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  if (internal::isinfinity(value)) {\n    // Format infinity ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t inf_size = 4;\n    const char *inf = upper ? \" INF\" : \" inf\";\n    if (!sign) {\n      --inf_size;\n      ++inf;\n    }\n    CharPtr out = write_str(inf, inf_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  std::size_t offset = buffer_.size();\n  unsigned width = spec.width();\n  if (sign) {\n    buffer_.reserve(buffer_.size() + (std::max)(width, 1u));\n    if (width > 0)\n      --width;\n    ++offset;\n  }\n\n  // Build format string.\n  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg\n  Char format[MAX_FORMAT_SIZE];\n  Char *format_ptr = format;\n  *format_ptr++ = '%';\n  unsigned width_for_sprintf = width;\n  if (spec.flag(HASH_FLAG))\n    *format_ptr++ = '#';\n  if (spec.align() == ALIGN_CENTER) {\n    width_for_sprintf = 0;\n  } else {\n    if (spec.align() == ALIGN_LEFT)\n      *format_ptr++ = '-';\n    if (width != 0)\n      *format_ptr++ = '*';\n  }\n  if (spec.precision() >= 0) {\n    *format_ptr++ = '.';\n    *format_ptr++ = '*';\n  }\n\n  append_float_length(format_ptr, value);\n  *format_ptr++ = type;\n  *format_ptr = '\\0';\n\n  // Format using snprintf.\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  for (;;) {\n    std::size_t buffer_size = buffer_.capacity() - offset;\n#ifdef _MSC_VER\n    // MSVC's vsnprintf_s doesn't work with zero size, so reserve\n    // space for at least one extra character to make the size non-zero.\n    // Note that the buffer's capacity will increase by more than 1.\n    if (buffer_size == 0) {\n      buffer_.reserve(offset + 1);\n      buffer_size = buffer_.capacity() - offset;\n    }\n#endif\n    Char *start = &buffer_[offset];\n    int n = internal::CharTraits<Char>::format_float(\n        start, buffer_size, format, width_for_sprintf, spec.precision(), value);\n    if (n >= 0 && offset + n < buffer_.capacity()) {\n      if (sign) {\n        if ((spec.align() != ALIGN_RIGHT && spec.align() != ALIGN_DEFAULT) ||\n            *start != ' ') {\n          *(start - 1) = sign;\n          sign = 0;\n        } else {\n          *(start - 1) = fill;\n        }\n        ++n;\n      }\n      if (spec.align() == ALIGN_CENTER &&\n          spec.width() > static_cast<unsigned>(n)) {\n        width = spec.width();\n        CharPtr p = grow_buffer(width);\n        std::copy(p, p + n, p + (width - n) / 2);\n        fill_padding(p, spec.width(), n, fill);\n        return;\n      }\n      if (spec.fill() != ' ' || sign) {\n        while (*start == ' ')\n          *start++ = fill;\n        if (sign)\n          *(start - 1) = sign;\n      }\n      grow_buffer(n);\n      return;\n    }\n    // If n is negative we ask to increase the capacity by at least 1,\n    // but as std::vector, the buffer grows exponentially.\n    buffer_.reserve(n >= 0 ? offset + n + 1 : buffer_.capacity() + 1);\n  }\n}\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a character stream. The output is stored in a memory buffer that grows\n  dynamically.\n\n  You can use one of the following typedefs for common character types\n  and the standard allocator:\n\n  +---------------+-----------------------------------------------------+\n  | Type          | Definition                                          |\n  +===============+=====================================================+\n  | MemoryWriter  | BasicMemoryWriter<char, std::allocator<char>>       |\n  +---------------+-----------------------------------------------------+\n  | WMemoryWriter | BasicMemoryWriter<wchar_t, std::allocator<wchar_t>> |\n  +---------------+-----------------------------------------------------+\n\n  **Example**::\n\n     MemoryWriter out;\n     out << \"The answer is \" << 42 << \"\\n\";\n     out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n  This will write the following output to the ``out`` object:\n\n  .. code-block:: none\n\n     The answer is 42\n     (-3.140000, +3.140000)\n\n  The output can be converted to an ``std::string`` with ``out.str()`` or\n  accessed as a C string with ``out.c_str()``.\n  \\endrst\n */\ntemplate <typename Char, typename Allocator = std::allocator<Char> >\nclass BasicMemoryWriter : public BasicWriter<Char> {\n private:\n  internal::MemoryBuffer<Char, internal::INLINE_BUFFER_SIZE, Allocator> buffer_;\n\n public:\n  explicit BasicMemoryWriter(const Allocator& alloc = Allocator())\n    : BasicWriter<Char>(buffer_), buffer_(alloc) {}\n\n#if FMT_USE_RVALUE_REFERENCES\n  /**\n    \\rst\n    Constructs a :class:`fmt::BasicMemoryWriter` object moving the content\n    of the other object to it.\n    \\endrst\n   */\n  BasicMemoryWriter(BasicMemoryWriter &&other)\n    : BasicWriter<Char>(buffer_), buffer_(std::move(other.buffer_)) {\n  }\n\n  /**\n    \\rst\n    Moves the content of the other ``BasicMemoryWriter`` object to this one.\n    \\endrst\n   */\n  BasicMemoryWriter &operator=(BasicMemoryWriter &&other) {\n    buffer_ = std::move(other.buffer_);\n    return *this;\n  }\n#endif\n};\n\ntypedef BasicMemoryWriter<char> MemoryWriter;\ntypedef BasicMemoryWriter<wchar_t> WMemoryWriter;\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a fixed-size array. For writing into a dynamically growing buffer\n  use :class:`fmt::BasicMemoryWriter`.\n\n  Any write method will throw ``std::runtime_error`` if the output doesn't fit\n  into the array.\n\n  You can use one of the following typedefs for common character types:\n\n  +--------------+---------------------------+\n  | Type         | Definition                |\n  +==============+===========================+\n  | ArrayWriter  | BasicArrayWriter<char>    |\n  +--------------+---------------------------+\n  | WArrayWriter | BasicArrayWriter<wchar_t> |\n  +--------------+---------------------------+\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicArrayWriter : public BasicWriter<Char> {\n private:\n  internal::FixedBuffer<Char> buffer_;\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   given size.\n   \\endrst\n   */\n  BasicArrayWriter(Char *array, std::size_t size)\n    : BasicWriter<Char>(buffer_), buffer_(array, size) {}\n\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   size known at compile time.\n   \\endrst\n   */\n  template <std::size_t SIZE>\n  explicit BasicArrayWriter(Char (&array)[SIZE])\n    : BasicWriter<Char>(buffer_), buffer_(array, SIZE) {}\n};\n\ntypedef BasicArrayWriter<char> ArrayWriter;\ntypedef BasicArrayWriter<wchar_t> WArrayWriter;\n\n// Formats a value.\ntemplate <typename Char, typename T>\nvoid format(BasicFormatter<Char> &f, const Char *&format_str, const T &value) {\n  std::basic_ostringstream<Char> os;\n  os << value;\n  std::basic_string<Char> str = os.str();\n  internal::Arg arg = internal::MakeValue<Char>(str);\n  arg.type = static_cast<internal::Arg::Type>(\n        internal::MakeValue<Char>::type(str));\n  format_str = f.format(format_str, arg);\n}\n\n// Reports a system error without throwing an exception.\n// Can be used to report errors from destructors.\nvoid report_system_error(int error_code, StringRef message) FMT_NOEXCEPT;\n\n#if FMT_USE_WINDOWS_H\n\n/** A Windows error. */\nclass WindowsError : public SystemError {\n private:\n  void init(int error_code, CStringRef format_str, ArgList args);\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::WindowsError` object with the description\n   of the form\n\n   .. parsed-literal::\n     *<message>*: *<system-message>*\n\n   where *<message>* is the formatted message and *<system-message>* is the\n   system message corresponding to the error code.\n   *error_code* is a Windows error code as given by ``GetLastError``.\n   If *error_code* is not a valid error code such as -1, the system message\n   will look like \"error -1\".\n\n   **Example**::\n\n     // This throws a WindowsError with the description\n     //   cannot open file 'madeup': The system cannot find the file specified.\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     LPOFSTRUCT of = LPOFSTRUCT();\n     HFILE file = OpenFile(filename, &of, OF_READ);\n     if (file == HFILE_ERROR) {\n       throw fmt::WindowsError(GetLastError(),\n                               \"cannot open file '{}'\", filename);\n     }\n   \\endrst\n  */\n  WindowsError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_VARIADIC_CTOR(WindowsError, init, int, CStringRef)\n};\n\n// Reports a Windows error without throwing an exception.\n// Can be used to report errors from destructors.\nvoid report_windows_error(int error_code, StringRef message) FMT_NOEXCEPT;\n\n#endif\n\nenum Color { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE };\n\n/**\n  Formats a string and prints it to stdout using ANSI escape sequences\n  to specify color (experimental).\n  Example:\n    PrintColored(fmt::RED, \"Elapsed time: {0:.2f} seconds\") << 1.23;\n */\nvoid print_colored(Color c, CStringRef format, ArgList args);\n\n/**\n  \\rst\n  Formats arguments and returns the result as a string.\n\n  **Example**::\n\n    std::string message = format(\"The answer is {}\", 42);\n  \\endrst\n*/\ninline std::string format(CStringRef format_str, ArgList args) {\n  MemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\ninline std::wstring format(WCStringRef format_str, ArgList args) {\n  WMemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\n/**\n  \\rst\n  Prints formatted data to the file *f*.\n\n  **Example**::\n\n    print(stderr, \"Don't {}!\", \"panic\");\n  \\endrst\n */\nvoid print(std::FILE *f, CStringRef format_str, ArgList args);\n\n/**\n  \\rst\n  Prints formatted data to ``stdout``.\n\n  **Example**::\n\n    print(\"Elapsed time: {0:.2f} seconds\", 1.23);\n  \\endrst\n */\nvoid print(CStringRef format_str, ArgList args);\n\ntemplate <typename Char>\nvoid printf(BasicWriter<Char> &w, BasicCStringRef<Char> format, ArgList args) {\n  internal::PrintfFormatter<Char>(args).format(w, format);\n}\n\n/**\n  \\rst\n  Formats arguments and returns the result as a string.\n\n  **Example**::\n\n    std::string message = fmt::sprintf(\"The answer is %d\", 42);\n  \\endrst\n*/\ninline std::string sprintf(CStringRef format, ArgList args) {\n  MemoryWriter w;\n  printf(w, format, args);\n  return w.str();\n}\n\ninline std::wstring sprintf(WCStringRef format, ArgList args) {\n  WMemoryWriter w;\n  printf(w, format, args);\n  return w.str();\n}\n\n/**\n  \\rst\n  Prints formatted data to the file *f*.\n\n  **Example**::\n\n    fmt::fprintf(stderr, \"Don't %s!\", \"panic\");\n  \\endrst\n */\nint fprintf(std::FILE *f, CStringRef format, ArgList args);\n\n/**\n  \\rst\n  Prints formatted data to ``stdout``.\n\n  **Example**::\n\n    fmt::printf(\"Elapsed time: %.2f seconds\", 1.23);\n  \\endrst\n */\ninline int printf(CStringRef format, ArgList args) {\n  return fprintf(stdout, format, args);\n}\n\n/**\n  Fast integer formatter.\n */\nclass FormatInt {\n private:\n  // Buffer should be large enough to hold all digits (digits10 + 1),\n  // a sign and a null character.\n  enum {BUFFER_SIZE = std::numeric_limits<ULongLong>::digits10 + 3};\n  mutable char buffer_[BUFFER_SIZE];\n  char *str_;\n\n  // Formats value in reverse and returns the number of digits.\n  char *format_decimal(ULongLong value) {\n    char *buffer_end = buffer_ + BUFFER_SIZE - 1;\n    while (value >= 100) {\n      // Integer division is slow so do it for a group of two digits instead\n      // of for every digit. The idea comes from the talk by Alexandrescu\n      // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n      unsigned index = (value % 100) * 2;\n      value /= 100;\n      *--buffer_end = internal::Data::DIGITS[index + 1];\n      *--buffer_end = internal::Data::DIGITS[index];\n    }\n    if (value < 10) {\n      *--buffer_end = static_cast<char>('0' + value);\n      return buffer_end;\n    }\n    unsigned index = static_cast<unsigned>(value * 2);\n    *--buffer_end = internal::Data::DIGITS[index + 1];\n    *--buffer_end = internal::Data::DIGITS[index];\n    return buffer_end;\n  }\n\n  void FormatSigned(LongLong value) {\n    ULongLong abs_value = static_cast<ULongLong>(value);\n    bool negative = value < 0;\n    if (negative)\n      abs_value = 0 - abs_value;\n    str_ = format_decimal(abs_value);\n    if (negative)\n      *--str_ = '-';\n  }\n\n public:\n  explicit FormatInt(int value) { FormatSigned(value); }\n  explicit FormatInt(long value) { FormatSigned(value); }\n  explicit FormatInt(LongLong value) { FormatSigned(value); }\n  explicit FormatInt(unsigned value) : str_(format_decimal(value)) {}\n  explicit FormatInt(unsigned long value) : str_(format_decimal(value)) {}\n  explicit FormatInt(ULongLong value) : str_(format_decimal(value)) {}\n\n  /**\n    Returns the number of characters written to the output buffer.\n   */\n  std::size_t size() const { return buffer_ - str_ + BUFFER_SIZE - 1; }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const char *data() const { return str_; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const char *c_str() const {\n    buffer_[BUFFER_SIZE - 1] = '\\0';\n    return str_;\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an ``std::string``.\n    \\endrst\n   */\n  std::string str() const { return std::string(str_, size()); }\n};\n\n// Formats a decimal integer value writing into buffer and returns\n// a pointer to the end of the formatted string. This function doesn't\n// write a terminating null character.\ntemplate <typename T>\ninline void format_decimal(char *&buffer, T value) {\n  typename internal::IntTraits<T>::MainType abs_value = value;\n  if (internal::is_negative(value)) {\n    *buffer++ = '-';\n    abs_value = 0 - abs_value;\n  }\n  if (abs_value < 100) {\n    if (abs_value < 10) {\n      *buffer++ = static_cast<char>('0' + abs_value);\n      return;\n    }\n    unsigned index = static_cast<unsigned>(abs_value * 2);\n    *buffer++ = internal::Data::DIGITS[index];\n    *buffer++ = internal::Data::DIGITS[index + 1];\n    return;\n  }\n  unsigned num_digits = internal::count_digits(abs_value);\n  internal::format_decimal(buffer, abs_value, num_digits);\n  buffer += num_digits;\n}\n\n/**\n  \\rst\n  Returns a named argument for formatting functions.\n\n  **Example**::\n\n    print(\"Elapsed time: {s:.2f} seconds\", arg(\"s\", 1.23));\n\n  \\endrst\n */\ntemplate <typename T>\ninline internal::NamedArg<char> arg(StringRef name, const T &arg) {\n  return internal::NamedArg<char>(name, arg);\n}\n\ntemplate <typename T>\ninline internal::NamedArg<wchar_t> arg(WStringRef name, const T &arg) {\n  return internal::NamedArg<wchar_t>(name, arg);\n}\n\n// The following two functions are deleted intentionally to disable\n// nested named arguments as in ``format(\"{}\", arg(\"a\", arg(\"b\", 42)))``.\ntemplate <typename Char>\nvoid arg(StringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\ntemplate <typename Char>\nvoid arg(WStringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\n}\n\n#if FMT_GCC_VERSION\n// Use the system_header pragma to suppress warnings about variadic macros\n// because suppressing -Wvariadic-macros with the diagnostic pragma doesn't\n// work. It is used at the end because we want to suppress as little warnings\n// as possible.\n# pragma GCC system_header\n#endif\n\n// This is used to work around VC++ bugs in handling variadic macros.\n#define FMT_EXPAND(args) args\n\n// Returns the number of arguments.\n// Based on https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s.\n#define FMT_NARG(...) FMT_NARG_(__VA_ARGS__, FMT_RSEQ_N())\n#define FMT_NARG_(...) FMT_EXPAND(FMT_ARG_N(__VA_ARGS__))\n#define FMT_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define FMT_RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n#define FMT_CONCAT(a, b) a##b\n#define FMT_FOR_EACH_(N, f, ...) \\\n  FMT_EXPAND(FMT_CONCAT(FMT_FOR_EACH, N)(f, __VA_ARGS__))\n#define FMT_FOR_EACH(f, ...) \\\n  FMT_EXPAND(FMT_FOR_EACH_(FMT_NARG(__VA_ARGS__), f, __VA_ARGS__))\n\n#define FMT_ADD_ARG_NAME(type, index) type arg##index\n#define FMT_GET_ARG_NAME(type, index) arg##index\n\n#if FMT_USE_VARIADIC_TEMPLATES\n# define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \\\n  template <typename... Args> \\\n  ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      const Args & ... args) { \\\n    typename fmt::internal::ArgArray<sizeof...(Args)>::Type array; \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \\\n      fmt::internal::make_arg_list<Char>(array, args...)); \\\n  }\n#else\n// Defines a wrapper for a function taking __VA_ARGS__ arguments\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP(Char, ReturnType, func, call, n, ...) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    fmt::internal::ArgArray<n>::Type arr = {FMT_GEN(n, FMT_MAKE_REF_##Char)}; \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), arr)); \\\n  }\n\n# define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__)) { \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList()); \\\n  } \\\n  FMT_WRAP(Char, ReturnType, func, call, 1, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 2, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 3, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 4, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 5, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 6, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 7, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 8, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 9, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 10, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 11, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 12, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 13, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 14, __VA_ARGS__) \\\n  FMT_WRAP(Char, ReturnType, func, call, 15, __VA_ARGS__)\n#endif  // FMT_USE_VARIADIC_TEMPLATES\n\n/**\n  \\rst\n  Defines a variadic function with the specified return type, function name\n  and argument types passed as variable arguments to this macro.\n\n  **Example**::\n\n    void print_error(const char *file, int line, const char *format,\n                     fmt::ArgList args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args);\n    }\n    FMT_VARIADIC(void, print_error, const char *, int, const char *)\n\n  ``FMT_VARIADIC`` is used for compatibility with legacy C++ compilers that\n  don't implement variadic templates. You don't have to use this macro if\n  you don't need legacy compiler support and can use variadic templates\n  directly::\n\n    template <typename... Args>\n    void print_error(const char *file, int line, const char *format,\n                     const Args & ... args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args...);\n    }\n  \\endrst\n */\n#define FMT_VARIADIC(ReturnType, func, ...) \\\n  FMT_VARIADIC_(char, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_W(ReturnType, func, ...) \\\n  FMT_VARIADIC_(wchar_t, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_CAPTURE_ARG_(id, index) ::fmt::arg(#id, id)\n\n#define FMT_CAPTURE_ARG_W_(id, index) ::fmt::arg(L###id, id)\n\n/**\n  \\rst\n  Convenient macro to capture the arguments' names and values into several\n  ``fmt::arg(name, value)``.\n\n  **Example**::\n\n    int x = 1, y = 2;\n    print(\"point: ({x}, {y})\", FMT_CAPTURE(x, y));\n    // same as:\n    // print(\"point: ({x}, {y})\", arg(\"x\", x), arg(\"y\", y));\n\n  \\endrst\n */\n#define FMT_CAPTURE(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_, __VA_ARGS__)\n\n#define FMT_CAPTURE_W(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_W_, __VA_ARGS__)\n\nnamespace fmt {\nFMT_VARIADIC(std::string, format, CStringRef)\nFMT_VARIADIC_W(std::wstring, format, WCStringRef)\nFMT_VARIADIC(void, print, CStringRef)\nFMT_VARIADIC(void, print, std::FILE *, CStringRef)\n\nFMT_VARIADIC(void, print_colored, Color, CStringRef)\nFMT_VARIADIC(std::string, sprintf, CStringRef)\nFMT_VARIADIC_W(std::wstring, sprintf, WCStringRef)\nFMT_VARIADIC(int, printf, CStringRef)\nFMT_VARIADIC(int, fprintf, std::FILE *, CStringRef)\n\n#if FMT_USE_IOSTREAMS\n/**\n  \\rst\n  Prints formatted data to the stream *os*.\n\n  **Example**::\n\n    print(cerr, \"Don't {}!\", \"panic\");\n  \\endrst\n */\nvoid print(std::ostream &os, CStringRef format_str, ArgList args);\nFMT_VARIADIC(void, print, std::ostream &, CStringRef)\n#endif\n}  // namespace fmt\n\n#if FMT_USE_USER_DEFINED_LITERALS\nnamespace fmt {\nnamespace internal {\n\ntemplate <typename Char>\nstruct UdlFormat {\n  const Char *str;\n\n  template <typename... Args>\n  auto operator()(Args && ... args) const\n                  -> decltype(format(str, std::forward<Args>(args)...)) {\n    return format(str, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename Char>\nstruct UdlArg {\n  const Char *str;\n\n  template <typename T>\n  NamedArg<Char> operator=(T &&value) const {\n    return {str, std::forward<T>(value)};\n  }\n};\n\n} // namespace internal\n\ninline namespace literals {\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::format`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    std::string message = \"The answer is {}\"_format(42);\n  \\endrst\n */\ninline internal::UdlFormat<char>\noperator\"\" _format(const char *s, std::size_t) { return {s}; }\ninline internal::UdlFormat<wchar_t>\noperator\"\" _format(const wchar_t *s, std::size_t) { return {s}; }\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::arg`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    print(\"Elapsed time: {s:.2f} seconds\", \"s\"_a=1.23);\n  \\endrst\n */\ninline internal::UdlArg<char>\noperator\"\" _a(const char *s, std::size_t) { return {s}; }\ninline internal::UdlArg<wchar_t>\noperator\"\" _a(const wchar_t *s, std::size_t) { return {s}; }\n\n} // inline namespace literals\n} // namespace fmt\n#endif // FMT_USE_USER_DEFINED_LITERALS\n\n}  // namespace blackhole\n\n// Restore warnings.\n#if FMT_GCC_VERSION >= 406\n# pragma GCC diagnostic pop\n#endif\n\n#ifdef __clang__\n# pragma clang diagnostic pop\n#endif\n\n#ifdef FMT_HEADER_ONLY\n# include \"format.cc\"\n#endif\n\n#endif  // FMT_FORMAT_H_\n"
      },
      {
        "filename": "include/blackhole/extensions/writer.hpp",
        "code": "#pragma once\n\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/extensions/format.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\n/// Represents stream writer backed up by cppformat.\nclass writer_t {\npublic:\n    fmt::MemoryWriter inner;\n\n    /// Formats the given arguments using the underlying formatter.\n    template<typename... Args>\n    inline auto write(const Args&... args) -> void {\n        inner.write(args...);\n    }\n\n    auto result() const noexcept -> string_view {\n        return string_view(inner.data(), inner.size());\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/record.hpp",
        "code": "#pragma once\n\n#include <chrono>\n#include <cstdint>\n#include <thread>\n\n#include \"blackhole/attributes.hpp\"\n#include \"blackhole/cpp17/string_view.hpp\"\n#include \"blackhole/severity.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\n\nusing cpp17::string_view;\n\nclass record_t {\npublic:\n    typedef std::chrono::system_clock clock_type;\n    typedef clock_type::time_point time_point;\n\nprivate:\n    struct inner_t;\n\n    typedef std::aligned_storage<64>::type storage_type;\n    storage_type storage;\n\npublic:\n    /// Creates a log record with the given severity, possibly unformatted message and attributes.\n    ///\n    /// The created record contains almost all information about the logging event associated except\n    /// the timestamp and formatted message.\n    ///\n    /// These missing attributes are set right after filtering pass with `activate` method.\n    ///\n    /// \\warning constructing from rvalue references is explicitly forbidden, specified objects must\n    ///     outlive the record created.\n    record_t(severity_t severity,\n        std::reference_wrapper<const string_view> message,\n        std::reference_wrapper<const attribute_pack> attributes);\n\n    auto message() const noexcept -> const string_view&;\n    auto severity() const noexcept -> severity_t;\n    auto timestamp() const noexcept -> time_point;\n\n    auto pid() const noexcept -> std::uint64_t;\n    auto tid() const noexcept -> std::thread::native_handle_type;\n\n    auto formatted() const noexcept -> const string_view&;\n    auto attributes() const noexcept -> const attribute_pack&;\n\n    /// Activate the record by setting the given formatted message accompanied by obtaining and\n    /// setting the current time point.\n    auto activate(const string_view& formatted = string_view()) noexcept -> void;\n\nprivate:\n    auto inner() noexcept -> inner_t&;\n    auto inner() const noexcept -> const inner_t&;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/attribute.hpp",
        "code": "#pragma once\n\n#include <boost/variant/variant.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace attribute {\n\nstruct value_t::inner_t {\n    typedef boost::make_variant_over<value_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\nstruct view_t::inner_t {\n    typedef boost::make_variant_over<view_t::types>::type type;\n\n    type value;\n\n    template<typename T>\n    inner_t(T&& value) : value(std::forward<T>(value)) {}\n};\n\n}  // namespace attribute\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/formatter/string/parser.hpp",
        "code": "#pragma once\n\n#include <memory>\n#include <string>\n#include <unordered_map>\n\n#include <boost/optional/optional.hpp>\n\n#include \"blackhole/detail/formatter/string/error.hpp\"\n#include \"blackhole/detail/formatter/string/token.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace detail {\nnamespace formatter {\nnamespace string {\n\nclass factory_t;\n\nclass parser_t {\npublic:\n    typedef char char_type;\n    typedef std::basic_string<char_type> string_type;\n\nprivate:\n    typedef string_type::const_iterator const_iterator;\n\n    enum class state_t {\n        /// Undetermined state.\n        unknown,\n        /// Parsing literal.\n        literal,\n        /// Parsing placeholder.\n        placeholder,\n        /// Parser is broken.\n        broken\n    };\n\n    state_t state;\n\n    const std::string pattern;\n    const_iterator pos;\n\n    std::unordered_map<std::string, std::shared_ptr<factory_t>> factories;\n\npublic:\n    explicit parser_t(std::string pattern);\n\n    auto next() -> boost::optional<token_t>;\n\nprivate:\n    auto parse_spec() -> std::string;\n    auto parse_unknown() -> boost::optional<token_t>;\n    auto parse_literal() -> literal_t;\n    auto parse_placeholder() -> token_t;\n\n    /// Returns `true` on exact match with the given range from the current position.\n    ///\n    /// The given range may be larger than `std::distance(pos, std::end(pattern))`.\n    template<typename Range>\n    auto exact(const Range& range) const -> bool;\n\n    /// Returns `true` on exact match with the given range and position.\n    ///\n    /// The given range may be larger than `std::distance(pos, std::end(pattern))`.\n    ///\n    /// \\overload\n    template<typename Range>\n    auto exact(const_iterator pos, const Range& range) const -> bool;\n\n    /// Marks the parser as broken and throws an exception\n    template<class Exception, class... Args>\n    __attribute__((noreturn)) auto throw_(Args&&... args) -> void;\n};\n\n}  // namespace string\n}  // namespace formatter\n}  // namespace detail\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/formatter/string/token.hpp",
        "code": "#pragma once\n\n#include <string>\n\n#include <boost/variant/variant_fwd.hpp>\n\n#include \"blackhole/detail/datetime.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace detail {\nnamespace formatter {\nnamespace string {\n\n/// Helper named structs for making eye-candy code.\nstruct id;\nstruct hex;\nstruct num;\nstruct name;\nstruct user;\nstruct required;\nstruct optional;\n\n/// Represents string literal.\nstruct literal_t {\n    std::string value;\n};\n\nnamespace placeholder {\n\ntemplate<typename T>\nstruct generic;\n\ntemplate<>\nstruct generic<required> {\n    std::string name;\n    std::string spec;\n\n    generic(std::string name);\n    generic(std::string name, std::string spec);\n};\n\ntemplate<>\nstruct generic<optional> : public generic<required> {\n    std::string prefix;\n    std::string suffix;\n\n    generic(std::string name);\n    generic(std::string name, std::string spec);\n    generic(generic<required> token, std::string prefix, std::string suffix);\n};\n\nstruct message_t {\n    std::string spec;\n\n    message_t();\n    message_t(std::string spec);\n};\n\ntemplate<typename T>\nstruct severity {\n    std::string spec;\n\n    severity();\n    severity(std::string spec);\n};\n\ntemplate<typename T>\nstruct timestamp;\n\ntemplate<>\nstruct timestamp<num> {\n    std::string spec;\n\n    timestamp();\n    timestamp(std::string spec);\n};\n\ntemplate<>\nstruct timestamp<user> {\n    std::string pattern;\n    std::string spec;\n    datetime::generator_t generator;\n\n    timestamp();\n    timestamp(std::string pattern, std::string spec);\n};\n\ntemplate<typename T>\nstruct process {\n    std::string spec;\n\n    process();\n    process(std::string spec);\n};\n\ntemplate<typename T>\nstruct thread {\n    std::string spec;\n\n    thread();\n    thread(std::string spec);\n};\n\ntemplate<>\nstruct thread<hex> {\n    std::string spec;\n\n    thread();\n    thread(std::string spec);\n};\n\nstruct leftover_t {\n    std::string name;\n\n    bool unique;\n    std::string prefix;\n    std::string suffix;\n    std::string pattern;\n    std::string separator;\n\n    leftover_t();\n    leftover_t(std::string name);\n    leftover_t(std::string name, bool unique, std::string prefix, std::string suffix,\n        std::string pattern, std::string separator);\n};\n\n}  // namespace placeholder\n\nnamespace ph = placeholder;\n\ntypedef boost::variant<\n    literal_t,\n    ph::generic<required>,\n    ph::generic<optional>,\n    ph::leftover_t,\n    ph::process<id>,\n    ph::process<name>,\n    ph::thread<id>,\n    ph::thread<hex>,\n    ph::thread<name>,\n    ph::message_t,\n    ph::severity<num>,\n    ph::severity<user>,\n    ph::timestamp<num>,\n    ph::timestamp<user>\n> token_t;\n\n}  // namespace string\n}  // namespace formatter\n}  // namespace detail\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/detail/procname.hpp",
        "code": "#pragma once\n\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace cpp17 {\n\ntemplate<typename Char, typename Traits> class basic_string_view;\ntypedef basic_string_view<char, std::char_traits<char>> string_view;\n\n}  // namespace cpp17\n\nnamespace detail {\n\nauto procname() -> cpp17::string_view;\n\n}  // namespace detail\n}  // namespace v1\n}  // namespace blackhole\n"
      }
    ],
    "unresolved_context": [],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -41,59 +41,7 @@\n \n }  // namespace\n \n-class token_t {\n-    string::token_t inner;\n-\n-public:\n-    token_t(string::token_t inner) :\n-        inner(std::move(inner))\n-    {}\n-\n-    auto operator*() const noexcept -> const string::token_t& {\n-        return inner;\n-    }\n-};\n-\n namespace {\n-\n-class transform_visitor_t : public boost::static_visitor<string::token_t> {\n-    const options_t& options;\n-\n-public:\n-    transform_visitor_t(const options_t& options) :\n-        options(options)\n-    {}\n-\n-    auto operator()(const ph::generic<required>& token) const -> string::token_t {\n-        const auto it = options.find(token.name);\n-\n-        if (it != options.end()) {\n-            const auto option = boost::get<option::optional_t>(it->second);\n-\n-            return ph::generic<optional>(token, option.prefix, option.suffix);\n-        }\n-\n-        return token;\n-    }\n-\n-    auto operator()(const ph::leftover_t& token) const -> string::token_t {\n-        const auto it = options.find(token.name);\n-\n-        if (it != options.end()) {\n-            const auto option = boost::get<option::leftover_t>(it->second);\n-\n-            return ph::leftover_t(token.name, option.unique, option.prefix, option.suffix,\n-                option.pattern, option.separator);\n-        }\n-\n-        return token;\n-    }\n-\n-    template<typename T>\n-    auto operator()(const T& token) const -> string::token_t {\n-        return token;\n-    }\n-};\n \n struct spec;\n struct unspec;\n@@ -302,19 +250,19 @@\n     }\n };\n \n-static auto tokenize(const std::string& pattern, const options_t& options) -> std::vector<token_t> {\n-    std::vector<token_t> tokens;\n-\n-    for (const auto& reserved : {\"process\", \"thread\", \"message\", \"severity\", \"timestamp\"}) {\n-        if (options.count(reserved) != 0) {\n-            throw std::logic_error(\"placeholder '\" + std::string(reserved) +\n-                \"' is reserved and can not be configured\");\n-        }\n-    }\n+auto tokenize(const std::string& pattern) -> std::vector<string::token_t> {\n+    std::vector<string::token_t> tokens;\n+    //\n+    // for (const auto& reserved : {\"process\", \"thread\", \"message\", \"severity\", \"timestamp\"}) {\n+    //     if (options.count(reserved) != 0) {\n+    //         throw std::logic_error(\"placeholder '\" + std::string(reserved) +\n+    //             \"' is reserved and can not be configured\");\n+    //     }\n+    // }\n \n     string::parser_t parser(pattern);\n     while (auto token = parser.next()) {\n-        tokens.emplace_back(boost::apply_visitor(transform_visitor_t(options), token.get()));\n+        tokens.emplace_back(token.get());\n     }\n \n     return tokens;\n@@ -322,42 +270,135 @@\n \n }  // namespace\n \n-string_t::string_t(std::string pattern, const options_t& options) :\n-    pattern(std::move(pattern)),\n-    sevmap([](int severity, const std::string& spec, writer_t& writer) {\n+class string_t::inner_t {\n+public:\n+    severity_map sevmap;\n+    std::vector<string::token_t> tokens;\n+};\n+\n+string_t::string_t(const std::string& pattern) :\n+    inner(new inner_t, [](inner_t* d) { delete d; })\n+{\n+    inner->sevmap = [](int severity, const std::string& spec, writer_t& writer) {\n         writer.write(spec, severity);\n-    }),\n-    tokens(tokenize(this->pattern, options))\n-{}\n-\n-string_t::string_t(std::string pattern, severity_map sevmap, const options_t& options) :\n-    pattern(std::move(pattern)),\n-    sevmap(std::move(sevmap)),\n-    tokens(tokenize(this->pattern, options))\n-{}\n-\n-string_t::string_t(string_t&& other) = default;\n-\n-string_t::~string_t() {}\n-\n-auto\n-string_t::format(const record_t& record, writer_t& writer) -> void {\n-    const visitor_t visitor(writer, record, sevmap);\n-\n-    for (const auto& token : tokens) {\n-        boost::apply_visitor(visitor, *token);\n+    };\n+\n+    inner->tokens = tokenize(pattern);\n+}\n+\n+string_t::string_t(const std::string& pattern, severity_map sevmap) :\n+    inner(new inner_t, [](inner_t* d) { delete d; })\n+{\n+    inner->sevmap = std::move(sevmap);\n+    inner->tokens = tokenize(pattern);\n+}\n+\n+struct option_visitor {\n+    typedef boost::optional<string::token_t> result_type;\n+\n+    const std::string& name;\n+    std::string& prefix;\n+    std::string& suffix;\n+\n+    auto operator()(const ph::generic<required>& token) const -> boost::optional<string::token_t> {\n+        if (token.name == name) {\n+            return boost::optional<string::token_t>(\n+                ph::generic<optional>(token, std::move(prefix), std::move(suffix)));\n+        }\n+\n+        return boost::none;\n+    }\n+\n+    auto operator()(const ph::generic<optional>& token) const -> boost::optional<string::token_t> {\n+        if (token.name == name) {\n+            ph::generic<optional> result(token);\n+            result.prefix = std::move(prefix);\n+            result.suffix = std::move(suffix);\n+            return boost::optional<string::token_t>(result);\n+        }\n+\n+        return boost::none;\n+    }\n+\n+    template<typename T>\n+    auto operator()(const T& token) const -> boost::optional<string::token_t> {\n+        return boost::none;\n+    }\n+};\n+\n+struct leftover_visitor {\n+    typedef boost::optional<string::token_t> result_type;\n+\n+    const std::string& name;\n+    std::string& prefix;\n+    std::string& suffix;\n+    std::string& pattern;\n+    std::string& separator;\n+    bool unique;\n+\n+    auto operator()(const ph::leftover_t& token) const -> boost::optional<string::token_t> {\n+        if (token.name == name) {\n+            return boost::optional<string::token_t>(\n+                ph::leftover_t(token.name, unique, prefix, suffix, pattern, separator));\n+        }\n+\n+        return boost::none;\n+    }\n+\n+\n+    template<typename T>\n+    auto operator()(const T& token) const -> boost::optional<string::token_t> {\n+        return boost::none;\n+    }\n+};\n+\n+// TODO: Decompose `throw std::invalid_argument(\"token not found\");` case.\n+// TODO: Check and decompose name is not reserved. Maybe by wrapping `name` with type. Test.\n+// TODO: Both algorithms are similar. Decompose.\n+auto string_t::optional(const std::string& name, std::string prefix, std::string suffix) -> void {\n+\n+    const option_visitor visitor{name, prefix, suffix};\n+\n+    for (auto& token : inner->tokens) {\n+        if (auto value = boost::apply_visitor(visitor, token)) {\n+            token = value.get();\n+            return;\n+        }\n+    }\n+\n+    throw std::invalid_argument(\"token not found\");\n+}\n+\n+auto string_t::leftover(const std::string& name, std::string prefix, std::string suffix,\n+    std::string pattern, std::string separator, bool unique) -> void\n+{\n+    const leftover_visitor visitor{name, prefix, suffix, pattern, separator, unique};\n+\n+    for (auto& token : inner->tokens) {\n+        if (auto value = boost::apply_visitor(visitor, token)) {\n+            token = value.get();\n+            return;\n+        }\n+    }\n+\n+    throw std::invalid_argument(\"token not found\");\n+}\n+\n+auto string_t::format(const record_t& record, writer_t& writer) -> void {\n+    const visitor_t visitor(writer, record, inner->sevmap);\n+\n+    for (const auto& token : inner->tokens) {\n+        boost::apply_visitor(visitor, token);\n     }\n }\n \n }  // namespace formatter\n \n-auto\n-factory<formatter::string_t>::type() -> const char* {\n+auto factory<formatter::string_t>::type() -> const char* {\n     return \"string\";\n }\n \n-auto\n-factory<formatter::string_t>::from(const config::node_t& config) -> formatter::string_t {\n+auto factory<formatter::string_t>::from(const config::node_t& config) -> formatter::string_t {\n     auto pattern = config[\"pattern\"].to_string().get();\n \n     if (auto mapping = config[\"sevmap\"]) {\n@@ -374,7 +415,7 @@\n             }\n         };\n \n-        return formatter::string_t(std::move(pattern), std::move(fn));\n+        return formatter::string_t(std::move(pattern));\n     }\n \n     return formatter::string_t(std::move(pattern));"
  }
}