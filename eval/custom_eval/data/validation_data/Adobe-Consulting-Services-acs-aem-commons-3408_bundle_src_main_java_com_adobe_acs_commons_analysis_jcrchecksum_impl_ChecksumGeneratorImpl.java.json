{
  "repo": {
    "name": "Adobe-Consulting-Services/acs-aem-commons",
    "buggy_commit": "a2cf90935d6166680ad85a9ac045e5060bf202ac",
    "fixed_commit": "be4c5995f48fb4b25d56d6b20485d28d62d76479"
  },
  "input": {
    "language": "Java",
    "issue": {
      "issue_title": "Reduce usage of Apache Commons Lang 2",
      "issue_description": "\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n"
    },
    "buggy_commit_message": "Merge branch 'Adobe-Consulting-Services:master' into master",
    "buggy_file": {
      "buggy_filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java",
      "buggy_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum.impl;\n\nimport com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGenerator;\nimport com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGeneratorOptions;\nimport com.adobe.acs.commons.analysis.jcrchecksum.impl.options.DefaultChecksumGeneratorOptions;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.jackrabbit.vault.util.Text;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.Node;\nimport javax.jcr.NodeIterator;\nimport javax.jcr.Property;\nimport javax.jcr.PropertyIterator;\nimport javax.jcr.PropertyType;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.Value;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\n/**\n * Utility that generates checksums for JCR paths.  The checksum is calculated using a depth first traversal\n * and calculates an aggregate checksum on the nodes with the specified node types\n * (via {@link ChecksumGeneratorOptions}).\n */\n@Component\n@Service\n@SuppressWarnings(\"squid:S2070\") // SHA1 not used cryptographically\npublic class ChecksumGeneratorImpl implements ChecksumGenerator {\n    private static final Logger log = LoggerFactory.getLogger(ChecksumGeneratorImpl.class);\n\n    /**\n     * Convenience method for  generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).\n     *\n     * @param session the session\n     * @param path tthe root path to generate checksums for\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException,\n            IOException {\n        return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());\n    }\n\n    /**\n     * Traverses the content tree whose root is defined by the path param, respecting the {@link\n     * ChecksumGeneratorOptions}.\n     * Generates map of checksum hashes in the format [ ABSOLUTE PATH ] : [ CHECKSUM OF NODE SYSTEM ]\n     *\n     * @param session the session\n     * @param path the root path to generate checksums for\n     * @param options the {@link ChecksumGeneratorOptions} that define the checksum generation\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    public Map<String, String> generateChecksums(Session session, String path, ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        Node node = session.getNode(path);\n\n        if (node == null) {\n            log.warn(\"Path [ {} ] not found while generating checksums\", path);\n            return new LinkedHashMap<>();\n        }\n\n        return traverseTree(node, options);\n    }\n\n    /**\n     * Traverse the tree for candidate aggregate nodes.\n     * @param node the current node being traversed\n     * @param options the checksum generator options\n     * @return a map of paths and checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    private Map<String, String> traverseTree(Node node, ChecksumGeneratorOptions options) throws\n            RepositoryException,\n            IOException {\n\n        final Map<String, String> checksums = new LinkedHashMap<>();\n\n        if (isExcludedSubTree(node, options)) {\n            return checksums;\n        } else if (isChecksumable(node, options) && !isExcludedNodeName(node, options)) {\n            // Tree-traversal has found a node to checksum (checksum will include all valid sub-tree nodes)\n            final String checksum = generatedNodeChecksum(node.getPath(), node, options);\n            if (checksum != null) {\n                checksums.put(node.getPath(), checksum);\n                log.debug(\"Top Level Node: {} ~> {}\", node.getPath(), checksum);\n            }\n        } else {\n            // Traverse the tree for checksum-able node systems\n            NodeIterator children = node.getNodes();\n\n            while (children.hasNext()) {\n                // Check each child with recursive logic; if child is checksum-able the call into traverseTree will\n                // handle this case\n                checksums.putAll(traverseTree(children.nextNode(), options));\n            }\n        }\n\n        return checksums;\n    }\n\n\n    /**\n     * Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.\n     *\n     * @param node    the candidate node\n     * @param options the checksum options containing the included and excluded none types\n     * @return true if the node represents a checksum-able node system\n     * @throws RepositoryException\n     */\n    private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException {\n        final Set<String> nodeTypeIncludes = options.getIncludedNodeTypes();\n        final Set<String> nodeTypeExcludes = options.getExcludedNodeTypes();\n\n        final String primaryNodeType = node.getPrimaryNodeType().getName();\n\n        return nodeTypeIncludes.contains(primaryNodeType) && !nodeTypeExcludes.contains(primaryNodeType);\n    }\n\n    /**\n     * Generates a checksum for a single node and its node sub-system, respecting the options.\n     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum\n     * @param node the node whose subsystem to create a checksum for\n     * @param options the {@link ChecksumGeneratorOptions} options\n     * @return a map containing 1 entry in the form [ node.getPath() ] : [ CHECKSUM OF NODE SYSTEM ]\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    @SuppressWarnings(\"squid:S3776\")\n    protected String generatedNodeChecksum(final String aggregateNodePath,\n                                                  final Node node,\n                                                  final ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        if (isExcludedSubTree(node, options)) { return \"\"; }\n\n        final Map<String, String> checksums = new LinkedHashMap<>();\n\n        if (!isExcludedNodeName(node, options)) {\n            /* Create checksums for Node's properties */\n            final String checksum = generatePropertyChecksums(aggregateNodePath, node, options);\n            if (checksum != null) {\n                checksums.put(getChecksumKey(aggregateNodePath, node.getPath()), checksum);\n            }\n        }\n\n        /* Then process node's children */\n\n        final Map<String, String> lexicographicallySortedChecksums = new TreeMap<>();\n        final boolean hasOrderedChildren = hasOrderedChildren(node);\n        final NodeIterator children = node.getNodes();\n\n        while (children.hasNext()) {\n            final Node child = children.nextNode();\n\n            if (isExcludedSubTree(child, options)) {\n                // Skip this node!\n            } else if (!isExcludedNodeType(child, options)) {\n                if (hasOrderedChildren) {\n                    // Use the order dictated by the JCR\n                    final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);\n                    if (checksum != null) {\n                        checksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n\n                        log.debug(\"Aggregated Ordered Node: {} ~> {}\",\n                                getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n                    }\n\n                } else {\n                    final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);\n                    if (checksum != null) {\n                        // If order is not dictated by JCR, collect so we can sort later\n                        lexicographicallySortedChecksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n\n                        log.debug(\"Aggregated Unordered Node: {} ~> {}\",\n                                getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n                    }\n                }\n            }\n        }\n\n        if (!hasOrderedChildren && lexicographicallySortedChecksums.size() > 0) {\n            // Order is not dictated by JCR, so add the lexicographically sorted entries to the checksums string\n            checksums.putAll(lexicographicallySortedChecksums);\n        }\n\n        final String nodeChecksum = aggregateChecksums(checksums);\n        log.debug(\"Node [ {} ] has a aggregated checksum of [ {} ]\", getChecksumKey(aggregateNodePath, node.getPath()), nodeChecksum);\n\n        return nodeChecksum;\n    }\n\n    /**\n     * Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].\n     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum\n     * @param node  the node to collect and checksum the properties for\n     * @param options the checksum generator options\n     * @return the map of the properties and their checksums\n     * @throws RepositoryException\n     */\n    protected String generatePropertyChecksums(final String aggregateNodePath,\n                                                      final Node node,\n                                                      final ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        SortedMap<String, String> propertyChecksums = new TreeMap<>();\n        PropertyIterator properties = node.getProperties();\n\n        while (properties.hasNext()) {\n            final Property property = properties.nextProperty();\n\n            if (options.getExcludedProperties().contains(property.getName())) {\n                // Skip this property as it is excluded\n                log.debug(\"Excluding property: {}\", node.getPath() + \"/@\" + property.getName());\n                continue;\n            }\n\n            /* Accept the property for checksuming */\n\n            final List<String> checksums = new ArrayList<String>();\n\n            final List<Value> values = getPropertyValues(property);\n\n            for (final Value value : values) {\n                if (value.getType() == PropertyType.BINARY) {\n                    checksums.add(getBinaryChecksum(value));\n                } else {\n                    checksums.add(getStringChecksum(value));\n                }\n            }\n\n            if (!options.getSortedProperties().contains(property.getName())) {\n                Collections.sort(checksums);\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Property: {} ~> {}\",\n                        getChecksumKey(aggregateNodePath, property.getPath()),\n                        StringUtils.join(checksums, \",\"));\n            }\n\n            propertyChecksums.put(getChecksumKey(aggregateNodePath, property.getPath()),\n                    StringUtils.join(checksums, \",\"));\n        }\n\n        return aggregateChecksums(propertyChecksums);\n    }\n\n\n    /**\n     * Generates the relative key used for tracking nodes and properties.\n     * @param aggregatePath the absolute path of the node being aggregated.\n     * @param path the path of the item being checksumed\n     * @return the key\n     */\n    protected String getChecksumKey(String aggregatePath, String path) {\n        if (\"/\".equals(aggregatePath) && \"/\".equals(path)) {\n            return \"/\";\n        } else if (\"/\".equals(aggregatePath)) {\n            return path;\n        }\n\n        String baseNodeName = Text.getName(aggregatePath);\n        String relPath = StringUtils.removeStart(path, aggregatePath);\n\n        return baseNodeName + relPath;\n    }\n\n    /**\n     * Normalizes a property values to a list; allows single and multi-values to be treated the same in code.\n     * @param property the propert to get the value(s) from\n     * @return a list of the property's value(s)\n     * @throws RepositoryException\n     */\n    private List<Value> getPropertyValues(final Property property) throws RepositoryException {\n        final List<Value> values = new ArrayList<>();\n\n        if (property.isMultiple()) {\n            values.addAll(Arrays.asList(property.getValues()));\n        } else {\n            values.add(property.getValue());\n        }\n\n        return values;\n    }\n\n    /**\n     * Gets the checksum for a Binary value.\n     * @param value the Value\n     * @return the checksum\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    protected String getBinaryChecksum(final Value value) throws RepositoryException, IOException {\n        InputStream stream = null;\n\n        try {\n            stream = value.getBinary().getStream();\n            return DigestUtils.sha1Hex(stream);\n        } finally {\n            if (stream != null) {\n                stream.close();\n            }\n        }\n    }\n\n    /**\n     * Gets the checksum for a String value.\n     * @param value the Value\n     * @return the checksum\n     * @throws RepositoryException\n     */\n    protected static String getStringChecksum(final Value value) throws RepositoryException {\n        return DigestUtils.sha1Hex(value.getString());\n    }\n\n    /**\n     * Checks if node has ordered children.\n     * @param node the node\n     * @return true if the node has ordered children\n     * @throws RepositoryException\n     */\n    protected boolean hasOrderedChildren(final Node node) throws RepositoryException {\n        boolean hasOrderedChildren = false;\n\n        try {\n            hasOrderedChildren = node.getPrimaryNodeType().hasOrderableChildNodes();\n        } catch (UnsupportedOperationException e) {\n            // This is an exception thrown in the test scenarios using the Mock JCR API\n            // This would not happen using the actual JCR APIs\n            // Allow other exceptions to be thrown and break processing normally\n        }\n\n        return hasOrderedChildren;\n    }\n\n    /**\n     * Aggregates a set of checksum entries into a single checksum value.\n     * @param checksums the checksums\n     * @return the checksum value\n     */\n    protected String aggregateChecksums(final Map<String, String> checksums) {\n        if (checksums.isEmpty()) { return null; }\n\n        StringBuilder data = new StringBuilder();\n\n        for (Map.Entry<String, String> entry : checksums.entrySet()) {\n            data.append(entry.getKey() + \"=\" + entry.getValue());\n        }\n\n        return DigestUtils.sha1Hex(data.toString());\n    }\n\n    protected boolean isExcludedSubTree(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        for (String exclude : options.getExcludedSubTrees()) {\n            if (isPathFragmentMatch(node, exclude)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    protected boolean isExcludedNodeName(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        for (String exclude : options.getExcludedNodeNames()) {\n            if (isPathFragmentMatch(node, exclude)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    protected boolean isExcludedNodeType(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        return options.getExcludedNodeTypes().contains(node.getPrimaryNodeType().getName());\n    }\n\n    private boolean isPathFragmentMatch(final Node node, final String fragmentPath) throws RepositoryException {\n        final List<String> fragments = Arrays.asList(StringUtils.split(fragmentPath, \"/\"));\n\n        Collections.reverse(fragments);\n\n        Node current = node;\n        for (String fragment : fragments) {\n\n            fragment = StringUtils.stripToNull(fragment);\n\n            if (current == null) {\n                return false;\n            } else if (StringUtils.startsWith(fragment,\"[\") && StringUtils.endsWith(fragment, \"]\")) {\n                final String nodeType = StringUtils.stripToEmpty(StringUtils.substringBetween(fragment, \"[\", \"]\"));\n\n                if (!current.isNodeType(nodeType)) {\n                    return false;\n                }\n            } else {\n                if (!StringUtils.equals(fragment, current.getName())) {\n                    return false;\n                }\n            }\n\n            current = current.getParent();\n        }\n\n        return true;\n    }\n}"
    },
    "context": [
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/ChecksumGenerator.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum;\n\nimport org.osgi.annotation.versioning.ProviderType;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport java.io.IOException;\nimport java.util.Map;\n\n/**\n * Utility that generates checksums for JCR paths.  The checksum is calculated using a depth first traversal\n * and calculates an aggregate checksum on the nodes with the specified node types\n * (via {@link ChecksumGeneratorOptions}).\n */\n@ProviderType\npublic interface ChecksumGenerator {\n    /**\n     * Convenience method for generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).\n     *\n     * @param session the session\n     * @param path    the root path to generate checksums for\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    Map<String, String> generateChecksums(Session session, String path) throws RepositoryException,\n            IOException;\n\n    /**\n     * Traverses the content tree whose root is defined by the path param, respecting the {@link\n     * ChecksumGeneratorOptions}.\n     * Generates map of checksum hashes in the format [ ABSOLUTE PATH ] : [ CHECKSUM OF NODE SYSTEM ]\n     *\n     * @param session the session\n     * @param path    the root path to generate checksums for\n     * @param options the {@link ChecksumGeneratorOptions} that define the checksum generation\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    Map<String, String> generateChecksums(Session session, String path, ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException;\n}"
      },
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/ChecksumGeneratorOptions.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum;\n\nimport org.osgi.annotation.versioning.ProviderType;\n\nimport java.util.Collections;\nimport java.util.Set;\n\n@ProviderType\n@SuppressWarnings(\"squid:S1214\")\npublic interface ChecksumGeneratorOptions {\n    String DATA = \"data\";\n\n    String PATHS = \"paths\";\n\n    String QUERY = \"query\";\n\n    String QUERY_TYPE = \"queryType\";\n\n    String NODES_TYPES = \"nodeTypes\";\n\n    String NODE_TYPE_EXCLUDES = \"excludeNodeTypes\";\n\n    String PROPERTY_EXCLUDES = \"excludeProperties\";\n\n    String SORTED_PROPERTIES = \"sortedProperties\";\n\n    String SUB_TREE_EXCLUDES = \"excludeSubTrees\";\n\n    String NODE_NAME_EXCLUDES = \"excludeNodeNames\";\n\n    /**\n     * For a node to be checksumable, its primaryType must exists in getIncludedNodesTypes() and not exist in\n     * getExcludedNodeTypes().\n     * @return the nodes types which are candidates for aggregation.\n     */\n    Set<String> getIncludedNodeTypes();\n\n    /**\n     * @return the node types which are not candidates for aggregation and cannot be aggregated under aggregation\n     * candidates.\n     */\n    Set<String> getExcludedNodeTypes();\n\n    /**\n     *\n     * @return the property names that should not be included as part of the checksum hash\n     */\n    Set<String> getExcludedProperties();\n\n    /**\n     * @return the property names whose multi-value order as defined in the JCR should be respected.\n     */\n    Set<String> getSortedProperties();\n\n    /**\n     * @return the named node subTrees to exclude (the matching node and any sub-nodes will NOT be traversed/checksumed)\n     */\n    default Set<String> getExcludedSubTrees() {\n        return  Collections.EMPTY_SET;\n    }\n\n    /**\n     * @return the nodeNames to exclude (sub-nodes WILL be traverse/checksumed)\n     */\n    default Set<String> getExcludedNodeNames() {\n        return  Collections.EMPTY_SET;\n    }\n}"
      },
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/options/DefaultChecksumGeneratorOptions.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum.impl.options;\n\nimport org.osgi.annotation.versioning.ProviderType;\nimport org.apache.sling.api.SlingHttpServletRequest;\n\n@ProviderType\npublic class DefaultChecksumGeneratorOptions extends AbstractChecksumGeneratorOptions {\n\n    public DefaultChecksumGeneratorOptions() {\n\n        this.addIncludedNodeTypes(\n                \"cq:PageContent\",\n                \"dam:AssetContent\",\n                \"cq:Tag\"\n        );\n\n        this.addExcludedNodeTypes(\n                \"rep:ACL\",\n                \"cq:meta\"\n        );\n\n        this.addExcludedProperties(\n                \"jcr:mixinTypes\",\n                \"jcr:created\",\n                \"jcr:uuid\",\n                \"jcr:lastModified\",\n                \"jcr:lastModifiedBy\",\n                \"cq:lastModified\",\n                \"cq:lastModifiedBy\",\n                \"cq:lastReplicated\",\n                \"cq:lastReplicatedBy\",\n                \"cq:lastReplicationAction\",\n                \"cq:ReplicationStatus\",\n                \"jcr:versionHistory\",\n                \"jcr:predecessors\",\n                \"jcr:baseVersion\"\n        );\n\n        this.addSortedProperties(\n                \"cq:tags\"\n        );\n    }\n\n    public DefaultChecksumGeneratorOptions(SlingHttpServletRequest request) {\n        this();\n    }\n\n}"
      }
    ],
    "unresolved_context": [
      "org.apache.commons.codec.digest.DigestUtils",
      "org.apache.commons.lang.StringUtils",
      "org.apache.felix.scr.annotations.Component",
      "org.apache.felix.scr.annotations.Service",
      "org.apache.jackrabbit.vault.util.Text",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.Node",
      "javax.jcr.NodeIterator",
      "javax.jcr.Property",
      "javax.jcr.PropertyIterator",
      "javax.jcr.PropertyType",
      "javax.jcr.RepositoryException",
      "javax.jcr.Session",
      "javax.jcr.Value",
      "java.io.IOException",
      "java.io.InputStream",
      "java.util.ArrayList",
      "java.util.Arrays",
      "java.util.Collections",
      "java.util.LinkedHashMap",
      "java.util.List",
      "java.util.Map",
      "java.util.Set",
      "java.util.SortedMap",
      "java.util.TreeMap"
    ]
  },
  "output": {
    "language": "Java",
    "fixed_commit_message": "Reduce usage of Apache Commons Lang 2\nThis fixes #3408",
    "fixed_file": {
      "fixed_filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/ChecksumGeneratorImpl.java",
      "fixed_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum.impl;\n\nimport com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGenerator;\nimport com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGeneratorOptions;\nimport com.adobe.acs.commons.analysis.jcrchecksum.impl.options.DefaultChecksumGeneratorOptions;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.jackrabbit.vault.util.Text;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.Node;\nimport javax.jcr.NodeIterator;\nimport javax.jcr.Property;\nimport javax.jcr.PropertyIterator;\nimport javax.jcr.PropertyType;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.Value;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\n/**\n * Utility that generates checksums for JCR paths.  The checksum is calculated using a depth first traversal\n * and calculates an aggregate checksum on the nodes with the specified node types\n * (via {@link ChecksumGeneratorOptions}).\n */\n@Component\n@Service\n@SuppressWarnings(\"squid:S2070\") // SHA1 not used cryptographically\npublic class ChecksumGeneratorImpl implements ChecksumGenerator {\n    private static final Logger log = LoggerFactory.getLogger(ChecksumGeneratorImpl.class);\n\n    /**\n     * Convenience method for  generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).\n     *\n     * @param session the session\n     * @param path tthe root path to generate checksums for\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException,\n            IOException {\n        return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());\n    }\n\n    /**\n     * Traverses the content tree whose root is defined by the path param, respecting the {@link\n     * ChecksumGeneratorOptions}.\n     * Generates map of checksum hashes in the format [ ABSOLUTE PATH ] : [ CHECKSUM OF NODE SYSTEM ]\n     *\n     * @param session the session\n     * @param path the root path to generate checksums for\n     * @param options the {@link ChecksumGeneratorOptions} that define the checksum generation\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    public Map<String, String> generateChecksums(Session session, String path, ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        Node node = session.getNode(path);\n\n        if (node == null) {\n            log.warn(\"Path [ {} ] not found while generating checksums\", path);\n            return new LinkedHashMap<>();\n        }\n\n        return traverseTree(node, options);\n    }\n\n    /**\n     * Traverse the tree for candidate aggregate nodes.\n     * @param node the current node being traversed\n     * @param options the checksum generator options\n     * @return a map of paths and checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    private Map<String, String> traverseTree(Node node, ChecksumGeneratorOptions options) throws\n            RepositoryException,\n            IOException {\n\n        final Map<String, String> checksums = new LinkedHashMap<>();\n\n        if (isExcludedSubTree(node, options)) {\n            return checksums;\n        } else if (isChecksumable(node, options) && !isExcludedNodeName(node, options)) {\n            // Tree-traversal has found a node to checksum (checksum will include all valid sub-tree nodes)\n            final String checksum = generatedNodeChecksum(node.getPath(), node, options);\n            if (checksum != null) {\n                checksums.put(node.getPath(), checksum);\n                log.debug(\"Top Level Node: {} ~> {}\", node.getPath(), checksum);\n            }\n        } else {\n            // Traverse the tree for checksum-able node systems\n            NodeIterator children = node.getNodes();\n\n            while (children.hasNext()) {\n                // Check each child with recursive logic; if child is checksum-able the call into traverseTree will\n                // handle this case\n                checksums.putAll(traverseTree(children.nextNode(), options));\n            }\n        }\n\n        return checksums;\n    }\n\n\n    /**\n     * Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.\n     *\n     * @param node    the candidate node\n     * @param options the checksum options containing the included and excluded none types\n     * @return true if the node represents a checksum-able node system\n     * @throws RepositoryException\n     */\n    private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException {\n        final Set<String> nodeTypeIncludes = options.getIncludedNodeTypes();\n        final Set<String> nodeTypeExcludes = options.getExcludedNodeTypes();\n\n        final String primaryNodeType = node.getPrimaryNodeType().getName();\n\n        return nodeTypeIncludes.contains(primaryNodeType) && !nodeTypeExcludes.contains(primaryNodeType);\n    }\n\n    /**\n     * Generates a checksum for a single node and its node sub-system, respecting the options.\n     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum\n     * @param node the node whose subsystem to create a checksum for\n     * @param options the {@link ChecksumGeneratorOptions} options\n     * @return a map containing 1 entry in the form [ node.getPath() ] : [ CHECKSUM OF NODE SYSTEM ]\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    @SuppressWarnings(\"squid:S3776\")\n    protected String generatedNodeChecksum(final String aggregateNodePath,\n                                                  final Node node,\n                                                  final ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        if (isExcludedSubTree(node, options)) { return \"\"; }\n\n        final Map<String, String> checksums = new LinkedHashMap<>();\n\n        if (!isExcludedNodeName(node, options)) {\n            /* Create checksums for Node's properties */\n            final String checksum = generatePropertyChecksums(aggregateNodePath, node, options);\n            if (checksum != null) {\n                checksums.put(getChecksumKey(aggregateNodePath, node.getPath()), checksum);\n            }\n        }\n\n        /* Then process node's children */\n\n        final Map<String, String> lexicographicallySortedChecksums = new TreeMap<>();\n        final boolean hasOrderedChildren = hasOrderedChildren(node);\n        final NodeIterator children = node.getNodes();\n\n        while (children.hasNext()) {\n            final Node child = children.nextNode();\n\n            if (isExcludedSubTree(child, options)) {\n                // Skip this node!\n            } else if (!isExcludedNodeType(child, options)) {\n                if (hasOrderedChildren) {\n                    // Use the order dictated by the JCR\n                    final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);\n                    if (checksum != null) {\n                        checksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n\n                        log.debug(\"Aggregated Ordered Node: {} ~> {}\",\n                                getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n                    }\n\n                } else {\n                    final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);\n                    if (checksum != null) {\n                        // If order is not dictated by JCR, collect so we can sort later\n                        lexicographicallySortedChecksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n\n                        log.debug(\"Aggregated Unordered Node: {} ~> {}\",\n                                getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n                    }\n                }\n            }\n        }\n\n        if (!hasOrderedChildren && lexicographicallySortedChecksums.size() > 0) {\n            // Order is not dictated by JCR, so add the lexicographically sorted entries to the checksums string\n            checksums.putAll(lexicographicallySortedChecksums);\n        }\n\n        final String nodeChecksum = aggregateChecksums(checksums);\n        log.debug(\"Node [ {} ] has a aggregated checksum of [ {} ]\", getChecksumKey(aggregateNodePath, node.getPath()), nodeChecksum);\n\n        return nodeChecksum;\n    }\n\n    /**\n     * Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].\n     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum\n     * @param node  the node to collect and checksum the properties for\n     * @param options the checksum generator options\n     * @return the map of the properties and their checksums\n     * @throws RepositoryException\n     */\n    protected String generatePropertyChecksums(final String aggregateNodePath,\n                                                      final Node node,\n                                                      final ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        SortedMap<String, String> propertyChecksums = new TreeMap<>();\n        PropertyIterator properties = node.getProperties();\n\n        while (properties.hasNext()) {\n            final Property property = properties.nextProperty();\n\n            if (options.getExcludedProperties().contains(property.getName())) {\n                // Skip this property as it is excluded\n                log.debug(\"Excluding property: {}\", node.getPath() + \"/@\" + property.getName());\n                continue;\n            }\n\n            /* Accept the property for checksuming */\n\n            final List<String> checksums = new ArrayList<String>();\n\n            final List<Value> values = getPropertyValues(property);\n\n            for (final Value value : values) {\n                if (value.getType() == PropertyType.BINARY) {\n                    checksums.add(getBinaryChecksum(value));\n                } else {\n                    checksums.add(getStringChecksum(value));\n                }\n            }\n\n            if (!options.getSortedProperties().contains(property.getName())) {\n                Collections.sort(checksums);\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Property: {} ~> {}\",\n                        getChecksumKey(aggregateNodePath, property.getPath()),\n                        StringUtils.join(checksums, \",\"));\n            }\n\n            propertyChecksums.put(getChecksumKey(aggregateNodePath, property.getPath()),\n                    StringUtils.join(checksums, \",\"));\n        }\n\n        return aggregateChecksums(propertyChecksums);\n    }\n\n\n    /**\n     * Generates the relative key used for tracking nodes and properties.\n     * @param aggregatePath the absolute path of the node being aggregated.\n     * @param path the path of the item being checksumed\n     * @return the key\n     */\n    protected String getChecksumKey(String aggregatePath, String path) {\n        if (\"/\".equals(aggregatePath) && \"/\".equals(path)) {\n            return \"/\";\n        } else if (\"/\".equals(aggregatePath)) {\n            return path;\n        }\n\n        String baseNodeName = Text.getName(aggregatePath);\n        String relPath = StringUtils.removeStart(path, aggregatePath);\n\n        return baseNodeName + relPath;\n    }\n\n    /**\n     * Normalizes a property values to a list; allows single and multi-values to be treated the same in code.\n     * @param property the propert to get the value(s) from\n     * @return a list of the property's value(s)\n     * @throws RepositoryException\n     */\n    private List<Value> getPropertyValues(final Property property) throws RepositoryException {\n        final List<Value> values = new ArrayList<>();\n\n        if (property.isMultiple()) {\n            values.addAll(Arrays.asList(property.getValues()));\n        } else {\n            values.add(property.getValue());\n        }\n\n        return values;\n    }\n\n    /**\n     * Gets the checksum for a Binary value.\n     * @param value the Value\n     * @return the checksum\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    protected String getBinaryChecksum(final Value value) throws RepositoryException, IOException {\n        InputStream stream = null;\n\n        try {\n            stream = value.getBinary().getStream();\n            return DigestUtils.sha1Hex(stream);\n        } finally {\n            if (stream != null) {\n                stream.close();\n            }\n        }\n    }\n\n    /**\n     * Gets the checksum for a String value.\n     * @param value the Value\n     * @return the checksum\n     * @throws RepositoryException\n     */\n    protected static String getStringChecksum(final Value value) throws RepositoryException {\n        return DigestUtils.sha1Hex(value.getString());\n    }\n\n    /**\n     * Checks if node has ordered children.\n     * @param node the node\n     * @return true if the node has ordered children\n     * @throws RepositoryException\n     */\n    protected boolean hasOrderedChildren(final Node node) throws RepositoryException {\n        boolean hasOrderedChildren = false;\n\n        try {\n            hasOrderedChildren = node.getPrimaryNodeType().hasOrderableChildNodes();\n        } catch (UnsupportedOperationException e) {\n            // This is an exception thrown in the test scenarios using the Mock JCR API\n            // This would not happen using the actual JCR APIs\n            // Allow other exceptions to be thrown and break processing normally\n        }\n\n        return hasOrderedChildren;\n    }\n\n    /**\n     * Aggregates a set of checksum entries into a single checksum value.\n     * @param checksums the checksums\n     * @return the checksum value\n     */\n    protected String aggregateChecksums(final Map<String, String> checksums) {\n        if (checksums.isEmpty()) { return null; }\n\n        StringBuilder data = new StringBuilder();\n\n        for (Map.Entry<String, String> entry : checksums.entrySet()) {\n            data.append(entry.getKey() + \"=\" + entry.getValue());\n        }\n\n        return DigestUtils.sha1Hex(data.toString());\n    }\n\n    protected boolean isExcludedSubTree(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        for (String exclude : options.getExcludedSubTrees()) {\n            if (isPathFragmentMatch(node, exclude)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    protected boolean isExcludedNodeName(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        for (String exclude : options.getExcludedNodeNames()) {\n            if (isPathFragmentMatch(node, exclude)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    protected boolean isExcludedNodeType(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        return options.getExcludedNodeTypes().contains(node.getPrimaryNodeType().getName());\n    }\n\n    private boolean isPathFragmentMatch(final Node node, final String fragmentPath) throws RepositoryException {\n        final List<String> fragments = Arrays.asList(StringUtils.split(fragmentPath, \"/\"));\n\n        Collections.reverse(fragments);\n\n        Node current = node;\n        for (String fragment : fragments) {\n\n            fragment = StringUtils.stripToNull(fragment);\n\n            if (current == null) {\n                return false;\n            } else if (StringUtils.startsWith(fragment,\"[\") && StringUtils.endsWith(fragment, \"]\")) {\n                final String nodeType = StringUtils.stripToEmpty(StringUtils.substringBetween(fragment, \"[\", \"]\"));\n\n                if (!current.isNodeType(nodeType)) {\n                    return false;\n                }\n            } else {\n                if (!StringUtils.equals(fragment, current.getName())) {\n                    return false;\n                }\n            }\n\n            current = current.getParent();\n        }\n\n        return true;\n    }\n}"
    },
    "context": [
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/ChecksumGenerator.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum;\n\nimport org.osgi.annotation.versioning.ProviderType;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport java.io.IOException;\nimport java.util.Map;\n\n/**\n * Utility that generates checksums for JCR paths.  The checksum is calculated using a depth first traversal\n * and calculates an aggregate checksum on the nodes with the specified node types\n * (via {@link ChecksumGeneratorOptions}).\n */\n@ProviderType\npublic interface ChecksumGenerator {\n    /**\n     * Convenience method for generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).\n     *\n     * @param session the session\n     * @param path    the root path to generate checksums for\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    Map<String, String> generateChecksums(Session session, String path) throws RepositoryException,\n            IOException;\n\n    /**\n     * Traverses the content tree whose root is defined by the path param, respecting the {@link\n     * ChecksumGeneratorOptions}.\n     * Generates map of checksum hashes in the format [ ABSOLUTE PATH ] : [ CHECKSUM OF NODE SYSTEM ]\n     *\n     * @param session the session\n     * @param path    the root path to generate checksums for\n     * @param options the {@link ChecksumGeneratorOptions} that define the checksum generation\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    Map<String, String> generateChecksums(Session session, String path, ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException;\n}"
      },
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/ChecksumGeneratorOptions.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum;\n\nimport org.osgi.annotation.versioning.ProviderType;\n\nimport java.util.Collections;\nimport java.util.Set;\n\n@ProviderType\n@SuppressWarnings(\"squid:S1214\")\npublic interface ChecksumGeneratorOptions {\n    String DATA = \"data\";\n\n    String PATHS = \"paths\";\n\n    String QUERY = \"query\";\n\n    String QUERY_TYPE = \"queryType\";\n\n    String NODES_TYPES = \"nodeTypes\";\n\n    String NODE_TYPE_EXCLUDES = \"excludeNodeTypes\";\n\n    String PROPERTY_EXCLUDES = \"excludeProperties\";\n\n    String SORTED_PROPERTIES = \"sortedProperties\";\n\n    String SUB_TREE_EXCLUDES = \"excludeSubTrees\";\n\n    String NODE_NAME_EXCLUDES = \"excludeNodeNames\";\n\n    /**\n     * For a node to be checksumable, its primaryType must exists in getIncludedNodesTypes() and not exist in\n     * getExcludedNodeTypes().\n     * @return the nodes types which are candidates for aggregation.\n     */\n    Set<String> getIncludedNodeTypes();\n\n    /**\n     * @return the node types which are not candidates for aggregation and cannot be aggregated under aggregation\n     * candidates.\n     */\n    Set<String> getExcludedNodeTypes();\n\n    /**\n     *\n     * @return the property names that should not be included as part of the checksum hash\n     */\n    Set<String> getExcludedProperties();\n\n    /**\n     * @return the property names whose multi-value order as defined in the JCR should be respected.\n     */\n    Set<String> getSortedProperties();\n\n    /**\n     * @return the named node subTrees to exclude (the matching node and any sub-nodes will NOT be traversed/checksumed)\n     */\n    default Set<String> getExcludedSubTrees() {\n        return  Collections.EMPTY_SET;\n    }\n\n    /**\n     * @return the nodeNames to exclude (sub-nodes WILL be traverse/checksumed)\n     */\n    default Set<String> getExcludedNodeNames() {\n        return  Collections.EMPTY_SET;\n    }\n}"
      },
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/analysis/jcrchecksum/impl/options/DefaultChecksumGeneratorOptions.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum.impl.options;\n\nimport org.osgi.annotation.versioning.ProviderType;\nimport org.apache.sling.api.SlingHttpServletRequest;\n\n@ProviderType\npublic class DefaultChecksumGeneratorOptions extends AbstractChecksumGeneratorOptions {\n\n    public DefaultChecksumGeneratorOptions() {\n\n        this.addIncludedNodeTypes(\n                \"cq:PageContent\",\n                \"dam:AssetContent\",\n                \"cq:Tag\"\n        );\n\n        this.addExcludedNodeTypes(\n                \"rep:ACL\",\n                \"cq:meta\"\n        );\n\n        this.addExcludedProperties(\n                \"jcr:mixinTypes\",\n                \"jcr:created\",\n                \"jcr:uuid\",\n                \"jcr:lastModified\",\n                \"jcr:lastModifiedBy\",\n                \"cq:lastModified\",\n                \"cq:lastModifiedBy\",\n                \"cq:lastReplicated\",\n                \"cq:lastReplicatedBy\",\n                \"cq:lastReplicationAction\",\n                \"cq:ReplicationStatus\",\n                \"jcr:versionHistory\",\n                \"jcr:predecessors\",\n                \"jcr:baseVersion\"\n        );\n\n        this.addSortedProperties(\n                \"cq:tags\"\n        );\n    }\n\n    public DefaultChecksumGeneratorOptions(SlingHttpServletRequest request) {\n        this();\n    }\n\n}"
      }
    ],
    "unresolved_context": [
      "org.apache.commons.codec.digest.DigestUtils",
      "org.apache.commons.lang3.StringUtils",
      "org.apache.felix.scr.annotations.Component",
      "org.apache.felix.scr.annotations.Service",
      "org.apache.jackrabbit.vault.util.Text",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.Node",
      "javax.jcr.NodeIterator",
      "javax.jcr.Property",
      "javax.jcr.PropertyIterator",
      "javax.jcr.PropertyType",
      "javax.jcr.RepositoryException",
      "javax.jcr.Session",
      "javax.jcr.Value",
      "java.io.IOException",
      "java.io.InputStream",
      "java.util.ArrayList",
      "java.util.Arrays",
      "java.util.Collections",
      "java.util.LinkedHashMap",
      "java.util.List",
      "java.util.Map",
      "java.util.Set",
      "java.util.SortedMap",
      "java.util.TreeMap"
    ],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -22,7 +22,7 @@\n import com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGeneratorOptions;\n import com.adobe.acs.commons.analysis.jcrchecksum.impl.options.DefaultChecksumGeneratorOptions;\n import org.apache.commons.codec.digest.DigestUtils;\n-import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.felix.scr.annotations.Component;\n import org.apache.felix.scr.annotations.Service;\n import org.apache.jackrabbit.vault.util.Text;"
  }
}