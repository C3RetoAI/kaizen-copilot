{
  "repo": {
    "name": "3Hren/blackhole",
    "buggy_commit": "57814ff45d7bcdf306f8f085d0f6ad34561419c5",
    "fixed_commit": "a57bedad01ead02147a9f94a3b3c4050fa2e81a9"
  },
  "input": {
    "language": "C++",
    "issue": {
      "issue_title": "Hide string formatter binary interface",
      "issue_description": "To achieve the possibility of changing string formatter implementation or bug fixes without breaking the ABI it's important to hide that ABI. All other formatters/sinks have already been written in that way.\n\nNote, that this change will break `blackhole::formatter::string_t` API/ABI as it were described in https://github.com/3Hren/blackhole/milestones, but for now it's okay, because nobody uses it explicitly except the Blackhole internals.\n"
    },
    "buggy_commit_message": "refactor(builder): move to experimental\n\nTo be able to correctly handle backward compatibility I need to\ndistinguish between stable and unstable components. When an user\nincludes an experimental component he/she is explicitly notified\nsemantically to be prepared for API/ABI breaking.",
    "buggy_file": {
      "buggy_filename": "bench/formatter/string.cpp",
      "buggy_code": "#include <benchmark/benchmark.h>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/string.hpp>\n#include <blackhole/record.hpp>\n\n#include \"mod.hpp\"\n\nnamespace blackhole {\nnamespace benchmark {\n\nstatic void format_literal(::benchmark::State& state) {\n    formatter::string_t formatter(\"message: value\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_pid(::benchmark::State& state) {\n    formatter::string_t formatter(\"{process}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_procname(::benchmark::State& state) {\n    formatter::string_t formatter(\"{process:s}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_tid(::benchmark::State& state) {\n    formatter::string_t formatter(\"{thread}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_message(::benchmark::State& state) {\n    formatter::string_t formatter(\"message: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_timestamp(::benchmark::State& state) {\n    formatter::string_t formatter(\"{timestamp}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_leftover(::benchmark::State& state) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}={v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_severity_message(::benchmark::State& state) {\n    formatter::string_t formatter(\"{severity:d}: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nNBENCHMARK(\"formatter.string[lit]\", format_literal);\nNBENCHMARK(\"formatter.string[pid]\", format_pid);\nNBENCHMARK(\"formatter.string[tid]\", format_tid);\nNBENCHMARK(\"formatter.string[procname]\", format_procname);\nNBENCHMARK(\"formatter.string[message]\", format_message);\nNBENCHMARK(\"formatter.string[timestamp]\", format_timestamp);\nNBENCHMARK(\"formatter.string[severity + message]\", format_severity_message);\nNBENCHMARK(\"formatter.string[...]\", format_leftover);\n\n}  // namespace benchmark\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "bench/mod.hpp",
        "code": "#pragma once\n\n// Some private magic, but it's okay, since I manage the library version myself.\n#define NBENCHMARK(name, n) \\\n    BENCHMARK_PRIVATE_DECLARE(n) =                               \\\n        (::benchmark::internal::RegisterBenchmarkInternal(       \\\n            new ::benchmark::internal::FunctionBenchmark(name, n)))\n"
      }
    ],
    "unresolved_context": []
  },
  "output": {
    "language": "C++",
    "fixed_commit_message": "refactor(formatter/string): new interface\n\nThis commit changes the interface (and ABI) of the string formatter to\nmake it possible to change the implementation or add functionality\nwithout further breaking.\n\nStrictly speaking this commit just applies pointer to implementation\nidiom.\n\nCloses #83, but it\u2019s not complete yet, just proof of concept.",
    "fixed_file": {
      "fixed_filename": "bench/formatter/string.cpp",
      "fixed_code": "#include <benchmark/benchmark.h>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/string.hpp>\n#include <blackhole/record.hpp>\n\n#include \"mod.hpp\"\n\nnamespace blackhole {\nnamespace benchmark {\n\nstatic void format_literal(::benchmark::State& state) {\n    formatter::string_t formatter(\"message: value\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_pid(::benchmark::State& state) {\n    formatter::string_t formatter(\"{process}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_procname(::benchmark::State& state) {\n    formatter::string_t formatter(\"{process:s}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_tid(::benchmark::State& state) {\n    formatter::string_t formatter(\"{thread}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_message(::benchmark::State& state) {\n    formatter::string_t formatter(\"message: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_timestamp(::benchmark::State& state) {\n    formatter::string_t formatter(\"{timestamp}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_leftover(::benchmark::State& state) {\n    formatter::string_t formatter(\"{...}\");\n    formatter.leftover(\"...\", \"[\", \"]\", \"{k}={v}\", \", \", false);\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_severity_message(::benchmark::State& state) {\n    formatter::string_t formatter(\"{severity:d}: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nNBENCHMARK(\"formatter.string[lit]\", format_literal);\nNBENCHMARK(\"formatter.string[pid]\", format_pid);\nNBENCHMARK(\"formatter.string[tid]\", format_tid);\nNBENCHMARK(\"formatter.string[procname]\", format_procname);\nNBENCHMARK(\"formatter.string[message]\", format_message);\nNBENCHMARK(\"formatter.string[timestamp]\", format_timestamp);\nNBENCHMARK(\"formatter.string[severity + message]\", format_severity_message);\nNBENCHMARK(\"formatter.string[...]\", format_leftover);\n\n}  // namespace benchmark\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "bench/mod.hpp",
        "code": "#pragma once\n\n// Some private magic, but it's okay, since I manage the library version myself.\n#define NBENCHMARK(name, n) \\\n    BENCHMARK_PRIVATE_DECLARE(n) =                               \\\n        (::benchmark::internal::RegisterBenchmarkInternal(       \\\n            new ::benchmark::internal::FunctionBenchmark(name, n)))\n"
      }
    ],
    "unresolved_context": [],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -104,9 +104,8 @@\n }\n \n static void format_leftover(::benchmark::State& state) {\n-    formatter::string_t formatter(\"{...}\", {\n-        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}={v}\", \", \"}}\n-    });\n+    formatter::string_t formatter(\"{...}\");\n+    formatter.leftover(\"...\", \"[\", \"]\", \"{k}={v}\", \", \", false);\n \n     const string_view message(\"-\");\n     const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};"
  }
}