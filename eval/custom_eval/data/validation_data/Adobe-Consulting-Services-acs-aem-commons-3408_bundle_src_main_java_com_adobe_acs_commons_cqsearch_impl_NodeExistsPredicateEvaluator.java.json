{
  "repo": {
    "name": "Adobe-Consulting-Services/acs-aem-commons",
    "buggy_commit": "a2cf90935d6166680ad85a9ac045e5060bf202ac",
    "fixed_commit": "be4c5995f48fb4b25d56d6b20485d28d62d76479"
  },
  "input": {
    "language": "Java",
    "issue": {
      "issue_title": "Reduce usage of Apache Commons Lang 2",
      "issue_description": "\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n"
    },
    "buggy_commit_message": "Merge branch 'Adobe-Consulting-Services:master' into master",
    "buggy_file": {
      "buggy_filename": "bundle/src/main/java/com/adobe/acs/commons/cqsearch/impl/NodeExistsPredicateEvaluator.java",
      "buggy_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.cqsearch.impl;\n\nimport com.day.cq.search.Predicate;\nimport com.day.cq.search.eval.AbstractPredicateEvaluator;\nimport com.day.cq.search.eval.EvaluationContext;\nimport com.day.cq.search.eval.PredicateEvaluator;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.query.Row;\nimport java.util.Map;\n\n/**\n * This AEM QueryBuilder predicate checks if a JCR node exists, or doesn't\n * exist, off the provided relative path.\n *\n * There are 3 configurations:\n *\n * nodeExists.or = true | false (defaults to false) -- When nodeExists.or =\n * false (the default), all .exists and .notexists conditions for this predicate\n * are AND'd together to determine if the result node is included.\n *\n * nodeExists.#_exists = relative path (relative from the result node) to\n * another node. This relative path mush exist for this expression to return\n * true -- Multiple exists conditions can be present and need to be prefixed via\n * the usual `#_exists` syntax.\n *\n * nodeExists.#_notexists = relative path (relative from the result node) to\n * another node. This relative path mush NOT exist for this expression to return\n * true -- Multiple exists conditions can be present and need to be prefixed via\n * the usual `#_notexists` syntax.\n *\n * nodeExists.or=true nodeExists.exists=jcr:content/renditions/original\n * nodeExists.2_exists=jcr:content/renditions/cq5dam.thumbnail.48.48.png\n * nodeExists.1_notexists=jcr:content/renditions/cq5dam.web.1280.1280.png\n * nodeExists.2_notexists=jcr:content/renditions/cq5dam.web.600.400.png\n */\n@Component(\n        factory = \"com.day.cq.search.eval.PredicateEvaluator/nodeExists\"\n)\npublic class NodeExistsPredicateEvaluator extends AbstractPredicateEvaluator implements PredicateEvaluator {\n\n    private static final Logger log = LoggerFactory.getLogger(NodeExistsPredicateEvaluator.class);\n\n    public static final String OR = \"or\";\n    public static final String EXISTS_REL_PATH = \"exists\";\n    public static final String NOT_EXISTS_REL_PATH = \"notexists\";\n\n    @Override\n    public final boolean canXpath(final Predicate predicate, final EvaluationContext context) {\n        return false;\n    }\n\n    @Override\n    public final boolean canFilter(final Predicate predicate, final EvaluationContext context) {\n        return !(predicate.getParameters().isEmpty()\n                || (predicate.getParameters().size() == 1\n                && predicate.getParameters().get(OR) != null));\n    }\n\n    @Override\n    @SuppressWarnings(\"squid:S3776\")\n    public final boolean includes(final Predicate predicate, final Row row, final EvaluationContext context) {\n        boolean or = predicate.getBool(OR);\n\n        if (log.isDebugEnabled()) {\n            if (or) {\n                log.debug(\"NodeExistsPredicatorEvaluator evaluating as [ OR ]\");\n            } else {\n                log.debug(\"NodeExistsPredicatorEvaluator evaluating as [ AND ]\");\n            }\n        }\n\n        for (final Map.Entry<String, String> entry : predicate.getParameters().entrySet()) {\n            boolean ruleIncludes = false;\n\n            String operation = entry.getKey();\n            if (StringUtils.contains(operation, \"_\")) {\n                operation = StringUtils.substringAfterLast(entry.getKey(), \"_\");\n            }\n\n            try {\n                if (EXISTS_REL_PATH.equals(operation)) {\n                    ruleIncludes = row.getNode().hasNode(entry.getValue());\n                } else if (NOT_EXISTS_REL_PATH.equals(operation)) {\n                    ruleIncludes = !row.getNode().hasNode(entry.getValue());\n                } else if (!OR.equals(operation)) {\n                    log.debug(\"Invalid operation [ {} ]\", operation);\n                }\n\n                // Return quickly from the evaluation loop\n                if (or && ruleIncludes) {\n                    // If OR condition; return true on the first condition match\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Including [ {} ] based on [ {}  -> {} ] as part of [ OR ]\",\n                                row.getPath(), operation, entry.getValue());\n                    }\n                    return true;\n                } else if (!or && !ruleIncludes) {\n                    // If AND condition; return true on the first condition failure\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Excluding [ {} ] based on [ {}  -> {} ] as part of [ AND ]\",\n                                row.getPath(), operation, entry.getValue());\n                    }\n\n                    return false;\n                }\n            } catch (RepositoryException e) {\n                log.error(\"Unable to check if Node [ {} : {} ] via the nodeExists QueryBuilder predicate\", new String[]{entry.getKey(), entry.getValue()}, e);\n            }\n        }\n\n        if (or) {\n            // For ORs, if a true condition was met in the loop, the method would have already returned true, so must be false.\n            if (log.isDebugEnabled()) {\n                try {\n                    log.debug(\"Excluding [ {} ] based on NOT matching conditions as part of [ OR ]\", row.getPath());\n                } catch (RepositoryException e) {\n                    log.error(\"Could not obtain path from for Result row in predicate evaluator\", e);\n                }\n            }\n            return false;\n        } else {\n            // If ANDs, if a false condition was met in the loop, the method would have already returned false, so must be true.\n            if (log.isDebugEnabled()) {\n                try {\n                    log.debug(\"Include [ {} ] based on ALL matching conditions as part of [ AND ]\", row.getPath());\n                } catch (RepositoryException e) {\n                    log.error(\"Could not obtain path from for Result row in predicate evaluator\", e);\n                }\n            }\n            return true;\n        }\n    }\n}\n"
    },
    "context": [],
    "unresolved_context": [
      "com.day.cq.search.Predicate",
      "com.day.cq.search.eval.AbstractPredicateEvaluator",
      "com.day.cq.search.eval.EvaluationContext",
      "com.day.cq.search.eval.PredicateEvaluator",
      "org.apache.commons.lang.StringUtils",
      "org.apache.felix.scr.annotations.Component",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.RepositoryException",
      "javax.jcr.query.Row",
      "java.util.Map"
    ]
  },
  "output": {
    "language": "Java",
    "fixed_commit_message": "Reduce usage of Apache Commons Lang 2\nThis fixes #3408",
    "fixed_file": {
      "fixed_filename": "bundle/src/main/java/com/adobe/acs/commons/cqsearch/impl/NodeExistsPredicateEvaluator.java",
      "fixed_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.cqsearch.impl;\n\nimport com.day.cq.search.Predicate;\nimport com.day.cq.search.eval.AbstractPredicateEvaluator;\nimport com.day.cq.search.eval.EvaluationContext;\nimport com.day.cq.search.eval.PredicateEvaluator;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.felix.scr.annotations.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.query.Row;\nimport java.util.Map;\n\n/**\n * This AEM QueryBuilder predicate checks if a JCR node exists, or doesn't\n * exist, off the provided relative path.\n *\n * There are 3 configurations:\n *\n * nodeExists.or = true | false (defaults to false) -- When nodeExists.or =\n * false (the default), all .exists and .notexists conditions for this predicate\n * are AND'd together to determine if the result node is included.\n *\n * nodeExists.#_exists = relative path (relative from the result node) to\n * another node. This relative path mush exist for this expression to return\n * true -- Multiple exists conditions can be present and need to be prefixed via\n * the usual `#_exists` syntax.\n *\n * nodeExists.#_notexists = relative path (relative from the result node) to\n * another node. This relative path mush NOT exist for this expression to return\n * true -- Multiple exists conditions can be present and need to be prefixed via\n * the usual `#_notexists` syntax.\n *\n * nodeExists.or=true nodeExists.exists=jcr:content/renditions/original\n * nodeExists.2_exists=jcr:content/renditions/cq5dam.thumbnail.48.48.png\n * nodeExists.1_notexists=jcr:content/renditions/cq5dam.web.1280.1280.png\n * nodeExists.2_notexists=jcr:content/renditions/cq5dam.web.600.400.png\n */\n@Component(\n        factory = \"com.day.cq.search.eval.PredicateEvaluator/nodeExists\"\n)\npublic class NodeExistsPredicateEvaluator extends AbstractPredicateEvaluator implements PredicateEvaluator {\n\n    private static final Logger log = LoggerFactory.getLogger(NodeExistsPredicateEvaluator.class);\n\n    public static final String OR = \"or\";\n    public static final String EXISTS_REL_PATH = \"exists\";\n    public static final String NOT_EXISTS_REL_PATH = \"notexists\";\n\n    @Override\n    public final boolean canXpath(final Predicate predicate, final EvaluationContext context) {\n        return false;\n    }\n\n    @Override\n    public final boolean canFilter(final Predicate predicate, final EvaluationContext context) {\n        return !(predicate.getParameters().isEmpty()\n                || (predicate.getParameters().size() == 1\n                && predicate.getParameters().get(OR) != null));\n    }\n\n    @Override\n    @SuppressWarnings(\"squid:S3776\")\n    public final boolean includes(final Predicate predicate, final Row row, final EvaluationContext context) {\n        boolean or = predicate.getBool(OR);\n\n        if (log.isDebugEnabled()) {\n            if (or) {\n                log.debug(\"NodeExistsPredicatorEvaluator evaluating as [ OR ]\");\n            } else {\n                log.debug(\"NodeExistsPredicatorEvaluator evaluating as [ AND ]\");\n            }\n        }\n\n        for (final Map.Entry<String, String> entry : predicate.getParameters().entrySet()) {\n            boolean ruleIncludes = false;\n\n            String operation = entry.getKey();\n            if (StringUtils.contains(operation, \"_\")) {\n                operation = StringUtils.substringAfterLast(entry.getKey(), \"_\");\n            }\n\n            try {\n                if (EXISTS_REL_PATH.equals(operation)) {\n                    ruleIncludes = row.getNode().hasNode(entry.getValue());\n                } else if (NOT_EXISTS_REL_PATH.equals(operation)) {\n                    ruleIncludes = !row.getNode().hasNode(entry.getValue());\n                } else if (!OR.equals(operation)) {\n                    log.debug(\"Invalid operation [ {} ]\", operation);\n                }\n\n                // Return quickly from the evaluation loop\n                if (or && ruleIncludes) {\n                    // If OR condition; return true on the first condition match\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Including [ {} ] based on [ {}  -> {} ] as part of [ OR ]\",\n                                row.getPath(), operation, entry.getValue());\n                    }\n                    return true;\n                } else if (!or && !ruleIncludes) {\n                    // If AND condition; return true on the first condition failure\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Excluding [ {} ] based on [ {}  -> {} ] as part of [ AND ]\",\n                                row.getPath(), operation, entry.getValue());\n                    }\n\n                    return false;\n                }\n            } catch (RepositoryException e) {\n                log.error(\"Unable to check if Node [ {} : {} ] via the nodeExists QueryBuilder predicate\", new String[]{entry.getKey(), entry.getValue()}, e);\n            }\n        }\n\n        if (or) {\n            // For ORs, if a true condition was met in the loop, the method would have already returned true, so must be false.\n            if (log.isDebugEnabled()) {\n                try {\n                    log.debug(\"Excluding [ {} ] based on NOT matching conditions as part of [ OR ]\", row.getPath());\n                } catch (RepositoryException e) {\n                    log.error(\"Could not obtain path from for Result row in predicate evaluator\", e);\n                }\n            }\n            return false;\n        } else {\n            // If ANDs, if a false condition was met in the loop, the method would have already returned false, so must be true.\n            if (log.isDebugEnabled()) {\n                try {\n                    log.debug(\"Include [ {} ] based on ALL matching conditions as part of [ AND ]\", row.getPath());\n                } catch (RepositoryException e) {\n                    log.error(\"Could not obtain path from for Result row in predicate evaluator\", e);\n                }\n            }\n            return true;\n        }\n    }\n}\n"
    },
    "context": [],
    "unresolved_context": [
      "com.day.cq.search.Predicate",
      "com.day.cq.search.eval.AbstractPredicateEvaluator",
      "com.day.cq.search.eval.EvaluationContext",
      "com.day.cq.search.eval.PredicateEvaluator",
      "org.apache.commons.lang3.StringUtils",
      "org.apache.felix.scr.annotations.Component",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.RepositoryException",
      "javax.jcr.query.Row",
      "java.util.Map"
    ],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -21,7 +21,7 @@\n import com.day.cq.search.eval.AbstractPredicateEvaluator;\n import com.day.cq.search.eval.EvaluationContext;\n import com.day.cq.search.eval.PredicateEvaluator;\n-import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.felix.scr.annotations.Component;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;"
  }
}