{
  "repo": {
    "name": "Adobe-Consulting-Services/acs-aem-commons",
    "buggy_commit": "a2cf90935d6166680ad85a9ac045e5060bf202ac",
    "fixed_commit": "be4c5995f48fb4b25d56d6b20485d28d62d76479"
  },
  "input": {
    "language": "Java",
    "issue": {
      "issue_title": "Reduce usage of Apache Commons Lang 2",
      "issue_description": "\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n"
    },
    "buggy_commit_message": "Merge branch 'Adobe-Consulting-Services:master' into master",
    "buggy_file": {
      "buggy_filename": "bundle/src/main/java/com/adobe/acs/commons/dam/impl/ReviewTaskAssetMoverHandler.java",
      "buggy_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.dam.impl;\n\n\nimport com.adobe.acs.commons.cqsearch.QueryUtil;\nimport com.adobe.granite.asset.api.Asset;\nimport com.adobe.granite.asset.api.AssetManager;\nimport com.adobe.granite.asset.api.AssetVersionManager;\nimport com.day.cq.commons.jcr.JcrConstants;\nimport com.day.cq.commons.jcr.JcrUtil;\nimport com.day.cq.dam.api.DamConstants;\nimport com.day.cq.search.PredicateGroup;\nimport com.day.cq.search.Query;\nimport com.day.cq.search.QueryBuilder;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.ConfigurationPolicy;\nimport org.apache.felix.scr.annotations.Properties;\nimport org.apache.felix.scr.annotations.Property;\nimport org.apache.felix.scr.annotations.PropertyOption;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.resource.LoginException;\nimport org.apache.sling.api.resource.PersistenceException;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.api.resource.ResourceResolverFactory;\nimport org.apache.sling.api.resource.ValueMap;\nimport org.apache.sling.commons.osgi.PropertiesUtil;\nimport org.apache.sling.commons.scheduler.ScheduleOptions;\nimport org.apache.sling.commons.scheduler.Scheduler;\nimport org.osgi.service.event.Event;\nimport org.osgi.service.event.EventConstants;\nimport org.osgi.service.event.EventHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.Node;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport java.text.SimpleDateFormat;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n@Component(\n        label = \"ACS AEM Commons - Review Task Move Handler\",\n        description = \"Create an OSGi configuration to enable this feature.\",\n        metatype = true,\n        immediate = true,\n        policy = ConfigurationPolicy.REQUIRE\n)\n@Properties({\n        @Property(\n                label = \"Event Topics\",\n                value = {ReviewTaskAssetMoverHandler.DEFAULT_TOPIC},\n                description = \"[Required] Event Topics this event handler will to respond to. Defaults to: com/adobe/granite/taskmanagement/event\",\n                name = EventConstants.EVENT_TOPIC,\n                propertyPrivate = true\n        ),\n\n        /* Event filters support LDAP filter syntax and have access to event.getProperty(..) values */\n        /* LDAP Query syntax: https://goo.gl/MCX2or */\n        @Property(\n                label = \"Event Filters\",\n                // Only listen on events associated with nodes that end with /jcr:content\n                value = \"(&(TaskTypeName=dam:review)(EventType=TASK_COMPLETED))\",\n                description = \"Event Filters used to further restrict this event handler; Uses LDAP expression against event properties. Defaults to: (&(TaskTypeName=dam:review)(EventType=TASK_COMPLETED))\",\n                name = EventConstants.EVENT_FILTER,\n                propertyPrivate = true\n        )\n})\n@Service\npublic class ReviewTaskAssetMoverHandler implements EventHandler {\n    private static final Logger log = LoggerFactory.getLogger(ReviewTaskAssetMoverHandler.class);\n\n    public static final String DEFAULT_TOPIC = \"com/adobe/granite/taskmanagement/event\";\n    private static final String PATH_CONTENT_DAM = DamConstants.MOUNTPOINT_ASSETS;\n    private static final String APPROVED = \"approved\";\n    private static final String REJECTED = \"rejected\";\n    private static final String REL_ASSET_METADATA = \"jcr:content/metadata\";\n    private static final String REL_ASSET_RENDITIONS = \"jcr:content/renditions\";\n    private static final String REL_PN_DAM_STATUS = REL_ASSET_METADATA + \"/dam:status\";\n\n    private static final String PN_ON_APPROVE = \"onApproveMoveTo\";\n    private static final String PN_ON_REJECT = \"onRejectMoveTo\";\n    private static final String PN_CONTENT_PATH = \"contentPath\";\n    private static final String PN_CONFLICT_RESOLUTION = \"onReviewConflictResolution\";\n    private static final String CONFLICT_RESOLUTION_SKIP = \"skip\";\n    private static final String CONFLICT_RESOLUTION_REPLACE = \"replace\";\n    private static final String CONFLICT_RESOLUTION_NEW_ASSET = \"new-asset\";\n    private static final String CONFLICT_RESOLUTION_NEW_VERSION = \"new-version\";\n\n    public static final String USER_EVENT_TYPE = \"acs-aem-commons.review-task-mover\";\n\n    private static final String SERVICE_NAME = \"review-task-asset-mover\";\n    private static final Map<String, Object> AUTH_INFO;\n\n    static {\n        AUTH_INFO = Collections.singletonMap(ResourceResolverFactory.SUBSERVICE, (Object) SERVICE_NAME);\n    }\n\n    @Reference\n    private ResourceResolverFactory resourceResolverFactory;\n\n    @Reference\n    private Scheduler scheduler;\n\n    @Reference\n    private QueryBuilder queryBuilder;\n\n    private static final String DEFAULT_DEFAULT_CONFLICT_RESOLUTION = CONFLICT_RESOLUTION_NEW_VERSION;\n    private String defaultConflictResolution = DEFAULT_DEFAULT_CONFLICT_RESOLUTION;\n    @Property(label = \"Default Conflict Resolution\",\n            description = \"Select default behavior if conflict resolution is not provided at the review task level.\",\n            options = {\n                    @PropertyOption(name = CONFLICT_RESOLUTION_NEW_VERSION, value = \"Add as version (new-version)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_NEW_ASSET, value = \"Add as new asset (new-asset)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_REPLACE, value = \"Replace (replace)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_SKIP, value = \"Skip (skip)\")\n            },\n            value = DEFAULT_DEFAULT_CONFLICT_RESOLUTION)\n    public static final String PROP_DEFAULT_CONFLICT_RESOLUTION = \"conflict-resolution.default\";\n\n    private static final String DEFAULT_LAST_MODIFIED_BY = \"Review Task\";\n    private String lastModifiedBy = DEFAULT_LAST_MODIFIED_BY;\n    @Property(label = \"Last Modified By\",\n            description = \"For Conflict Resolution: Version, the review task event does not track the user that completed the event. Use this property to specify the static name of of the [dam:Asset]/jcr:content@jcr:lastModifiedBy. Default: Review Task\",\n            value = DEFAULT_LAST_MODIFIED_BY)\n    public static final String PROP_LAST_MODIFIED_BY = \"conflict-resolution.version.last-modified-by\";\n\n\n    @Activate\n    protected void activate(Map<String, Object> config) {\n        lastModifiedBy = PropertiesUtil.toString(config.get(PROP_LAST_MODIFIED_BY), DEFAULT_LAST_MODIFIED_BY);\n        defaultConflictResolution = PropertiesUtil.toString(config.get(PROP_DEFAULT_CONFLICT_RESOLUTION), DEFAULT_DEFAULT_CONFLICT_RESOLUTION);\n    }\n\n    @Override\n    public void handleEvent(Event event) {\n\n        try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(AUTH_INFO)) {\n            final String path = (String) event.getProperty(\"TaskId\");\n            final Resource taskResource = resourceResolver.getResource(path);\n\n            if (taskResource != null) {\n                final ValueMap taskProperties = taskResource.getValueMap();\n\n                // Perform a fast check to see if this project has the required properties to perform the asset moving\n                if (StringUtils.startsWith(taskProperties.get(PN_ON_APPROVE, String.class), PATH_CONTENT_DAM)\n                        || StringUtils.startsWith(taskProperties.get(PN_ON_REJECT, String.class), PATH_CONTENT_DAM)) {\n\n                    log.debug(\"Handling event (creating a Job) for Assets Review Task @ [ {} ]\", path);\n\n                    ScheduleOptions options = scheduler.NOW();\n                    String jobName = this.getClass().getSimpleName().toString().replace(\".\", \"/\") + \"/\" + path;\n                    options.name(jobName);\n\n                    options.canRunConcurrently(false);\n\n                    scheduler.schedule(new ImmediateJob(path), options);\n                }\n            }\n        } catch (LoginException e) {\n            log.error(\"Could not get resource resolver\", e);\n        }\n    }\n\n    private class ImmediateJob implements Runnable {\n        private final String path;\n\n        public ImmediateJob(String path) {\n            this.path = path;\n        }\n\n        @Override\n        public void run() {\n            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(AUTH_INFO)) {\n\n                // Access data passed into the Job from the Event\n                Resource resource = resourceResolver.getResource(path);\n                AssetManager assetManager = resourceResolver.adaptTo(AssetManager.class);\n\n                if (resource != null && assetManager != null) {\n                    ValueMap taskProperties = resource.getValueMap();\n                    String contentPath = taskProperties.get(PN_CONTENT_PATH, String.class);\n\n                    if (StringUtils.startsWith(contentPath, PATH_CONTENT_DAM)) {\n                        Query query = findAssets(resourceResolver, contentPath);\n                        log.debug(\"Found [ {} ] assets under [ {} ] that were reviewed and require processing.\",\n                                query.getResult().getHits().size(),\n                                contentPath);\n\n                        final Iterator<Resource> assets = query.getResult().getResources();\n                        resourceResolver.adaptTo(Session.class).getWorkspace().getObservationManager().setUserData(USER_EVENT_TYPE);\n\n                        while (assets.hasNext()) {\n                            final Asset asset = assetManager.getAsset(assets.next().getPath());\n                            moveAsset(resourceResolver, assetManager, asset, taskProperties);\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                log.error(\"Could not process Review Task Mover\", e);\n            }\n        }\n\n        /**\n         * Find all assets under the Task contentPath that have a dam:status of approved or rejected.\n         *\n         * @param resourceResolver the resource resolver used to find the Assets to move.\n         * @param contentPath      the DAM contentPath which the task covers.\n         * @return the CloseableQuery whose result represents dam:Assets for which dam:status is set to approved or rejected\n         */\n        private Query findAssets(ResourceResolver resourceResolver, String contentPath) {\n            Map<String, String> params = new HashMap<String, String>();\n            params.put(\"type\", DamConstants.NT_DAM_ASSET);\n            params.put(\"path\", contentPath);\n            params.put(\"property\", REL_PN_DAM_STATUS);\n            params.put(\"property.1_value\", APPROVED);\n            params.put(\"property.2_value\", REJECTED);\n            params.put(\"p.offset\", \"0\");\n            params.put(\"p.limit\", \"-1\");\n\n            Query query = queryBuilder.createQuery(PredicateGroup.create(params), resourceResolver.adaptTo(Session.class));\n            QueryUtil.setResourceResolverOn(resourceResolver, query);\n            return query;\n        }\n\n\n        /**\n         * Create a unique asset name based on the current time and a up-to-1000 counter.\n         *\n         * @param assetManager assetManager object\n         * @param destPath     the folder the asset will be moved into\n         * @param assetName    the asset name\n         * @return a unique asset path to the asset\n         * @throws PersistenceException\n         */\n        private String createUniqueAssetPath(AssetManager assetManager, String destPath, String assetName) throws PersistenceException {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n            final String now = sdf.format(new Date());\n            String destAssetPath = destPath + \"/\" + assetName;\n\n            int count = 0;\n            while (assetManager.assetExists(destAssetPath)) {\n                if (count > 1000) {\n                    throw new PersistenceException(\"Unable to generate a unique name after 1000 attempts. Something must be wrong!\");\n                }\n\n                if (count == 0) {\n                    destAssetPath = destPath + \"/\" + now + \"_\" + assetName;\n                } else {\n                    destAssetPath = destPath + \"/\" + now + \"_\" + count + \"_\" + assetName;\n                }\n\n                count++;\n            }\n\n            return destAssetPath;\n        }\n\n        /**\n         * Creates a new revision of an asset and replaces its renditions (including original), and metadata node.\n         *\n         * @param resourceResolver the ResourceResolver object\n         * @param assetManager     the AssetManager object\n         * @param originalAsset    the asset to create a new version for\n         * @param reviewedAsset    the asset to that will represent the new version\n         * @throws PersistenceException\n         */\n        private void createRevision(ResourceResolver resourceResolver, AssetManager assetManager, Asset originalAsset, Asset reviewedAsset) throws PersistenceException {\n            Session session = resourceResolver.adaptTo(Session.class);\n\n            // Create the new version\n            AssetVersionManager versionManager = resourceResolver.adaptTo(AssetVersionManager.class);\n            versionManager.createVersion(originalAsset.getPath(), \"Review Task (\" + reviewedAsset.getValueMap().get(REL_PN_DAM_STATUS, \"Unknown\") + \")\");\n\n            String assetPath = originalAsset.getPath();\n\n            // Delete the existing metadata and renditions from the old asset\n\n            resourceResolver.delete(resourceResolver.getResource(assetPath + \"/\" + REL_ASSET_METADATA));\n            resourceResolver.delete(resourceResolver.getResource(assetPath + \"/\" + REL_ASSET_RENDITIONS));\n\n            try {\n                Node originalAssetJcrContentNode = session.getNode(originalAsset.getPath() + \"/\" + JcrConstants.JCR_CONTENT);\n\n                Node newAssetMetadataNode = session.getNode(reviewedAsset.getPath() + \"/\" + REL_ASSET_METADATA);\n                Node newAssetRenditionsNode = session.getNode(reviewedAsset.getPath() + \"/\" + REL_ASSET_RENDITIONS);\n\n                JcrUtil.copy(newAssetMetadataNode, originalAssetJcrContentNode, null);\n                JcrUtil.copy(newAssetRenditionsNode, originalAssetJcrContentNode, null);\n\n                JcrUtil.setProperty(originalAssetJcrContentNode, JcrConstants.JCR_LASTMODIFIED, new Date());\n                JcrUtil.setProperty(originalAssetJcrContentNode, JcrConstants.JCR_LAST_MODIFIED_BY, lastModifiedBy);\n\n                assetManager.removeAsset(reviewedAsset.getPath());\n            } catch (RepositoryException e) {\n                log.error(\"Could not create a new version of the asset\", e);\n                throw new PersistenceException(e.getMessage());\n            }\n        }\n\n        /**\n         * Move the asset based on the its dam:status (approved or rejected).\n         *\n         * @param asset          the asset to move\n         * @param taskProperties the task properties containing the target onApproveMoveTo and onRejectMoveTo paths\n         */\n        @SuppressWarnings(\"squid:S3776\")\n        private void moveAsset(ResourceResolver resourceResolver, AssetManager assetManager, Asset asset, ValueMap taskProperties) {\n            try {\n                final String status = asset.getValueMap().get(REL_PN_DAM_STATUS, String.class);\n                final String conflictResolution = taskProperties.get(PN_CONFLICT_RESOLUTION, defaultConflictResolution);\n                final String onApprovePath = taskProperties.get(PN_ON_APPROVE, String.class);\n                final String onRejectPath = taskProperties.get(PN_ON_REJECT, String.class);\n\n                String destPath = null;\n\n                if (StringUtils.equals(APPROVED, status)) {\n                    destPath = onApprovePath;\n                } else if (StringUtils.equals(REJECTED, status)) {\n                    destPath = onRejectPath;\n                }\n\n                if (destPath != null) {\n                    if (StringUtils.startsWith(destPath, PATH_CONTENT_DAM)) {\n\n                        String destAssetPath = destPath + \"/\" + asset.getName();\n                        final boolean exists = assetManager.assetExists(destAssetPath);\n\n                        if (exists) {\n                            if (StringUtils.equals(asset.getPath(), destAssetPath)) {\n                                log.info(\"Reviewed asset [ {} ] is already in its final location, so there is nothing to do.\", asset.getPath());\n                            } else if (CONFLICT_RESOLUTION_REPLACE.equals(conflictResolution)) {\n                                assetManager.removeAsset(destAssetPath);\n                                resourceResolver.commit();\n                                assetManager.moveAsset(asset.getPath(), destAssetPath);\n                                log.info(\"Moved with replace [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            } else if (CONFLICT_RESOLUTION_NEW_ASSET.equals(conflictResolution)) {\n                                destAssetPath = createUniqueAssetPath(assetManager, destPath, asset.getName());\n                                assetManager.moveAsset(asset.getPath(), destAssetPath);\n                                log.info(\"Moved with unique asset name [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            } else if (CONFLICT_RESOLUTION_NEW_VERSION.equals(conflictResolution)) {\n                                log.info(\"Creating new version of existing asset [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                                createRevision(resourceResolver, assetManager, assetManager.getAsset(destAssetPath), asset);\n                            } else if (CONFLICT_RESOLUTION_SKIP.equals(conflictResolution)) {\n                                log.info(\"Skipping with due to existing asset at the same destination [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            }\n                        } else {\n                            assetManager.moveAsset(asset.getPath(), destAssetPath);\n                            log.info(\"Moved [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                    asset.getPath(), destAssetPath, status);\n                        }\n                    } else {\n                        log.warn(\"Request to move reviewed asset to a non DAM Asset path [ {} ]\", destPath);\n                    }\n                }\n\n                if (resourceResolver.hasChanges()) {\n                    resourceResolver.commit();\n                }\n            } catch (PersistenceException e) {\n                log.error(\"Could not move reviewed asset [ {} ]\", asset.getPath(), e);\n                resourceResolver.revert();\n                resourceResolver.refresh();\n            }\n        }\n    }\n\n    protected void bindResourceResolverFactory(ResourceResolverFactory resourceResolverFactory) {\n        if (this.resourceResolverFactory == null) {\n            this.resourceResolverFactory = resourceResolverFactory;\n        }\n    }\n\n    protected void unbindResourceResolverFactory(ResourceResolverFactory resourceResolverFactory) {\n        if (this.resourceResolverFactory == resourceResolverFactory) {\n            this.resourceResolverFactory = null;\n        }\n    }\n\n    protected void bindScheduler(Scheduler scheduler) {\n        if (this.scheduler == null) {\n            this.scheduler = scheduler;\n        }\n    }\n\n    protected void unbindScheduler(Scheduler scheduler) {\n        if (this.scheduler == scheduler) {\n            this.scheduler = null;\n        }\n    }\n\n    protected void bindQueryBuilder(QueryBuilder queryBuilder) {\n        if (this.queryBuilder == null) {\n            this.queryBuilder = queryBuilder;\n        }\n    }\n\n    protected void unbindQueryBuilder(QueryBuilder queryBuilder) {\n        if (this.queryBuilder == queryBuilder) {\n            this.queryBuilder = null;\n        }\n    }\n}"
    },
    "context": [
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/cqsearch/QueryUtil.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.cqsearch;\n\nimport com.day.cq.search.Query;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.Field;\n\n/**\n * Simple utility to use as an alternative to deprecated CloseableQuery in older versions of AEM.\n */\npublic final class QueryUtil {\n    private static final Logger log = LoggerFactory.getLogger(QueryUtil.class);\n\n    /**\n     * No constructor.\n     */\n    private QueryUtil() {\n        // private constructor\n    }\n\n    // accepts any object so that the logic itself is unit testable, because we 1) can't extend Query without violating\n    // CQBP84, and 2) we can't expose a writeable resourceResolver field on a Proxy instance.\n    static void internalSetResourceResolverOn(ResourceResolver resolver, Object any)\n            throws NoSuchFieldException, IllegalAccessException {\n        if (any != null) {\n            Class<?> clazz = any.getClass();\n            Field resourceResolverField = clazz.getDeclaredField(\"resourceResolver\");\n            resourceResolverField.setAccessible(true);\n            resourceResolverField.set(any, resolver);\n        }\n    }\n\n    /**\n     * Uses reflection to forcibly set the Query object's ResourceResolver to the provided.\n     */\n    public static void setResourceResolverOn(ResourceResolver resolver, Query query) {\n        try {\n            internalSetResourceResolverOn(resolver, query);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            log.error(\"Could not set ResourceResolver on provided Query: {} => {}\",\n                    e.getClass().getName(), e.getMessage());\n        }\n    }\n}\n"
      }
    ],
    "unresolved_context": [
      "com.adobe.granite.asset.api.Asset",
      "com.adobe.granite.asset.api.AssetManager",
      "com.adobe.granite.asset.api.AssetVersionManager",
      "com.day.cq.commons.jcr.JcrConstants",
      "com.day.cq.commons.jcr.JcrUtil",
      "com.day.cq.dam.api.DamConstants",
      "com.day.cq.search.PredicateGroup",
      "com.day.cq.search.Query",
      "com.day.cq.search.QueryBuilder",
      "org.apache.commons.lang.StringUtils",
      "org.apache.felix.scr.annotations.Activate",
      "org.apache.felix.scr.annotations.Component",
      "org.apache.felix.scr.annotations.ConfigurationPolicy",
      "org.apache.felix.scr.annotations.Properties",
      "org.apache.felix.scr.annotations.Property",
      "org.apache.felix.scr.annotations.PropertyOption",
      "org.apache.felix.scr.annotations.Reference",
      "org.apache.felix.scr.annotations.Service",
      "org.apache.sling.api.resource.LoginException",
      "org.apache.sling.api.resource.PersistenceException",
      "org.apache.sling.api.resource.Resource",
      "org.apache.sling.api.resource.ResourceResolver",
      "org.apache.sling.api.resource.ResourceResolverFactory",
      "org.apache.sling.api.resource.ValueMap",
      "org.apache.sling.commons.osgi.PropertiesUtil",
      "org.apache.sling.commons.scheduler.ScheduleOptions",
      "org.apache.sling.commons.scheduler.Scheduler",
      "org.osgi.service.event.Event",
      "org.osgi.service.event.EventConstants",
      "org.osgi.service.event.EventHandler",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.Node",
      "javax.jcr.RepositoryException",
      "javax.jcr.Session",
      "java.text.SimpleDateFormat",
      "java.util.Collections",
      "java.util.Date",
      "java.util.HashMap",
      "java.util.Iterator",
      "java.util.Map"
    ]
  },
  "output": {
    "language": "Java",
    "fixed_commit_message": "Reduce usage of Apache Commons Lang 2\nThis fixes #3408",
    "fixed_file": {
      "fixed_filename": "bundle/src/main/java/com/adobe/acs/commons/dam/impl/ReviewTaskAssetMoverHandler.java",
      "fixed_code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.dam.impl;\n\n\nimport com.adobe.acs.commons.cqsearch.QueryUtil;\nimport com.adobe.granite.asset.api.Asset;\nimport com.adobe.granite.asset.api.AssetManager;\nimport com.adobe.granite.asset.api.AssetVersionManager;\nimport com.day.cq.commons.jcr.JcrConstants;\nimport com.day.cq.commons.jcr.JcrUtil;\nimport com.day.cq.dam.api.DamConstants;\nimport com.day.cq.search.PredicateGroup;\nimport com.day.cq.search.Query;\nimport com.day.cq.search.QueryBuilder;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.ConfigurationPolicy;\nimport org.apache.felix.scr.annotations.Properties;\nimport org.apache.felix.scr.annotations.Property;\nimport org.apache.felix.scr.annotations.PropertyOption;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.resource.LoginException;\nimport org.apache.sling.api.resource.PersistenceException;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.api.resource.ResourceResolverFactory;\nimport org.apache.sling.api.resource.ValueMap;\nimport org.apache.sling.commons.osgi.PropertiesUtil;\nimport org.apache.sling.commons.scheduler.ScheduleOptions;\nimport org.apache.sling.commons.scheduler.Scheduler;\nimport org.osgi.service.event.Event;\nimport org.osgi.service.event.EventConstants;\nimport org.osgi.service.event.EventHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.Node;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport java.text.SimpleDateFormat;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n@Component(\n        label = \"ACS AEM Commons - Review Task Move Handler\",\n        description = \"Create an OSGi configuration to enable this feature.\",\n        metatype = true,\n        immediate = true,\n        policy = ConfigurationPolicy.REQUIRE\n)\n@Properties({\n        @Property(\n                label = \"Event Topics\",\n                value = {ReviewTaskAssetMoverHandler.DEFAULT_TOPIC},\n                description = \"[Required] Event Topics this event handler will to respond to. Defaults to: com/adobe/granite/taskmanagement/event\",\n                name = EventConstants.EVENT_TOPIC,\n                propertyPrivate = true\n        ),\n\n        /* Event filters support LDAP filter syntax and have access to event.getProperty(..) values */\n        /* LDAP Query syntax: https://goo.gl/MCX2or */\n        @Property(\n                label = \"Event Filters\",\n                // Only listen on events associated with nodes that end with /jcr:content\n                value = \"(&(TaskTypeName=dam:review)(EventType=TASK_COMPLETED))\",\n                description = \"Event Filters used to further restrict this event handler; Uses LDAP expression against event properties. Defaults to: (&(TaskTypeName=dam:review)(EventType=TASK_COMPLETED))\",\n                name = EventConstants.EVENT_FILTER,\n                propertyPrivate = true\n        )\n})\n@Service\npublic class ReviewTaskAssetMoverHandler implements EventHandler {\n    private static final Logger log = LoggerFactory.getLogger(ReviewTaskAssetMoverHandler.class);\n\n    public static final String DEFAULT_TOPIC = \"com/adobe/granite/taskmanagement/event\";\n    private static final String PATH_CONTENT_DAM = DamConstants.MOUNTPOINT_ASSETS;\n    private static final String APPROVED = \"approved\";\n    private static final String REJECTED = \"rejected\";\n    private static final String REL_ASSET_METADATA = \"jcr:content/metadata\";\n    private static final String REL_ASSET_RENDITIONS = \"jcr:content/renditions\";\n    private static final String REL_PN_DAM_STATUS = REL_ASSET_METADATA + \"/dam:status\";\n\n    private static final String PN_ON_APPROVE = \"onApproveMoveTo\";\n    private static final String PN_ON_REJECT = \"onRejectMoveTo\";\n    private static final String PN_CONTENT_PATH = \"contentPath\";\n    private static final String PN_CONFLICT_RESOLUTION = \"onReviewConflictResolution\";\n    private static final String CONFLICT_RESOLUTION_SKIP = \"skip\";\n    private static final String CONFLICT_RESOLUTION_REPLACE = \"replace\";\n    private static final String CONFLICT_RESOLUTION_NEW_ASSET = \"new-asset\";\n    private static final String CONFLICT_RESOLUTION_NEW_VERSION = \"new-version\";\n\n    public static final String USER_EVENT_TYPE = \"acs-aem-commons.review-task-mover\";\n\n    private static final String SERVICE_NAME = \"review-task-asset-mover\";\n    private static final Map<String, Object> AUTH_INFO;\n\n    static {\n        AUTH_INFO = Collections.singletonMap(ResourceResolverFactory.SUBSERVICE, (Object) SERVICE_NAME);\n    }\n\n    @Reference\n    private ResourceResolverFactory resourceResolverFactory;\n\n    @Reference\n    private Scheduler scheduler;\n\n    @Reference\n    private QueryBuilder queryBuilder;\n\n    private static final String DEFAULT_DEFAULT_CONFLICT_RESOLUTION = CONFLICT_RESOLUTION_NEW_VERSION;\n    private String defaultConflictResolution = DEFAULT_DEFAULT_CONFLICT_RESOLUTION;\n    @Property(label = \"Default Conflict Resolution\",\n            description = \"Select default behavior if conflict resolution is not provided at the review task level.\",\n            options = {\n                    @PropertyOption(name = CONFLICT_RESOLUTION_NEW_VERSION, value = \"Add as version (new-version)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_NEW_ASSET, value = \"Add as new asset (new-asset)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_REPLACE, value = \"Replace (replace)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_SKIP, value = \"Skip (skip)\")\n            },\n            value = DEFAULT_DEFAULT_CONFLICT_RESOLUTION)\n    public static final String PROP_DEFAULT_CONFLICT_RESOLUTION = \"conflict-resolution.default\";\n\n    private static final String DEFAULT_LAST_MODIFIED_BY = \"Review Task\";\n    private String lastModifiedBy = DEFAULT_LAST_MODIFIED_BY;\n    @Property(label = \"Last Modified By\",\n            description = \"For Conflict Resolution: Version, the review task event does not track the user that completed the event. Use this property to specify the static name of of the [dam:Asset]/jcr:content@jcr:lastModifiedBy. Default: Review Task\",\n            value = DEFAULT_LAST_MODIFIED_BY)\n    public static final String PROP_LAST_MODIFIED_BY = \"conflict-resolution.version.last-modified-by\";\n\n\n    @Activate\n    protected void activate(Map<String, Object> config) {\n        lastModifiedBy = PropertiesUtil.toString(config.get(PROP_LAST_MODIFIED_BY), DEFAULT_LAST_MODIFIED_BY);\n        defaultConflictResolution = PropertiesUtil.toString(config.get(PROP_DEFAULT_CONFLICT_RESOLUTION), DEFAULT_DEFAULT_CONFLICT_RESOLUTION);\n    }\n\n    @Override\n    public void handleEvent(Event event) {\n\n        try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(AUTH_INFO)) {\n            final String path = (String) event.getProperty(\"TaskId\");\n            final Resource taskResource = resourceResolver.getResource(path);\n\n            if (taskResource != null) {\n                final ValueMap taskProperties = taskResource.getValueMap();\n\n                // Perform a fast check to see if this project has the required properties to perform the asset moving\n                if (StringUtils.startsWith(taskProperties.get(PN_ON_APPROVE, String.class), PATH_CONTENT_DAM)\n                        || StringUtils.startsWith(taskProperties.get(PN_ON_REJECT, String.class), PATH_CONTENT_DAM)) {\n\n                    log.debug(\"Handling event (creating a Job) for Assets Review Task @ [ {} ]\", path);\n\n                    ScheduleOptions options = scheduler.NOW();\n                    String jobName = this.getClass().getSimpleName().toString().replace(\".\", \"/\") + \"/\" + path;\n                    options.name(jobName);\n\n                    options.canRunConcurrently(false);\n\n                    scheduler.schedule(new ImmediateJob(path), options);\n                }\n            }\n        } catch (LoginException e) {\n            log.error(\"Could not get resource resolver\", e);\n        }\n    }\n\n    private class ImmediateJob implements Runnable {\n        private final String path;\n\n        public ImmediateJob(String path) {\n            this.path = path;\n        }\n\n        @Override\n        public void run() {\n            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(AUTH_INFO)) {\n\n                // Access data passed into the Job from the Event\n                Resource resource = resourceResolver.getResource(path);\n                AssetManager assetManager = resourceResolver.adaptTo(AssetManager.class);\n\n                if (resource != null && assetManager != null) {\n                    ValueMap taskProperties = resource.getValueMap();\n                    String contentPath = taskProperties.get(PN_CONTENT_PATH, String.class);\n\n                    if (StringUtils.startsWith(contentPath, PATH_CONTENT_DAM)) {\n                        Query query = findAssets(resourceResolver, contentPath);\n                        log.debug(\"Found [ {} ] assets under [ {} ] that were reviewed and require processing.\",\n                                query.getResult().getHits().size(),\n                                contentPath);\n\n                        final Iterator<Resource> assets = query.getResult().getResources();\n                        resourceResolver.adaptTo(Session.class).getWorkspace().getObservationManager().setUserData(USER_EVENT_TYPE);\n\n                        while (assets.hasNext()) {\n                            final Asset asset = assetManager.getAsset(assets.next().getPath());\n                            moveAsset(resourceResolver, assetManager, asset, taskProperties);\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                log.error(\"Could not process Review Task Mover\", e);\n            }\n        }\n\n        /**\n         * Find all assets under the Task contentPath that have a dam:status of approved or rejected.\n         *\n         * @param resourceResolver the resource resolver used to find the Assets to move.\n         * @param contentPath      the DAM contentPath which the task covers.\n         * @return the CloseableQuery whose result represents dam:Assets for which dam:status is set to approved or rejected\n         */\n        private Query findAssets(ResourceResolver resourceResolver, String contentPath) {\n            Map<String, String> params = new HashMap<String, String>();\n            params.put(\"type\", DamConstants.NT_DAM_ASSET);\n            params.put(\"path\", contentPath);\n            params.put(\"property\", REL_PN_DAM_STATUS);\n            params.put(\"property.1_value\", APPROVED);\n            params.put(\"property.2_value\", REJECTED);\n            params.put(\"p.offset\", \"0\");\n            params.put(\"p.limit\", \"-1\");\n\n            Query query = queryBuilder.createQuery(PredicateGroup.create(params), resourceResolver.adaptTo(Session.class));\n            QueryUtil.setResourceResolverOn(resourceResolver, query);\n            return query;\n        }\n\n\n        /**\n         * Create a unique asset name based on the current time and a up-to-1000 counter.\n         *\n         * @param assetManager assetManager object\n         * @param destPath     the folder the asset will be moved into\n         * @param assetName    the asset name\n         * @return a unique asset path to the asset\n         * @throws PersistenceException\n         */\n        private String createUniqueAssetPath(AssetManager assetManager, String destPath, String assetName) throws PersistenceException {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n            final String now = sdf.format(new Date());\n            String destAssetPath = destPath + \"/\" + assetName;\n\n            int count = 0;\n            while (assetManager.assetExists(destAssetPath)) {\n                if (count > 1000) {\n                    throw new PersistenceException(\"Unable to generate a unique name after 1000 attempts. Something must be wrong!\");\n                }\n\n                if (count == 0) {\n                    destAssetPath = destPath + \"/\" + now + \"_\" + assetName;\n                } else {\n                    destAssetPath = destPath + \"/\" + now + \"_\" + count + \"_\" + assetName;\n                }\n\n                count++;\n            }\n\n            return destAssetPath;\n        }\n\n        /**\n         * Creates a new revision of an asset and replaces its renditions (including original), and metadata node.\n         *\n         * @param resourceResolver the ResourceResolver object\n         * @param assetManager     the AssetManager object\n         * @param originalAsset    the asset to create a new version for\n         * @param reviewedAsset    the asset to that will represent the new version\n         * @throws PersistenceException\n         */\n        private void createRevision(ResourceResolver resourceResolver, AssetManager assetManager, Asset originalAsset, Asset reviewedAsset) throws PersistenceException {\n            Session session = resourceResolver.adaptTo(Session.class);\n\n            // Create the new version\n            AssetVersionManager versionManager = resourceResolver.adaptTo(AssetVersionManager.class);\n            versionManager.createVersion(originalAsset.getPath(), \"Review Task (\" + reviewedAsset.getValueMap().get(REL_PN_DAM_STATUS, \"Unknown\") + \")\");\n\n            String assetPath = originalAsset.getPath();\n\n            // Delete the existing metadata and renditions from the old asset\n\n            resourceResolver.delete(resourceResolver.getResource(assetPath + \"/\" + REL_ASSET_METADATA));\n            resourceResolver.delete(resourceResolver.getResource(assetPath + \"/\" + REL_ASSET_RENDITIONS));\n\n            try {\n                Node originalAssetJcrContentNode = session.getNode(originalAsset.getPath() + \"/\" + JcrConstants.JCR_CONTENT);\n\n                Node newAssetMetadataNode = session.getNode(reviewedAsset.getPath() + \"/\" + REL_ASSET_METADATA);\n                Node newAssetRenditionsNode = session.getNode(reviewedAsset.getPath() + \"/\" + REL_ASSET_RENDITIONS);\n\n                JcrUtil.copy(newAssetMetadataNode, originalAssetJcrContentNode, null);\n                JcrUtil.copy(newAssetRenditionsNode, originalAssetJcrContentNode, null);\n\n                JcrUtil.setProperty(originalAssetJcrContentNode, JcrConstants.JCR_LASTMODIFIED, new Date());\n                JcrUtil.setProperty(originalAssetJcrContentNode, JcrConstants.JCR_LAST_MODIFIED_BY, lastModifiedBy);\n\n                assetManager.removeAsset(reviewedAsset.getPath());\n            } catch (RepositoryException e) {\n                log.error(\"Could not create a new version of the asset\", e);\n                throw new PersistenceException(e.getMessage());\n            }\n        }\n\n        /**\n         * Move the asset based on the its dam:status (approved or rejected).\n         *\n         * @param asset          the asset to move\n         * @param taskProperties the task properties containing the target onApproveMoveTo and onRejectMoveTo paths\n         */\n        @SuppressWarnings(\"squid:S3776\")\n        private void moveAsset(ResourceResolver resourceResolver, AssetManager assetManager, Asset asset, ValueMap taskProperties) {\n            try {\n                final String status = asset.getValueMap().get(REL_PN_DAM_STATUS, String.class);\n                final String conflictResolution = taskProperties.get(PN_CONFLICT_RESOLUTION, defaultConflictResolution);\n                final String onApprovePath = taskProperties.get(PN_ON_APPROVE, String.class);\n                final String onRejectPath = taskProperties.get(PN_ON_REJECT, String.class);\n\n                String destPath = null;\n\n                if (StringUtils.equals(APPROVED, status)) {\n                    destPath = onApprovePath;\n                } else if (StringUtils.equals(REJECTED, status)) {\n                    destPath = onRejectPath;\n                }\n\n                if (destPath != null) {\n                    if (StringUtils.startsWith(destPath, PATH_CONTENT_DAM)) {\n\n                        String destAssetPath = destPath + \"/\" + asset.getName();\n                        final boolean exists = assetManager.assetExists(destAssetPath);\n\n                        if (exists) {\n                            if (StringUtils.equals(asset.getPath(), destAssetPath)) {\n                                log.info(\"Reviewed asset [ {} ] is already in its final location, so there is nothing to do.\", asset.getPath());\n                            } else if (CONFLICT_RESOLUTION_REPLACE.equals(conflictResolution)) {\n                                assetManager.removeAsset(destAssetPath);\n                                resourceResolver.commit();\n                                assetManager.moveAsset(asset.getPath(), destAssetPath);\n                                log.info(\"Moved with replace [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            } else if (CONFLICT_RESOLUTION_NEW_ASSET.equals(conflictResolution)) {\n                                destAssetPath = createUniqueAssetPath(assetManager, destPath, asset.getName());\n                                assetManager.moveAsset(asset.getPath(), destAssetPath);\n                                log.info(\"Moved with unique asset name [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            } else if (CONFLICT_RESOLUTION_NEW_VERSION.equals(conflictResolution)) {\n                                log.info(\"Creating new version of existing asset [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                                createRevision(resourceResolver, assetManager, assetManager.getAsset(destAssetPath), asset);\n                            } else if (CONFLICT_RESOLUTION_SKIP.equals(conflictResolution)) {\n                                log.info(\"Skipping with due to existing asset at the same destination [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            }\n                        } else {\n                            assetManager.moveAsset(asset.getPath(), destAssetPath);\n                            log.info(\"Moved [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                    asset.getPath(), destAssetPath, status);\n                        }\n                    } else {\n                        log.warn(\"Request to move reviewed asset to a non DAM Asset path [ {} ]\", destPath);\n                    }\n                }\n\n                if (resourceResolver.hasChanges()) {\n                    resourceResolver.commit();\n                }\n            } catch (PersistenceException e) {\n                log.error(\"Could not move reviewed asset [ {} ]\", asset.getPath(), e);\n                resourceResolver.revert();\n                resourceResolver.refresh();\n            }\n        }\n    }\n\n    protected void bindResourceResolverFactory(ResourceResolverFactory resourceResolverFactory) {\n        if (this.resourceResolverFactory == null) {\n            this.resourceResolverFactory = resourceResolverFactory;\n        }\n    }\n\n    protected void unbindResourceResolverFactory(ResourceResolverFactory resourceResolverFactory) {\n        if (this.resourceResolverFactory == resourceResolverFactory) {\n            this.resourceResolverFactory = null;\n        }\n    }\n\n    protected void bindScheduler(Scheduler scheduler) {\n        if (this.scheduler == null) {\n            this.scheduler = scheduler;\n        }\n    }\n\n    protected void unbindScheduler(Scheduler scheduler) {\n        if (this.scheduler == scheduler) {\n            this.scheduler = null;\n        }\n    }\n\n    protected void bindQueryBuilder(QueryBuilder queryBuilder) {\n        if (this.queryBuilder == null) {\n            this.queryBuilder = queryBuilder;\n        }\n    }\n\n    protected void unbindQueryBuilder(QueryBuilder queryBuilder) {\n        if (this.queryBuilder == queryBuilder) {\n            this.queryBuilder = null;\n        }\n    }\n}"
    },
    "context": [
      {
        "filename": "bundle/src/main/java/com/adobe/acs/commons/cqsearch/QueryUtil.java",
        "code": "/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.cqsearch;\n\nimport com.day.cq.search.Query;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.Field;\n\n/**\n * Simple utility to use as an alternative to deprecated CloseableQuery in older versions of AEM.\n */\npublic final class QueryUtil {\n    private static final Logger log = LoggerFactory.getLogger(QueryUtil.class);\n\n    /**\n     * No constructor.\n     */\n    private QueryUtil() {\n        // private constructor\n    }\n\n    // accepts any object so that the logic itself is unit testable, because we 1) can't extend Query without violating\n    // CQBP84, and 2) we can't expose a writeable resourceResolver field on a Proxy instance.\n    static void internalSetResourceResolverOn(ResourceResolver resolver, Object any)\n            throws NoSuchFieldException, IllegalAccessException {\n        if (any != null) {\n            Class<?> clazz = any.getClass();\n            Field resourceResolverField = clazz.getDeclaredField(\"resourceResolver\");\n            resourceResolverField.setAccessible(true);\n            resourceResolverField.set(any, resolver);\n        }\n    }\n\n    /**\n     * Uses reflection to forcibly set the Query object's ResourceResolver to the provided.\n     */\n    public static void setResourceResolverOn(ResourceResolver resolver, Query query) {\n        try {\n            internalSetResourceResolverOn(resolver, query);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            log.error(\"Could not set ResourceResolver on provided Query: {} => {}\",\n                    e.getClass().getName(), e.getMessage());\n        }\n    }\n}\n"
      }
    ],
    "unresolved_context": [
      "com.adobe.granite.asset.api.Asset",
      "com.adobe.granite.asset.api.AssetManager",
      "com.adobe.granite.asset.api.AssetVersionManager",
      "com.day.cq.commons.jcr.JcrConstants",
      "com.day.cq.commons.jcr.JcrUtil",
      "com.day.cq.dam.api.DamConstants",
      "com.day.cq.search.PredicateGroup",
      "com.day.cq.search.Query",
      "com.day.cq.search.QueryBuilder",
      "org.apache.commons.lang3.StringUtils",
      "org.apache.felix.scr.annotations.Activate",
      "org.apache.felix.scr.annotations.Component",
      "org.apache.felix.scr.annotations.ConfigurationPolicy",
      "org.apache.felix.scr.annotations.Properties",
      "org.apache.felix.scr.annotations.Property",
      "org.apache.felix.scr.annotations.PropertyOption",
      "org.apache.felix.scr.annotations.Reference",
      "org.apache.felix.scr.annotations.Service",
      "org.apache.sling.api.resource.LoginException",
      "org.apache.sling.api.resource.PersistenceException",
      "org.apache.sling.api.resource.Resource",
      "org.apache.sling.api.resource.ResourceResolver",
      "org.apache.sling.api.resource.ResourceResolverFactory",
      "org.apache.sling.api.resource.ValueMap",
      "org.apache.sling.commons.osgi.PropertiesUtil",
      "org.apache.sling.commons.scheduler.ScheduleOptions",
      "org.apache.sling.commons.scheduler.Scheduler",
      "org.osgi.service.event.Event",
      "org.osgi.service.event.EventConstants",
      "org.osgi.service.event.EventHandler",
      "org.slf4j.Logger",
      "org.slf4j.LoggerFactory",
      "javax.jcr.Node",
      "javax.jcr.RepositoryException",
      "javax.jcr.Session",
      "java.text.SimpleDateFormat",
      "java.util.Collections",
      "java.util.Date",
      "java.util.HashMap",
      "java.util.Iterator",
      "java.util.Map"
    ],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -29,7 +29,7 @@\n import com.day.cq.search.PredicateGroup;\n import com.day.cq.search.Query;\n import com.day.cq.search.QueryBuilder;\n-import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.felix.scr.annotations.Activate;\n import org.apache.felix.scr.annotations.Component;\n import org.apache.felix.scr.annotations.ConfigurationPolicy;"
  }
}