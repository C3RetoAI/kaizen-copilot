{
  "repo": {
    "name": "3Hren/blackhole",
    "buggy_commit": "2aebfb1e2e8a9a6a93b907f4a82f694d35fdc97b",
    "fixed_commit": "e043fa9933fd4106248f46968ad2ddfbf85d29af"
  },
  "input": {
    "language": "C++",
    "issue": {
      "issue_title": "Implement factory for UDP sink",
      "issue_description": ""
    },
    "buggy_commit_message": "fix(): add maybe required include\n\nOn GCC 5.3 with boost 1.58 the changed file did not compile without\nthat include.",
    "buggy_file": {
      "buggy_filename": "src/sink/socket/udp.cpp",
      "buggy_code": "#include \"blackhole/sink/socket/udp.hpp\"\n\n#include <boost/asio/ip/udp.hpp>\n#include <boost/lexical_cast.hpp>\n\n#include \"blackhole/cpp17/string_view.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace sink {\nnamespace socket {\n\nnamespace udp {\n\nclass inner_t {\npublic:\n    virtual ~inner_t() {}\n    virtual auto write(const string_view& data) -> void = 0;\n};\n\nclass blocking_t : public inner_t {\n    boost::asio::io_service io_service;\n    boost::asio::ip::udp::socket socket;\n    boost::asio::ip::udp::endpoint endpoint;\n\npublic:\n    blocking_t(const std::string& host, std::uint16_t port) :\n        io_service(),\n        socket(io_service)\n    {\n        boost::asio::ip::udp::resolver resolver(io_service);\n        boost::asio::ip::udp::resolver::query query(host, boost::lexical_cast<std::string>(port),\n            boost::asio::ip::udp::resolver::query::flags::numeric_service);\n        endpoint = *resolver.resolve(query);\n    }\n\n    auto write(const string_view& data) -> void {\n        socket.send_to(boost::asio::buffer(data.data(), data.size()), endpoint);\n    }\n};\n\nclass nonblocking_t : public inner_t {\npublic:\n};\n\n}  // namespace udp\n\nudp_t::udp_t(const std::string& host, std::uint16_t port) :\n    inner(new udp::blocking_t(host, port))\n{}\n\nudp_t::~udp_t() = default;\n\nauto udp_t::filter(const record_t&) -> bool {\n    return true;\n}\n\nauto udp_t::emit(const record_t&, const string_view& formatted) -> void {\n    inner->write(formatted);\n}\n\n}  // namespace socket\n}  // namespace sink\n\nauto factory<sink::socket::udp_t>::type() -> const char* {\n    return \"udp\";\n}\n\n}  // namespace v1\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "include/blackhole/sink/socket/udp.hpp",
        "code": "#pragma once\n\n#include \"blackhole/sink.hpp\"\n\n#include <memory>\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<typename>\nstruct factory;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace sink {\nnamespace socket {\n\nnamespace udp {\n\nclass inner_t;\n\n}  // namespace udp\n\nclass udp_t : public sink_t {\n    std::unique_ptr<udp::inner_t> inner;\n\npublic:\n    udp_t(const std::string& host, std::uint16_t port);\n\n    udp_t(const udp_t& other) = delete;\n    udp_t(udp_t&& other) noexcept;\n\n    ~udp_t();\n\n    auto operator=(const udp_t& other) -> udp_t& = delete;\n    auto operator=(udp_t&& other) noexcept -> udp_t&;\n\n    auto filter(const record_t& record) -> bool;\n\n    auto emit(const record_t& record, const string_view& message) -> void;\n};\n\n// builder<socket::udp_t>()\n//     .host(std::string)\n//     .port(std::uint16_t)\n//     .nonblocking()\n//     .build();\n\n}  // namespace socket\n}  // namespace sink\n\ntemplate<>\nstruct factory<sink::socket::udp_t> {\n    static auto type() -> const char*;\n    static auto from(const config::node_t& config) -> sink::socket::udp_t;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/cpp17/string_view.hpp",
        "code": "#pragma once\n\n#include <iosfwd>\n#include <limits>\n#include <stdexcept>\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace cpp17 {\n\n/// The class template `basic_string_view` describes an object that can refer to a constant\n/// contiguous sequence of char-like objects with the first element of the sequence at position\n/// zero.\n///\n/// A typical implementation holds only two members: a pointer to constant Char and a size.\n///\n/// \\tparam Char - character type.\n/// \\tparam Traits - traits class specifying the operations on the character type.\ntemplate<typename Char, typename Traits = std::char_traits<Char>>\nclass basic_string_view {\npublic:\n    /// This is a special value equal to the maximum value representable by the type size_type.\n    ///\n    /// The exact meaning depends on context, but it is generally used either as end of view\n    /// indicator by the functions that expect a view index or as the error indicator by the\n    /// functions that return a view index.\n    static constexpr std::size_t npos = std::numeric_limits<std::size_t>::max();\n\n    typedef Char value_type;\n    typedef Traits traits_type;\n    typedef Char* pointer;\n    typedef const Char* const_pointer;\n    typedef Char& reference;\n    typedef const Char& const_reference;\n\n    typedef std::size_t size_type;\n\nprivate:\n    const_pointer data_;\n\n    /// Size without \\0.\n    size_type size_;\n\npublic:\n    /// Constructs an empty string view.\n    constexpr basic_string_view() noexcept:\n        data_(nullptr),\n        size_(0)\n    {}\n\n    /// Constructs a view of the null-terminated character string pointed to by `literal`, not\n    /// including the terminating null character.\n    template<size_type N>\n    constexpr basic_string_view(const Char(&literal)[N]) noexcept :\n        data_(literal),\n        size_(N - 1)\n    {}\n\n    /// Constructs a view of the first `size` characters of the character array starting with the\n    /// element pointed by `literal`.\n    ///\n    /// The `literal` can contain null characters.\n    /// The behavior is undefined if [literal, literal + size) is not a valid range (even though the\n    /// constructor may not access any of the elements of this range).\n    constexpr basic_string_view(const Char* literal, std::size_t size) noexcept :\n        data_(literal),\n        size_(size)\n    {}\n\n    /// Constructs a view of the first `string.size()` characters of the character array starting\n    /// with the element pointed by `string.data()`.\n    template<typename Allocator>\n    basic_string_view(const std::basic_string<Char, Traits, Allocator>& string) noexcept :\n        data_(string.data()),\n        size_(string.size())\n    {}\n\n    /// Constructs a view of the same content as other.\n    constexpr basic_string_view(const basic_string_view& other) = default;\n\n    /// Replaces the view with the given other view.\n    auto operator=(const basic_string_view& other) -> basic_string_view& = default;\n\n    /// Returns a pointer to the underlying character array.\n    ///\n    /// The pointer is such that the range [data(); data() + size()) is valid and the values in it\n    /// correspond to the values of the view.\n    ///\n    /// \\note unlike `basic_string::data()` and string literals, `data()` may return a pointer to a\n    /// buffer that is not null-terminated. Therefore it is typically a mistake to pass `data()` to\n    /// a routine that takes just a const Char* and expects a null-terminated string.\n    constexpr auto data() const noexcept -> const_pointer {\n        return data_;\n    }\n\n    /// Returns the number of Char elements in the view.\n    constexpr auto size() const noexcept -> size_type {\n        return size_;\n    }\n\n    /// Returns a const reference to the character at specified location `id`.\n    constexpr auto operator[](std::size_t id) const -> char {\n        return id < size() ?\n            data_[id] :\n            throw std::out_of_range(\"out of range\");\n    }\n\n    /// Operations.\n\n    /// Creates a `basic_string` with a copy of the content of the current view.\n    template<class Allocator = std::allocator<Char>>\n    auto to_string(const Allocator& alloc = Allocator()) const ->\n        std::basic_string<Char, Traits, Allocator>\n    {\n        return {data(), size(), alloc};\n    }\n\n    /// Returns a view of the substring [pos, pos + rcount), where rcount is the smaller of count\n    /// and `size() - pos`.\n    constexpr\n    auto substr(std::size_t pos = 0, std::size_t count = npos) const -> basic_string_view {\n        return pos <= size() ?\n            basic_string_view(data() + pos, std::min(count, size() - pos)) :\n            throw std::out_of_range(\"out of range\");\n    }\n\n    /// Compares two views.\n    ///\n    /// All comparisons are done via the `compare()` member function, which itself is defined in\n    /// terms of `Traits::compare()`.\n    /// Two views are equal if both the size of `this` and `other` are equal and each character in\n    /// `this` has an equivalent character in `other` at the same position.\n    constexpr auto operator==(const basic_string_view& other) const noexcept -> bool {\n        return size() == other.size() && traits_type::compare(data(), other.data(), size()) == 0;\n    }\n};\n\ntemplate<typename Char, typename Traits >\nconstexpr auto operator<(basic_string_view<Char, Traits> lhs, basic_string_view<Char, Traits> rhs) ->\n    bool\n{\n    return std::lexicographical_compare(lhs.data(), lhs.data() + lhs.size(),\n        rhs.data(), rhs.data() + rhs.size());\n}\n\ntemplate<class Char, class Traits>\nauto operator<<(std::basic_ostream<Char, Traits>& stream, const basic_string_view<Char, Traits>& value) ->\n    std::basic_ostream<Char, Traits>&\n{\n    return stream << value.to_string();\n}\n\n/// Several typedefs for common character types are provided:\ntypedef basic_string_view<char> string_view;\n\n}  // namespace cpp17\n\nusing cpp17::string_view;\n\n}  // namespace v1\n}  // namespace blackhole\n"
      }
    ],
    "unresolved_context": []
  },
  "output": {
    "language": "C++",
    "fixed_commit_message": "feat(sink/udp): implement factory\n\nCloses #88.",
    "fixed_file": {
      "fixed_filename": "src/sink/socket/udp.cpp",
      "fixed_code": "#include \"blackhole/sink/socket/udp.hpp\"\n\n#include <boost/asio/ip/udp.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/optional/optional.hpp>\n\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/cpp17/string_view.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace sink {\nnamespace socket {\n\nnamespace udp {\n\nclass inner_t {\npublic:\n    virtual ~inner_t() {}\n    virtual auto write(const string_view& data) -> void = 0;\n};\n\nclass blocking_t : public inner_t {\n    boost::asio::io_service io_service;\n    boost::asio::ip::udp::socket socket;\n    boost::asio::ip::udp::endpoint endpoint;\n\npublic:\n    blocking_t(const std::string& host, std::uint16_t port) :\n        io_service(),\n        socket(io_service)\n    {\n        boost::asio::ip::udp::resolver resolver(io_service);\n        boost::asio::ip::udp::resolver::query query(host, boost::lexical_cast<std::string>(port),\n            boost::asio::ip::udp::resolver::query::flags::numeric_service);\n        endpoint = *resolver.resolve(query);\n    }\n\n    auto write(const string_view& data) -> void {\n        socket.send_to(boost::asio::buffer(data.data(), data.size()), endpoint);\n    }\n};\n\nclass nonblocking_t : public inner_t {\npublic:\n};\n\n}  // namespace udp\n\nudp_t::udp_t(const std::string& host, std::uint16_t port) :\n    inner(new udp::blocking_t(host, port))\n{}\n\nudp_t::~udp_t() = default;\n\nauto udp_t::filter(const record_t&) -> bool {\n    return true;\n}\n\nauto udp_t::emit(const record_t&, const string_view& formatted) -> void {\n    inner->write(formatted);\n}\n\n}  // namespace socket\n}  // namespace sink\n\nauto factory<sink::socket::udp_t>::type() -> const char* {\n    return \"udp\";\n}\n\nauto factory<sink::socket::udp_t>::from(const config::node_t& config) -> sink::socket::udp_t {\n    const auto host = config[\"host\"].to_string().get();\n    const auto port = config[\"port\"].to_uint64().get();\n\n    return {host, static_cast<std::uint16_t>(port)};\n}\n\n}  // namespace v1\n}  // namespace blackhole\n"
    },
    "context": [
      {
        "filename": "include/blackhole/sink/socket/udp.hpp",
        "code": "#pragma once\n\n#include \"blackhole/sink.hpp\"\n\n#include <memory>\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<typename>\nstruct factory;\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace sink {\nnamespace socket {\n\nnamespace udp {\n\nclass inner_t;\n\n}  // namespace udp\n\nclass udp_t : public sink_t {\n    std::unique_ptr<udp::inner_t> inner;\n\npublic:\n    udp_t(const std::string& host, std::uint16_t port);\n\n    udp_t(const udp_t& other) = delete;\n    udp_t(udp_t&& other) noexcept;\n\n    ~udp_t();\n\n    auto operator=(const udp_t& other) -> udp_t& = delete;\n    auto operator=(udp_t&& other) noexcept -> udp_t&;\n\n    auto filter(const record_t& record) -> bool;\n\n    auto emit(const record_t& record, const string_view& message) -> void;\n};\n\n// builder<socket::udp_t>()\n//     .host(std::string)\n//     .port(std::uint16_t)\n//     .nonblocking()\n//     .build();\n\n}  // namespace socket\n}  // namespace sink\n\ntemplate<>\nstruct factory<sink::socket::udp_t> {\n    static auto type() -> const char*;\n    static auto from(const config::node_t& config) -> sink::socket::udp_t;\n};\n\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/node.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\ntemplate<typename T>\nclass option;\n\n/// Represents the configuration tree node.\n///\n/// Blackhole operates with instances of this class while configuring the logging system from some\n/// generic source, from file for example. It assumes that the whole configuration can be described\n/// using tree data structure, like JSON, XML or YAML.\n/// To be able to initialize from your own data format you must create subclass and implement its\n/// converting methods as like as tree traversing using subscription operators.\nclass node_t {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\npublic:\n    virtual ~node_t() = 0;\n\n    /// Tries to convert the underlying object to bool.\n    virtual auto to_bool() const -> bool = 0;\n\n    /// Tries to convert the underlying object to signed integer.\n    virtual auto to_sint64() const -> std::int64_t = 0;\n\n    /// Tries to convert the underlying object to unsigned integer.\n    virtual auto to_uint64() const -> std::uint64_t = 0;\n\n    /// Tries to convert the underlying object to double.\n    virtual auto to_double() const -> double = 0;\n\n    /// Tries to convert the underlying object to string.\n    virtual auto to_string() const -> std::string = 0;\n\n    /// Assuming that the underlying object is an array, performs inner iteration over it by\n    /// applying the given function to each element.\n    ///\n    /// Should do nothing either if there is no underlying array or it is empty.\n    virtual auto each(const each_function& fn) const -> void = 0;\n\n    /// Assuming that the underlying object is a map, performs inner iteration over it by applying\n    /// the given function to each key-value element.\n    ///\n    /// Should do nothing either if there is no underlying map or it is empty.\n    virtual auto each_map(const member_function& fn) const -> void = 0;\n\n    /// Assuming that the underlying object is an array performs index operation returning the\n    /// option object with some node at the given index on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::size_t& idx) const -> option<node_t> = 0;\n\n    /// Assuming that the underlying object is a map performs tree traversing operation returning\n    /// option object with some node at the given key on success, none otherwise.\n    ///\n    /// Depending on the concrete implementation it may or not throw exceptions on out of range\n    /// access.\n    virtual auto operator[](const std::string& key) const -> option<node_t> = 0;\n};\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/config/option.hpp",
        "code": "#pragma once\n\n#include <cstdint>\n#include <functional>\n#include <memory>\n#include <string>\n\n#include <boost/optional/optional_fwd.hpp>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace config {\n\nclass node_t;\n\ntemplate<typename T>\nclass option;\n\ntemplate<>\nclass option<node_t> {\npublic:\n    typedef std::function<auto(const node_t& node) -> void> each_function;\n    typedef std::function<auto(const std::string& key, const node_t& node) -> void> member_function;\n\nprivate:\n    std::unique_ptr<node_t> node;\n\npublic:\n    /// Constructs an option object that will contan nothing.\n    option() noexcept;\n\n    /// Constructs an option object that will contain the specified configuration node.\n    explicit option(std::unique_ptr<node_t> node) noexcept;\n\n    explicit operator bool() const noexcept;\n\n    /// Unwraps an option, yielding the content of an underlying config node object.\n    auto unwrap() const -> boost::optional<const node_t&>;\n\n    auto to_bool() const -> boost::optional<bool>;\n    auto to_sint64() const -> boost::optional<std::int64_t>;\n    auto to_uint64() const -> boost::optional<std::uint64_t>;\n    auto to_double() const -> boost::optional<double>;\n    auto to_string() const -> boost::optional<std::string>;\n\n    auto each(const each_function& fn) const -> void;\n    auto each_map(const member_function& fn) const -> void;\n\n    auto operator[](const std::size_t& idx) const -> option<node_t>;\n    auto operator[](const std::string& key) const -> option<node_t>;\n\nprivate:\n    template<typename F>\n    auto to(F&& fn) const -> decltype(fn());\n};\n\n/// Constructs an option of the specified configuration node type using given arguments.\ntemplate<typename T, typename... Args>\nauto make_option(Args&&... args) -> option<node_t> {\n    return option<node_t>(std::unique_ptr<T>(new T(std::forward<Args>(args)...)));\n}\n\n}  // namespace config\n}  // namespace v1\n}  // namespace blackhole\n"
      },
      {
        "filename": "include/blackhole/cpp17/string_view.hpp",
        "code": "#pragma once\n\n#include <iosfwd>\n#include <limits>\n#include <stdexcept>\n#include <string>\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace cpp17 {\n\n/// The class template `basic_string_view` describes an object that can refer to a constant\n/// contiguous sequence of char-like objects with the first element of the sequence at position\n/// zero.\n///\n/// A typical implementation holds only two members: a pointer to constant Char and a size.\n///\n/// \\tparam Char - character type.\n/// \\tparam Traits - traits class specifying the operations on the character type.\ntemplate<typename Char, typename Traits = std::char_traits<Char>>\nclass basic_string_view {\npublic:\n    /// This is a special value equal to the maximum value representable by the type size_type.\n    ///\n    /// The exact meaning depends on context, but it is generally used either as end of view\n    /// indicator by the functions that expect a view index or as the error indicator by the\n    /// functions that return a view index.\n    static constexpr std::size_t npos = std::numeric_limits<std::size_t>::max();\n\n    typedef Char value_type;\n    typedef Traits traits_type;\n    typedef Char* pointer;\n    typedef const Char* const_pointer;\n    typedef Char& reference;\n    typedef const Char& const_reference;\n\n    typedef std::size_t size_type;\n\nprivate:\n    const_pointer data_;\n\n    /// Size without \\0.\n    size_type size_;\n\npublic:\n    /// Constructs an empty string view.\n    constexpr basic_string_view() noexcept:\n        data_(nullptr),\n        size_(0)\n    {}\n\n    /// Constructs a view of the null-terminated character string pointed to by `literal`, not\n    /// including the terminating null character.\n    template<size_type N>\n    constexpr basic_string_view(const Char(&literal)[N]) noexcept :\n        data_(literal),\n        size_(N - 1)\n    {}\n\n    /// Constructs a view of the first `size` characters of the character array starting with the\n    /// element pointed by `literal`.\n    ///\n    /// The `literal` can contain null characters.\n    /// The behavior is undefined if [literal, literal + size) is not a valid range (even though the\n    /// constructor may not access any of the elements of this range).\n    constexpr basic_string_view(const Char* literal, std::size_t size) noexcept :\n        data_(literal),\n        size_(size)\n    {}\n\n    /// Constructs a view of the first `string.size()` characters of the character array starting\n    /// with the element pointed by `string.data()`.\n    template<typename Allocator>\n    basic_string_view(const std::basic_string<Char, Traits, Allocator>& string) noexcept :\n        data_(string.data()),\n        size_(string.size())\n    {}\n\n    /// Constructs a view of the same content as other.\n    constexpr basic_string_view(const basic_string_view& other) = default;\n\n    /// Replaces the view with the given other view.\n    auto operator=(const basic_string_view& other) -> basic_string_view& = default;\n\n    /// Returns a pointer to the underlying character array.\n    ///\n    /// The pointer is such that the range [data(); data() + size()) is valid and the values in it\n    /// correspond to the values of the view.\n    ///\n    /// \\note unlike `basic_string::data()` and string literals, `data()` may return a pointer to a\n    /// buffer that is not null-terminated. Therefore it is typically a mistake to pass `data()` to\n    /// a routine that takes just a const Char* and expects a null-terminated string.\n    constexpr auto data() const noexcept -> const_pointer {\n        return data_;\n    }\n\n    /// Returns the number of Char elements in the view.\n    constexpr auto size() const noexcept -> size_type {\n        return size_;\n    }\n\n    /// Returns a const reference to the character at specified location `id`.\n    constexpr auto operator[](std::size_t id) const -> char {\n        return id < size() ?\n            data_[id] :\n            throw std::out_of_range(\"out of range\");\n    }\n\n    /// Operations.\n\n    /// Creates a `basic_string` with a copy of the content of the current view.\n    template<class Allocator = std::allocator<Char>>\n    auto to_string(const Allocator& alloc = Allocator()) const ->\n        std::basic_string<Char, Traits, Allocator>\n    {\n        return {data(), size(), alloc};\n    }\n\n    /// Returns a view of the substring [pos, pos + rcount), where rcount is the smaller of count\n    /// and `size() - pos`.\n    constexpr\n    auto substr(std::size_t pos = 0, std::size_t count = npos) const -> basic_string_view {\n        return pos <= size() ?\n            basic_string_view(data() + pos, std::min(count, size() - pos)) :\n            throw std::out_of_range(\"out of range\");\n    }\n\n    /// Compares two views.\n    ///\n    /// All comparisons are done via the `compare()` member function, which itself is defined in\n    /// terms of `Traits::compare()`.\n    /// Two views are equal if both the size of `this` and `other` are equal and each character in\n    /// `this` has an equivalent character in `other` at the same position.\n    constexpr auto operator==(const basic_string_view& other) const noexcept -> bool {\n        return size() == other.size() && traits_type::compare(data(), other.data(), size()) == 0;\n    }\n};\n\ntemplate<typename Char, typename Traits >\nconstexpr auto operator<(basic_string_view<Char, Traits> lhs, basic_string_view<Char, Traits> rhs) ->\n    bool\n{\n    return std::lexicographical_compare(lhs.data(), lhs.data() + lhs.size(),\n        rhs.data(), rhs.data() + rhs.size());\n}\n\ntemplate<class Char, class Traits>\nauto operator<<(std::basic_ostream<Char, Traits>& stream, const basic_string_view<Char, Traits>& value) ->\n    std::basic_ostream<Char, Traits>&\n{\n    return stream << value.to_string();\n}\n\n/// Several typedefs for common character types are provided:\ntypedef basic_string_view<char> string_view;\n\n}  // namespace cpp17\n\nusing cpp17::string_view;\n\n}  // namespace v1\n}  // namespace blackhole\n"
      }
    ],
    "unresolved_context": [],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -2,7 +2,10 @@\n \n #include <boost/asio/ip/udp.hpp>\n #include <boost/lexical_cast.hpp>\n+#include <boost/optional/optional.hpp>\n \n+#include \"blackhole/config/node.hpp\"\n+#include \"blackhole/config/option.hpp\"\n #include \"blackhole/cpp17/string_view.hpp\"\n \n namespace blackhole {\n@@ -66,5 +69,12 @@\n     return \"udp\";\n }\n \n+auto factory<sink::socket::udp_t>::from(const config::node_t& config) -> sink::socket::udp_t {\n+    const auto host = config[\"host\"].to_string().get();\n+    const auto port = config[\"port\"].to_uint64().get();\n+\n+    return {host, static_cast<std::uint16_t>(port)};\n+}\n+\n }  // namespace v1\n }  // namespace blackhole"
  }
}