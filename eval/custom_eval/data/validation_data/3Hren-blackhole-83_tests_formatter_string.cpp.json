{
  "repo": {
    "name": "3Hren/blackhole",
    "buggy_commit": "57814ff45d7bcdf306f8f085d0f6ad34561419c5",
    "fixed_commit": "a57bedad01ead02147a9f94a3b3c4050fa2e81a9"
  },
  "input": {
    "language": "C++",
    "issue": {
      "issue_title": "Hide string formatter binary interface",
      "issue_description": "To achieve the possibility of changing string formatter implementation or bug fixes without breaking the ABI it's important to hide that ABI. All other formatters/sinks have already been written in that way.\n\nNote, that this change will break `blackhole::formatter::string_t` API/ABI as it were described in https://github.com/3Hren/blackhole/milestones, but for now it's okay, because nobody uses it explicitly except the Blackhole internals.\n"
    },
    "buggy_commit_message": "refactor(builder): move to experimental\n\nTo be able to correctly handle backward compatibility I need to\ndistinguish between stable and unstable components. When an user\nincludes an experimental component he/she is explicitly notified\nsemantically to be prepared for API/ABI breaking.",
    "buggy_file": {
      "buggy_filename": "tests/formatter/string.cpp",
      "buggy_code": "#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <boost/algorithm/string/predicate.hpp>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/string.hpp>\n#include <blackhole/record.hpp>\n\nnamespace {\n\nstruct version_t {\n    int major;\n    int minor;\n};\n\n}  // namespace\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<>\nstruct display_traits<version_t> {\n    static auto apply(const version_t& version, writer_t& wr) -> void {\n        wr.write(\"{}.{}\", version.major, version.minor);\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\nnamespace testing {\n\nusing ::testing::AnyOf;\nusing ::testing::Eq;\n\nTEST(string_t, Message) {\n    formatter::string_t formatter(\"[{message}]\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[value]\", writer.result().to_string());\n}\n\nTEST(string_t, Severity) {\n    // NOTE: No severity mapping provided, formatter falls back to the numeric case.\n    formatter::string_t formatter(\"[{severity}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNum) {\n    formatter::string_t formatter(\"[{severity:d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUser) {\n    formatter::string_t formatter(\"[{severity}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUserExplicit) {\n    formatter::string_t formatter(\"[{severity:s}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNumWithMappingProvided) {\n    formatter::string_t formatter(\"[{severity:d}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNumWithSpec) {\n    formatter::string_t formatter(\"[{severity:*^3d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[*0*]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUserWithSpec) {\n    formatter::string_t formatter(\"[{severity:<7}]\", [](int severity, const std::string& spec, writer_t& writer) {\n        writer.write(spec, \"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG  ]\", writer.result().to_string());\n}\n\nTEST(string_t, CombinedSeverityNumWithMessage) {\n    formatter::string_t formatter(\"[{severity:d}]: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]: value\", writer.result().to_string());\n}\n\nTEST(string_t, Generic) {\n    formatter::string_t formatter(\"{protocol}/{version:.1f}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", {1.1}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1\", writer.result().to_string());\n}\n\nTEST(string_t, GenericNull) {\n    formatter::string_t formatter(\"{protocol}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"none\", writer.result().to_string());\n}\n\nTEST(string_t, GenericNullWithSpec) {\n    formatter::string_t formatter(\"{protocol:>5}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\" none\", writer.result().to_string());\n}\n\nTEST(string_t, ThrowsIfGenericAttributeNotFound) {\n    formatter::string_t formatter(\"{protocol}/{version:.1f}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    EXPECT_THROW(formatter.format(record, writer), std::logic_error);\n}\n\nTEST(string_t, GenericOptional) {\n    formatter::string_t formatter(\"{protocol}{version:.1f}\", {\n        {\"version\", formatter::option::optional_t{\"/\", \" - REQUIRED\"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", {1.1}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1 - REQUIRED\", writer.result().to_string());\n}\n\nTEST(string_t, GenericLazyUnspec) {\n    formatter::string_t formatter(\"{protocol}/{version}\");\n\n    version_t version{1, 1};\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", version}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1\", writer.result().to_string());\n}\n\nTEST(string_t, GenericLazySpec) {\n    formatter::string_t formatter(\"{protocol}/{version:>4s} - alpha\");\n\n    version_t version{1, 1};\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", version}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1 - alpha\", writer.result().to_string());\n}\n\nTEST(string_t, ThrowsIfOptionsContainsReservedPlaceholderNames) {\n    using formatter::option::optional_t;\n\n    EXPECT_THROW((formatter::string_t(\"{protocol}\", {{\"message\", optional_t{\"[\", \"]\"}}})),\n        std::logic_error);\n}\n\nTEST(string_t, Process) {\n    formatter::string_t formatter(\"{process}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(std::to_string(::getpid()), writer.result().to_string());\n}\n\nTEST(string_t, ProcessIdExplicitly) {\n    formatter::string_t formatter(\"{process:d}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(std::to_string(::getpid()), writer.result().to_string());\n}\n\nTEST(string_t, ProcessName) {\n    formatter::string_t formatter(\"{process:s}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_TRUE(writer.result().to_string().size() > 0);\n}\n\nTEST(string_t, Thread) {\n    formatter::string_t formatter(\"{thread}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_EQ(stream.str(), writer.result().to_string());\n}\n\nTEST(string_t, ThreadExplicitly) {\n    formatter::string_t formatter(\"{thread:#x}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_EQ(stream.str(), writer.result().to_string());\n}\n\nTEST(string_t, ThreadExplicitlySpec) {\n    formatter::string_t formatter(\"{thread:>#16x}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux__\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_TRUE(boost::ends_with(writer.result().to_string(), stream.str()));\n}\n\nstruct threadname_guard {\n    template<std::size_t N>\n    threadname_guard(const char(&name)[N]) {\n        #ifdef __linux__\n            ::pthread_setname_np(::pthread_self(), name);\n        #elif __APPLE__\n            ::pthread_setname_np(name);\n        #else\n        #error \"Not implemented. Please write an implementation for your OS.\"\n        #endif\n    }\n\n    ~threadname_guard() {\n        #ifdef __linux__\n            ::pthread_setname_np(::pthread_self(), \"\");\n        #elif __APPLE__\n            ::pthread_setname_np(\"\");\n        #else\n        #error \"Not implemented. Please write an implementation for your OS.\"\n        #endif\n    }\n};\n\nTEST(string_t, ThreadName) {\n    formatter::string_t formatter(\"{thread:s}\");\n\n    threadname_guard guard(\"thread#0\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"thread#0\", writer.result().to_string());\n}\n\nTEST(string_t, ThreadNameWithSpec) {\n    formatter::string_t formatter(\"{thread:>10s}\");\n\n    threadname_guard guard(\"thread#0\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"  thread#0\", writer.result().to_string());\n}\n\nTEST(string_t, Timestamp) {\n    // NOTE: By default %Y-%m-%d %H:%M:%S.%f pattern is used.\n    formatter::string_t formatter(\"[{timestamp}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \".\" << fmt::pad(std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count() % 1000000, 6, '0') << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampExplicit) {\n    formatter::string_t formatter(\"[{timestamp:{%Y}}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampExplicitWithType) {\n    formatter::string_t formatter(\"[{timestamp:{%H:%M:%S}s}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampSpec) {\n    formatter::string_t formatter(\"[{timestamp:>30s}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[    \" << fmt::StringRef(buffer, len) << \".\" << fmt::pad(std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count() % 1000000, 6, '0') << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampNum) {\n    formatter::string_t formatter(\"[{timestamp:d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto usec = std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count();\n    fmt::MemoryWriter wr;\n    wr << \"[\" << usec << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, Leftover) {\n    formatter::string_t formatter(\"{...}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1: 42, key#2: value#2\"),\n        Eq(\"key#2: value#2, key#1: 42\")\n    ));\n}\n\nTEST(string_t, LeftoverEmpty) {\n    formatter::string_t formatter(\"[{...}]\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[]\", writer.result().to_string());\n}\n\nTEST(string_t, LeftoverWithPrefixAndSuffix) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}: {v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"[key#1: 42, key#2: value#2]\"),\n        Eq(\"[key#2: value#2, key#1: 42]\")\n    ));\n}\n\nTEST(string_t, LeftoverEmptyWithPrefixAndSuffix) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}: {v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"\", writer.result().to_string());\n}\n\nTEST(DISABLED_string_t, LeftoverWithPattern) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"\", \"\", \"{k}={v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1=42, key#2=value#2\"),\n        Eq(\"key#2=value#2, key#1=42\")\n    ));\n}\n\nTEST(string_t, LeftoverWithSeparator) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"\", \"\", \"{k}={v}\", \" | \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1: 42 | key#2: value#2\"),\n        Eq(\"key#2: value#2 | key#1: 42\")\n    ));\n}\n\nTEST(string_t, Type) {\n    EXPECT_EQ(\"string\", std::string(factory<formatter::string_t>::type()));\n}\n\n}  // namespace testing\n}  // namespace blackhole\n"
    },
    "context": [],
    "unresolved_context": []
  },
  "output": {
    "language": "C++",
    "fixed_commit_message": "refactor(formatter/string): new interface\n\nThis commit changes the interface (and ABI) of the string formatter to\nmake it possible to change the implementation or add functionality\nwithout further breaking.\n\nStrictly speaking this commit just applies pointer to implementation\nidiom.\n\nCloses #83, but it\u2019s not complete yet, just proof of concept.",
    "fixed_file": {
      "fixed_filename": "tests/formatter/string.cpp",
      "fixed_code": "#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <boost/algorithm/string/predicate.hpp>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/string.hpp>\n#include <blackhole/record.hpp>\n\nnamespace {\n\nstruct version_t {\n    int major;\n    int minor;\n};\n\n}  // namespace\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<>\nstruct display_traits<version_t> {\n    static auto apply(const version_t& version, writer_t& wr) -> void {\n        wr.write(\"{}.{}\", version.major, version.minor);\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\nnamespace testing {\n\nusing ::testing::AnyOf;\nusing ::testing::Eq;\n\nTEST(string_t, Message) {\n    formatter::string_t formatter(\"[{message}]\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[value]\", writer.result().to_string());\n}\n\nTEST(string_t, Severity) {\n    // NOTE: No severity mapping provided, formatter falls back to the numeric case.\n    formatter::string_t formatter(\"[{severity}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNum) {\n    formatter::string_t formatter(\"[{severity:d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUser) {\n    formatter::string_t formatter(\"[{severity}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUserExplicit) {\n    formatter::string_t formatter(\"[{severity:s}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNumWithMappingProvided) {\n    formatter::string_t formatter(\"[{severity:d}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNumWithSpec) {\n    formatter::string_t formatter(\"[{severity:*^3d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[*0*]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUserWithSpec) {\n    formatter::string_t formatter(\"[{severity:<7}]\", [](int severity, const std::string& spec, writer_t& writer) {\n        writer.write(spec, \"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG  ]\", writer.result().to_string());\n}\n\nTEST(string_t, CombinedSeverityNumWithMessage) {\n    formatter::string_t formatter(\"[{severity:d}]: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]: value\", writer.result().to_string());\n}\n\nTEST(string_t, Generic) {\n    formatter::string_t formatter(\"{protocol}/{version:.1f}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", {1.1}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1\", writer.result().to_string());\n}\n\nTEST(string_t, GenericNull) {\n    formatter::string_t formatter(\"{protocol}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"none\", writer.result().to_string());\n}\n\nTEST(string_t, GenericNullWithSpec) {\n    formatter::string_t formatter(\"{protocol:>5}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\" none\", writer.result().to_string());\n}\n\nTEST(string_t, ThrowsIfGenericAttributeNotFound) {\n    formatter::string_t formatter(\"{protocol}/{version:.1f}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    EXPECT_THROW(formatter.format(record, writer), std::logic_error);\n}\n\nTEST(string_t, GenericOptional) {\n    formatter::string_t formatter(\"{protocol}{version:.1f}\");\n    formatter.optional(\"version\", \"/\", \" - REQUIRED\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", {1.1}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1 - REQUIRED\", writer.result().to_string());\n}\n\nTEST(string_t, GenericLazyUnspec) {\n    formatter::string_t formatter(\"{protocol}/{version}\");\n\n    version_t version{1, 1};\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", version}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1\", writer.result().to_string());\n}\n\nTEST(string_t, GenericLazySpec) {\n    formatter::string_t formatter(\"{protocol}/{version:>4s} - alpha\");\n\n    version_t version{1, 1};\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", version}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1 - alpha\", writer.result().to_string());\n}\n\nTEST(string_t, ThrowsIfOptionsContainsReservedPlaceholderNames) {\n    formatter::string_t formatter(\"{protocol}\");\n\n    EXPECT_THROW(formatter.optional(\"message\", \"[\", \"]\"), std::logic_error);\n}\n\nTEST(string_t, Process) {\n    formatter::string_t formatter(\"{process}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(std::to_string(::getpid()), writer.result().to_string());\n}\n\nTEST(string_t, ProcessIdExplicitly) {\n    formatter::string_t formatter(\"{process:d}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(std::to_string(::getpid()), writer.result().to_string());\n}\n\nTEST(string_t, ProcessName) {\n    formatter::string_t formatter(\"{process:s}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_TRUE(writer.result().to_string().size() > 0);\n}\n\nTEST(string_t, Thread) {\n    formatter::string_t formatter(\"{thread}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_EQ(stream.str(), writer.result().to_string());\n}\n\nTEST(string_t, ThreadExplicitly) {\n    formatter::string_t formatter(\"{thread:#x}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_EQ(stream.str(), writer.result().to_string());\n}\n\nTEST(string_t, ThreadExplicitlySpec) {\n    formatter::string_t formatter(\"{thread:>#16x}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux__\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_TRUE(boost::ends_with(writer.result().to_string(), stream.str()));\n}\n\nstruct threadname_guard {\n    template<std::size_t N>\n    threadname_guard(const char(&name)[N]) {\n        #ifdef __linux__\n            ::pthread_setname_np(::pthread_self(), name);\n        #elif __APPLE__\n            ::pthread_setname_np(name);\n        #else\n        #error \"Not implemented. Please write an implementation for your OS.\"\n        #endif\n    }\n\n    ~threadname_guard() {\n        #ifdef __linux__\n            ::pthread_setname_np(::pthread_self(), \"\");\n        #elif __APPLE__\n            ::pthread_setname_np(\"\");\n        #else\n        #error \"Not implemented. Please write an implementation for your OS.\"\n        #endif\n    }\n};\n\nTEST(string_t, ThreadName) {\n    formatter::string_t formatter(\"{thread:s}\");\n\n    threadname_guard guard(\"thread#0\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"thread#0\", writer.result().to_string());\n}\n\nTEST(string_t, ThreadNameWithSpec) {\n    formatter::string_t formatter(\"{thread:>10s}\");\n\n    threadname_guard guard(\"thread#0\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"  thread#0\", writer.result().to_string());\n}\n\nTEST(string_t, Timestamp) {\n    // NOTE: By default %Y-%m-%d %H:%M:%S.%f pattern is used.\n    formatter::string_t formatter(\"[{timestamp}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \".\" << fmt::pad(std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count() % 1000000, 6, '0') << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampExplicit) {\n    formatter::string_t formatter(\"[{timestamp:{%Y}}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampExplicitWithType) {\n    formatter::string_t formatter(\"[{timestamp:{%H:%M:%S}s}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampSpec) {\n    formatter::string_t formatter(\"[{timestamp:>30s}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[    \" << fmt::StringRef(buffer, len) << \".\" << fmt::pad(std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count() % 1000000, 6, '0') << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampNum) {\n    formatter::string_t formatter(\"[{timestamp:d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto usec = std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count();\n    fmt::MemoryWriter wr;\n    wr << \"[\" << usec << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, Leftover) {\n    formatter::string_t formatter(\"{...}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1: 42, key#2: value#2\"),\n        Eq(\"key#2: value#2, key#1: 42\")\n    ));\n}\n\nTEST(string_t, LeftoverEmpty) {\n    formatter::string_t formatter(\"[{...}]\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[]\", writer.result().to_string());\n}\n\nTEST(string_t, LeftoverWithPrefixAndSuffix) {\n    formatter::string_t formatter(\"{...}\");\n    formatter.leftover(\"...\", \"[\", \"]\", \"{k}: {v}\", \", \", false);\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"[key#1: 42, key#2: value#2]\"),\n        Eq(\"[key#2: value#2, key#1: 42]\")\n    ));\n}\n\nTEST(string_t, LeftoverEmptyWithPrefixAndSuffix) {\n    formatter::string_t formatter(\"{...}\");\n    formatter.leftover(\"...\", \"[\", \"]\", \"{k}: {v}\", \", \", false);\n\n    const string_view message(\"-\");\n    const attribute_list attributes{};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"\", writer.result().to_string());\n}\n\nTEST(DISABLED_string_t, LeftoverWithPattern) {\n    formatter::string_t formatter(\"{...}\");\n    formatter.leftover(\"...\", \"\", \"\", \"{k}={v}\", \", \", false);\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1=42, key#2=value#2\"),\n        Eq(\"key#2=value#2, key#1=42\")\n    ));\n}\n\nTEST(string_t, LeftoverWithSeparator) {\n    formatter::string_t formatter(\"{...}\");\n    formatter.leftover(\"...\", \"\", \"\", \"{k}={v}\", \" | \", false);\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1: 42 | key#2: value#2\"),\n        Eq(\"key#2: value#2 | key#1: 42\")\n    ));\n}\n\nTEST(string_t, Type) {\n    EXPECT_EQ(\"string\", std::string(factory<formatter::string_t>::type()));\n}\n\n}  // namespace testing\n}  // namespace blackhole\n"
    },
    "context": [],
    "unresolved_context": [],
    "changes_summary": "Code changed as follows:\n--- buggy\n+++ fixed\n@@ -207,9 +207,8 @@\n }\n \n TEST(string_t, GenericOptional) {\n-    formatter::string_t formatter(\"{protocol}{version:.1f}\", {\n-        {\"version\", formatter::option::optional_t{\"/\", \" - REQUIRED\"}}\n-    });\n+    formatter::string_t formatter(\"{protocol}{version:.1f}\");\n+    formatter.optional(\"version\", \"/\", \" - REQUIRED\");\n \n     const string_view message(\"-\");\n     const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", {1.1}}};\n@@ -252,10 +251,9 @@\n }\n \n TEST(string_t, ThrowsIfOptionsContainsReservedPlaceholderNames) {\n-    using formatter::option::optional_t;\n-\n-    EXPECT_THROW((formatter::string_t(\"{protocol}\", {{\"message\", optional_t{\"[\", \"]\"}}})),\n-        std::logic_error);\n+    formatter::string_t formatter(\"{protocol}\");\n+\n+    EXPECT_THROW(formatter.optional(\"message\", \"[\", \"]\"), std::logic_error);\n }\n \n TEST(string_t, Process) {\n@@ -547,9 +545,8 @@\n }\n \n TEST(string_t, LeftoverWithPrefixAndSuffix) {\n-    formatter::string_t formatter(\"{...}\", {\n-        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}: {v}\", \", \"}}\n-    });\n+    formatter::string_t formatter(\"{...}\");\n+    formatter.leftover(\"...\", \"[\", \"]\", \"{k}: {v}\", \", \", false);\n \n     const string_view message(\"-\");\n     const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n@@ -565,9 +562,8 @@\n }\n \n TEST(string_t, LeftoverEmptyWithPrefixAndSuffix) {\n-    formatter::string_t formatter(\"{...}\", {\n-        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}: {v}\", \", \"}}\n-    });\n+    formatter::string_t formatter(\"{...}\");\n+    formatter.leftover(\"...\", \"[\", \"]\", \"{k}: {v}\", \", \", false);\n \n     const string_view message(\"-\");\n     const attribute_list attributes{};\n@@ -580,9 +576,8 @@\n }\n \n TEST(DISABLED_string_t, LeftoverWithPattern) {\n-    formatter::string_t formatter(\"{...}\", {\n-        {\"...\", formatter::option::leftover_t{false, \"\", \"\", \"{k}={v}\", \", \"}}\n-    });\n+    formatter::string_t formatter(\"{...}\");\n+    formatter.leftover(\"...\", \"\", \"\", \"{k}={v}\", \", \", false);\n \n     const string_view message(\"-\");\n     const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n@@ -598,9 +593,8 @@\n }\n \n TEST(string_t, LeftoverWithSeparator) {\n-    formatter::string_t formatter(\"{...}\", {\n-        {\"...\", formatter::option::leftover_t{false, \"\", \"\", \"{k}={v}\", \" | \"}}\n-    });\n+    formatter::string_t formatter(\"{...}\");\n+    formatter.leftover(\"...\", \"\", \"\", \"{k}={v}\", \" | \", false);\n \n     const string_view message(\"-\");\n     const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};"
  }
}