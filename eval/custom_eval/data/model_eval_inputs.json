[
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\nTo achieve the possibility of changing string formatter implementation or bug fixes without breaking the ABI it's important to hide that ABI. All other formatters/sinks have already been written in that way.\n\nNote, that this change will break `blackhole::formatter::string_t` API/ABI as it were described in https://github.com/3Hren/blackhole/milestones, but for now it's okay, because nobody uses it explicitly except the Blackhole internals.\n\nIn this file:\nstring.cpp\n#include \"blackhole/formatter/string.hpp\"\n\n#include <array>\n\n#include <boost/variant/apply_visitor.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/variant/variant.hpp>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/extensions/format.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n#include \"blackhole/record.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n#include \"blackhole/detail/formatter/string/parser.hpp\"\n#include \"blackhole/detail/formatter/string/token.hpp\"\n#include \"blackhole/detail/procname.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\n\nnamespace string = blackhole::detail::formatter::string;\nnamespace ph = string::ph;\n\nusing string::id;\nusing string::hex;\nusing string::num;\nusing string::name;\nusing string::user;\nusing string::required;\nusing string::optional;\n\nusing string::literal_t;\n\nnamespace {\n\ntypedef fmt::StringRef string_ref;\n\n}  // namespace\n\nclass token_t {\n    string::token_t inner;\n\npublic:\n    token_t(string::token_t inner) :\n        inner(std::move(inner))\n    {}\n\n    auto operator*() const noexcept -> const string::token_t& {\n        return inner;\n    }\n};\n\nnamespace {\n\nclass transform_visitor_t : public boost::static_visitor<string::token_t> {\n    const options_t& options;\n\npublic:\n    transform_visitor_t(const options_t& options) :\n        options(options)\n    {}\n\n    auto operator()(const ph::generic<required>& token) const -> string::token_t {\n        const auto it = options.find(token.name);\n\n        if (it != options.end()) {\n            const auto option = boost::get<option::optional_t>(it->second);\n\n            return ph::generic<optional>(token, option.prefix, option.suffix);\n        }\n\n        return token;\n    }\n\n    auto operator()(const ph::leftover_t& token) const -> string::token_t {\n        const auto it = options.find(token.name);\n\n        if (it != options.end()) {\n            const auto option = boost::get<option::leftover_t>(it->second);\n\n            return ph::leftover_t(token.name, option.unique, option.prefix, option.suffix,\n                option.pattern, option.separator);\n        }\n\n        return token;\n    }\n\n    template<typename T>\n    auto operator()(const T& token) const -> string::token_t {\n        return token;\n    }\n};\n\nstruct spec;\nstruct unspec;\n\ntemplate<typename Spec>\nclass view_visitor;\n\ntemplate<>\nclass view_visitor<spec> : public boost::static_visitor<> {\n    writer_t& writer;\n    const std::string& spec;\n\npublic:\n    view_visitor(writer_t& writer, const std::string& spec) noexcept :\n        writer(writer),\n        spec(spec)\n    {}\n\n    auto operator()(std::nullptr_t) const -> void {\n        writer.write(spec, \"none\");\n    }\n\n    template<typename T>\n    auto operator()(T value) const -> void {\n        writer.write(spec, value);\n    }\n\n    auto operator()(const string_view& value) const -> void {\n        writer.write(spec, value.data());\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) const -> void {\n        value(writer);\n    }\n};\n\ntemplate<>\nclass view_visitor<unspec> : public boost::static_visitor<> {\n    writer_t& writer;\n\npublic:\n    view_visitor(writer_t& writer) noexcept :\n        writer(writer)\n    {}\n\n    auto operator()(std::nullptr_t) const -> void {\n        writer.inner << \"none\";\n    }\n\n    template<typename T>\n    auto operator()(T value) const -> void {\n        writer.inner << value;\n    }\n\n    auto operator()(const string_view& value) const -> void {\n        writer.inner << string_ref(value.data(), value.size());\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) const -> void {\n        value(writer);\n    }\n};\n\nclass visitor_t : public boost::static_visitor<> {\n    writer_t& writer;\n    const record_t& record;\n    const severity_map& sevmap;\n\npublic:\n    visitor_t(writer_t& writer, const record_t& record, const severity_map& sevmap) noexcept :\n        writer(writer),\n        record(record),\n        sevmap(sevmap)\n    {}\n\n    auto operator()(const literal_t& token) const -> void {\n        writer.inner << token.value;\n    }\n\n    auto operator()(const ph::message_t& token) const -> void {\n        const auto& value = record.formatted();\n        writer.write(token.spec, string_ref(value.data(), value.size()));\n    }\n\n    auto operator()(const ph::process<id>& token) const -> void {\n        writer.write(token.spec, record.pid());\n    }\n\n    auto operator()(const ph::process<name>& token) const -> void {\n        writer.write(token.spec, detail::procname().data());\n    }\n\n    auto operator()(const ph::thread<id>& token) const -> void {\n        throw std::runtime_error(\"{thread:d} placeholder is not implemented yet\");\n    }\n\n    auto operator()(const ph::thread<hex>& token) const -> void {\n#ifdef __linux__\n        writer.write(token.spec, record.tid());\n#elif __APPLE__\n        writer.write(token.spec, reinterpret_cast<unsigned long>(record.tid()));\n#endif\n    }\n\n    auto operator()(const ph::thread<name>& token) const -> void {\n        std::array<char, 16> buffer;\n        const auto rc = ::pthread_getname_np(record.tid(), buffer.data(), buffer.size());\n\n        if (rc == 0) {\n            writer.write(token.spec, buffer.data());\n        } else {\n            writer.write(token.spec, \"<unnamed>\");\n        }\n    }\n\n    auto operator()(const ph::severity<num>& token) const -> void {\n        writer.write(token.spec, record.severity());\n    }\n\n    auto operator()(const ph::severity<user>& token) const -> void {\n        sevmap(record.severity(), token.spec, writer);\n    }\n\n    auto operator()(const ph::timestamp<num>& token) const -> void {\n        const auto timestamp = record.timestamp();\n        const auto usec = std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(timestamp.time_since_epoch()).count();\n\n        writer.write(token.spec, usec);\n    }\n\n    auto operator()(const ph::timestamp<user>& token) const -> void {\n        const auto timestamp = record.timestamp();\n        const auto time = record_t::clock_type::to_time_t(timestamp);\n        const auto usec = std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(timestamp.time_since_epoch()).count() % 1000000;\n\n        std::tm tm;\n        ::gmtime_r(&time, &tm);\n\n        fmt::MemoryWriter buffer;\n        token.generator(buffer, tm, static_cast<std::uint64_t>(usec));\n        writer.write(token.spec, string_ref(buffer.data(), buffer.size()));\n    }\n\n    auto operator()(const ph::generic<required>& token) const -> void {\n        if (auto value = find(token.name)) {\n            return boost::apply_visitor(view_visitor<spec>(writer, token.spec), value->inner().value);\n        }\n\n        throw std::logic_error(\"required attribute '\" + token.name + \"' not found\");\n    }\n\n    auto operator()(const ph::generic<optional>& token) const -> void {\n        if (auto value = find(token.name)) {\n            writer.write(token.prefix);\n            boost::apply_visitor(view_visitor<spec>(writer, token.spec), value->inner().value);\n            writer.write(token.suffix);\n        }\n    }\n\n    auto operator()(const ph::leftover_t& token) const -> void {\n        bool first = true;\n        writer_t kv;\n        const view_visitor<unspec> visitor(kv);\n\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                if (first) {\n                    first = false;\n                    writer.inner << token.prefix;\n                } else {\n                    writer.inner << token.separator;\n                }\n\n                // TODO: To correctly implement kv patterns we need a visitor with parameters. Or\n                // attribute (pair) type, instead of that `std::pair`.\n                kv.inner << string_ref(attribute.first.data(), attribute.first.size()) << \": \";\n                boost::apply_visitor(visitor, attribute.second.inner().value);\n\n                const auto view = kv.result();\n                writer.inner << string_ref(view.data(), view.size());\n\n                kv.inner.clear();\n            }\n        }\n\n        if (!first) {\n            writer.inner << token.suffix;\n        }\n    }\n\nprivate:\n    auto find(const std::string& name) const -> boost::optional<attribute::view_t> {\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                if (attribute.first == name) {\n                    return attribute.second;\n                }\n            }\n        }\n\n        return boost::none;\n    }\n};\n\nstatic auto tokenize(const std::string& pattern, const options_t& options) -> std::vector<token_t> {\n    std::vector<token_t> tokens;\n\n    for (const auto& reserved : {\"process\", \"thread\", \"message\", \"severity\", \"timestamp\"}) {\n        if (options.count(reserved) != 0) {\n            throw std::logic_error(\"placeholder '\" + std::string(reserved) +\n                \"' is reserved and can not be configured\");\n        }\n    }\n\n    string::parser_t parser(pattern);\n    while (auto token = parser.next()) {\n        tokens.emplace_back(boost::apply_visitor(transform_visitor_t(options), token.get()));\n    }\n\n    return tokens;\n}\n\n}  // namespace\n\nstring_t::string_t(std::string pattern, const options_t& options) :\n    pattern(std::move(pattern)),\n    sevmap([](int severity, const std::string& spec, writer_t& writer) {\n        writer.write(spec, severity);\n    }),\n    tokens(tokenize(this->pattern, options))\n{}\n\nstring_t::string_t(std::string pattern, severity_map sevmap, const options_t& options) :\n    pattern(std::move(pattern)),\n    sevmap(std::move(sevmap)),\n    tokens(tokenize(this->pattern, options))\n{}\n\nstring_t::string_t(string_t&& other) = default;\n\nstring_t::~string_t() {}\n\nauto\nstring_t::format(const record_t& record, writer_t& writer) -> void {\n    const visitor_t visitor(writer, record, sevmap);\n\n    for (const auto& token : tokens) {\n        boost::apply_visitor(visitor, *token);\n    }\n}\n\n}  // namespace formatter\n\nauto\nfactory<formatter::string_t>::type() -> const char* {\n    return \"string\";\n}\n\nauto\nfactory<formatter::string_t>::from(const config::node_t& config) -> formatter::string_t {\n    auto pattern = config[\"pattern\"].to_string().get();\n\n    if (auto mapping = config[\"sevmap\"]) {\n        std::vector<std::string> sevmap;\n        mapping.each([&](const config::node_t& config) {\n            sevmap.emplace_back(config.to_string());\n        });\n\n        auto fn = [=](std::size_t severity, const std::string& spec, writer_t& writer) {\n            if (severity < sevmap.size()) {\n                writer.write(spec, sevmap[severity]);\n            } else {\n                writer.write(spec, severity);\n            }\n        };\n\n        return formatter::string_t(std::move(pattern), std::move(fn));\n    }\n\n    return formatter::string_t(std::move(pattern));\n}\n\n}  // namespace v1\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\nIn this file:\njson.cpp\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <rapidjson/document.h>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/json.hpp>\n#include <blackhole/record.hpp>\n\nnamespace {\n\nstruct endpoint_t {\n    std::string host;\n    std::uint16_t port;\n};\n\n}  // namespace\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<>\nstruct display_traits<endpoint_t> {\n    static auto apply(const endpoint_t& endpoint, writer_t& wr) -> void {\n        wr.write(\"{}:{}\", endpoint.host, endpoint.port);\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\nnamespace testing {\nnamespace formatter {\n\nusing ::blackhole::formatter::json_t;\n\nTEST(json_t, FormatMessage) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n}\n\nTEST(json_t, FormatFormattedMessage) {\n    json_t formatter;\n\n    const string_view message(\"value {}\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate(\"value 42\");\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value 42\", doc[\"message\"].GetString());\n}\n\nTEST(json_t, FormatSeverity) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(4, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n\n    ASSERT_TRUE(doc.HasMember(\"severity\"));\n    ASSERT_TRUE(doc[\"severity\"].IsInt());\n    EXPECT_EQ(4, doc[\"severity\"].GetInt());\n}\n\nTEST(json_t, FormatTimestamp) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(4, message, pack);\n    record.activate();\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n\n    ASSERT_TRUE(doc.HasMember(\"timestamp\"));\n    ASSERT_TRUE(doc[\"timestamp\"].IsUint64());\n    EXPECT_TRUE(doc[\"timestamp\"].GetUint64() > 0);\n}\n\nTEST(json_t, FormatAttribute) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"counter\", 42}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n}\n\nTEST(json_t, FormatAttributeNull) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", nullptr}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsNull());\n}\n\nTEST(json_t, FormatAttributeBool) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"available\", true}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"available\"));\n    ASSERT_TRUE(doc[\"available\"].IsBool());\n    EXPECT_TRUE(doc[\"available\"].GetBool());\n}\n\nTEST(json_t, FormatAttributeDouble) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"pi\", 3.1415}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"pi\"));\n    ASSERT_TRUE(doc[\"pi\"].IsDouble());\n    EXPECT_DOUBLE_EQ(3.1415, doc[\"pi\"].GetDouble());\n}\n\nTEST(json_t, FormatAttributeString) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeUser) {\n    endpoint_t endpoint{\"127.0.0.1\", 8080};\n\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", endpoint}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatDuplicateAttributesDefault) {\n    auto formatter = json_t::builder_t()\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list a1{{\"counter\", 42}};\n    const attribute_list a2{{\"counter\", 100}};\n    const attribute_pack pack{a1, a2};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":42\") != std::string::npos);\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":100\") != std::string::npos);\n}\n\nTEST(json_t, FormatDuplicateAttributesUnique) {\n    auto formatter = json_t::builder_t()\n        .unique()\n        .build();\n\n    const string_view message(\"value\");\n    // Earlier attribute list has more precedence than the later ones.\n    const attribute_list a1{{\"counter\", 42}};\n    const attribute_list a2{{\"counter\", 100}};\n    const attribute_pack pack{a1, a2};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":42\") != std::string::npos);\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":100\") == std::string::npos);\n}\n\nTEST(json_t, FormatMessageWithRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields\", {\"message\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"fields\"][\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"fields\"][\"message\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"fields\"][\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"fields\"][\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithNestedRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields/external\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"external\"));\n    ASSERT_TRUE(doc[\"fields\"][\"external\"].IsObject());\n    ASSERT_TRUE(doc[\"fields\"][\"external\"].HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"fields\"][\"external\"][\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"fields\"][\"external\"][\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithRootRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatMessageWithRenaming) {\n    auto formatter = json_t::builder_t()\n        .rename(\"message\", \"#message\")\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"#message\"));\n    ASSERT_TRUE(doc[\"#message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"#message\"].GetString());\n}\n\nTEST(json_t, FormatAttributeWithRenaming) {\n    auto formatter = json_t::builder_t()\n        .rename(\"source\", \"#source\")\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"source\", \"storage\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"#source\"));\n    ASSERT_TRUE(doc[\"#source\"].IsString());\n    EXPECT_STREQ(\"storage\", doc[\"#source\"].GetString());\n}\n\nTEST(json_t, FactoryType) {\n    EXPECT_EQ(\"json\", std::string(factory<formatter::json_t>::type()));\n}\n\n}  // namespace formatter\n}  // namespace testing\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nDAMFunctions.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.dam;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport org.osgi.annotation.versioning.ProviderType;\n\nimport com.day.cq.dam.api.Asset;\nimport com.day.cq.dam.api.DamConstants;\n\n/**\n * DAM JSP functions.\n */\n@ProviderType\npublic final class DAMFunctions {\n\n    private DAMFunctions() {\n    }\n\n    /**\n     * Return the title or name of the asset, if the title is not defined.\n     * \n     * @param asset the asset\n     * @return the asset title or name\n     */\n    public static String getTitleOrName(Asset asset) {\n        String title = asset.getMetadataValue(DamConstants.DC_TITLE);\n        return StringUtils.isNotBlank(title) ? title : asset.getName();\n    }\n\n}\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\nFor example:\n\n``` json\n{\n  \"message\":\"stopping {:d} execution unit(s)\",\n  \"severity\":1,\n  \"timestamp\":1454064629638488,\n  \"source\":\"core\"\n}\n```\n\nWhere \"message\" field should be formatted.\n\nIn this file:\njson.cpp\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <rapidjson/document.h>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/json.hpp>\n#include <blackhole/record.hpp>\n\nnamespace {\n\nstruct endpoint_t {\n    std::string host;\n    std::uint16_t port;\n};\n\n}  // namespace\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<>\nstruct display_traits<endpoint_t> {\n    static auto apply(const endpoint_t& endpoint, writer_t& wr) -> void {\n        wr.write(\"{}:{}\", endpoint.host, endpoint.port);\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\nnamespace testing {\nnamespace formatter {\n\nusing ::blackhole::formatter::json_t;\n\nTEST(json_t, FormatMessage) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n}\n\nTEST(json_t, FormatSeverity) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(4, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n\n    ASSERT_TRUE(doc.HasMember(\"severity\"));\n    ASSERT_TRUE(doc[\"severity\"].IsInt());\n    EXPECT_EQ(4, doc[\"severity\"].GetInt());\n}\n\nTEST(json_t, FormatTimestamp) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(4, message, pack);\n    record.activate();\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n\n    ASSERT_TRUE(doc.HasMember(\"timestamp\"));\n    ASSERT_TRUE(doc[\"timestamp\"].IsUint64());\n    EXPECT_TRUE(doc[\"timestamp\"].GetUint64() > 0);\n}\n\nTEST(json_t, FormatAttribute) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"counter\", 42}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n}\n\nTEST(json_t, FormatAttributeNull) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", nullptr}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsNull());\n}\n\nTEST(json_t, FormatAttributeBool) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"available\", true}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"available\"));\n    ASSERT_TRUE(doc[\"available\"].IsBool());\n    EXPECT_TRUE(doc[\"available\"].GetBool());\n}\n\nTEST(json_t, FormatAttributeDouble) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"pi\", 3.1415}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"pi\"));\n    ASSERT_TRUE(doc[\"pi\"].IsDouble());\n    EXPECT_DOUBLE_EQ(3.1415, doc[\"pi\"].GetDouble());\n}\n\nTEST(json_t, FormatAttributeString) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeUser) {\n    endpoint_t endpoint{\"127.0.0.1\", 8080};\n\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", endpoint}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatDuplicateAttributesDefault) {\n    auto formatter = json_t::builder_t()\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list a1{{\"counter\", 42}};\n    const attribute_list a2{{\"counter\", 100}};\n    const attribute_pack pack{a1, a2};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":42\") != std::string::npos);\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":100\") != std::string::npos);\n}\n\nTEST(json_t, FormatDuplicateAttributesUnique) {\n    auto formatter = json_t::builder_t()\n        .unique()\n        .build();\n\n    const string_view message(\"value\");\n    // Earlier attribute list has more precedence than the later ones.\n    const attribute_list a1{{\"counter\", 42}};\n    const attribute_list a2{{\"counter\", 100}};\n    const attribute_pack pack{a1, a2};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":42\") != std::string::npos);\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":100\") == std::string::npos);\n}\n\nTEST(json_t, FormatMessageWithRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields\", {\"message\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"fields\"][\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"fields\"][\"message\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"fields\"][\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"fields\"][\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithNestedRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields/external\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"external\"));\n    ASSERT_TRUE(doc[\"fields\"][\"external\"].IsObject());\n    ASSERT_TRUE(doc[\"fields\"][\"external\"].HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"fields\"][\"external\"][\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"fields\"][\"external\"][\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithRootRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatMessageWithRenaming) {\n    auto formatter = json_t::builder_t()\n        .rename(\"message\", \"#message\")\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"#message\"));\n    ASSERT_TRUE(doc[\"#message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"#message\"].GetString());\n}\n\nTEST(json_t, FormatAttributeWithRenaming) {\n    auto formatter = json_t::builder_t()\n        .rename(\"source\", \"#source\")\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"source\", \"storage\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"#source\"));\n    ASSERT_TRUE(doc[\"#source\"].IsString());\n    EXPECT_STREQ(\"storage\", doc[\"#source\"].GetString());\n}\n\nTEST(json_t, FactoryType) {\n    EXPECT_EQ(\"json\", std::string(factory<formatter::json_t>::type()));\n}\n\n}  // namespace formatter\n}  // namespace testing\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nAuditLogSearchRequest.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.audit_log_search;\n\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.TimeZone;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.UnsupportedRepositoryOperationException;\n\nimport org.apache.commons.lang.StringEscapeUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport org.apache.jackrabbit.api.security.user.Authorizable;\nimport org.apache.jackrabbit.api.security.user.UserManager;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\n\nimport com.adobe.granite.security.user.UserProperties;\nimport com.adobe.granite.security.user.UserPropertiesManager;\nimport com.adobe.granite.security.user.UserPropertiesService;\n\n/**\n * Simple POJO for audit log requests. Handles some of the crufty code around\n * loading and generating the query.\n */\npublic class AuditLogSearchRequest {\n\n    private static final FastDateFormat HTML5_DATETIME_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm\", TimeZone.getTimeZone(\"GMT\"));\n    private static final FastDateFormat QUERY_DATE_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\", TimeZone.getTimeZone(\"GMT\"));\n\n    private static String getJcrSqlDate(Date date) {\n        return QUERY_DATE_FORMAT.format(date) + \".000Z\";\n    }\n\n    private final String contentRoot;\n    private final boolean includeChildren;\n    private final String type;\n    private final String user;\n    private final Date startDate;\n    private final Date endDate;\n    private final String order;\n    private Map<String, String> userNames = new HashMap<String, String>();\n\n    private Map<String, String> userPaths = new HashMap<String, String>();\n\n    /**\n     * Constructs a new AuditLogSearchRequest from the SlingHttpServletRequest\n     *\n     * @param request\n     *            yep, that's a request... guess what it does\n     * @throws ParseException\n     *             an exception occurred parsing the start / end date\n     */\n    public AuditLogSearchRequest(SlingHttpServletRequest request) throws ParseException {\n        contentRoot = request.getParameter(\"contentRoot\");\n        includeChildren = \"true\".equals(request.getParameter(\"includeChildren\"));\n        type = request.getParameter(\"type\");\n        user = request.getParameter(\"user\");\n        startDate = loadDate(request.getParameter(\"startDate\"));\n        endDate = loadDate(request.getParameter(\"endDate\"));\n        order = request.getParameter(\"order\");\n    }\n\n    public String getContentRoot() {\n        return contentRoot;\n    }\n\n    public Date getEndDate() {\n        return Optional.ofNullable(endDate)\n                .map(date -> (Date) date.clone())\n                .orElse(null);\n    }\n\n    public String getOrder() {\n        return order;\n    }\n\n    public String getQueryParameters() {\n        List<String> expressions = new ArrayList<String>();\n\n        if (!StringUtils.isEmpty(type)) {\n            expressions.add(\"[cq:type]='\" + StringEscapeUtils.escapeSql(type) + \"'\");\n        }\n        if (!StringUtils.isEmpty(user)) {\n            expressions.add(\"[cq:userid]='\" + StringEscapeUtils.escapeSql(user) + \"'\");\n        }\n        if (StringUtils.isNotEmpty(contentRoot)) {\n            if (includeChildren) {\n                expressions.add(\"[cq:path] LIKE '\" + StringEscapeUtils.escapeSql(contentRoot) + \"%'\");\n            } else {\n                expressions.add(\"[cq:path]='\" + StringEscapeUtils.escapeSql(contentRoot) + \"'\");\n            }\n        }\n        if (startDate != null) {\n            expressions.add(\"[cq:time] > CAST('\" + getJcrSqlDate(startDate) + \"' AS DATE)\");\n        }\n        if (endDate != null) {\n            expressions.add(\"[cq:time] < CAST('\" + getJcrSqlDate(endDate) + \"' AS DATE)\");\n        }\n        String query = StringUtils.join(expressions, \" AND \");\n        if (!StringUtils.isEmpty(order)) {\n            query += \" ORDER BY \" + order;\n        }\n        return query;\n    }\n\n    public Date getStartDate() {\n        return Optional.ofNullable(startDate)\n                .map(date -> (Date) date.clone())\n                .orElse(null);\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public String getUser() {\n        return user;\n    }\n\n    public String getUserName(ResourceResolver resolver, String userId) throws RepositoryException {\n        if (!userNames.containsKey(userId)) {\n            final UserPropertiesManager upm = resolver.adaptTo(UserPropertiesManager.class);\n            UserProperties userProperties = upm.getUserProperties(userId, UserPropertiesService.PRIVATE_PROFILE);\n            String name = userId;\n            if (userProperties != null && !StringUtils.isEmpty(userProperties.getDisplayName())) {\n                name = userProperties.getDisplayName();\n            }\n            userNames.put(userId, name);\n        }\n        return userNames.get(userId);\n    }\n\n    public String getUserPath(ResourceResolver resolver, String userId)\n            throws UnsupportedRepositoryOperationException, RepositoryException {\n        if (!userPaths.containsKey(userId)) {\n            final UserManager userManager = resolver.adaptTo(UserManager.class);\n            if (userManager != null) {\n                final Authorizable usr = userManager.getAuthorizable(userId);\n                if (usr != null) {\n                    userPaths.put(userId, usr.getPath());\n                }\n            }\n        }\n        return userPaths.get(userId);\n    }\n\n    public boolean isIncludehildren() {\n        return includeChildren;\n    }\n\n    private Date loadDate(String dateStr) throws ParseException {\n        Date date = null;\n        if (!StringUtils.isEmpty(dateStr)) {\n            date = HTML5_DATETIME_FORMAT.parse(dateStr);\n        }\n        return date;\n    }\n\n    @Override\n    public String toString() {\n        return \"AuditLogSearchRequest [contentRoot=\" + contentRoot + \", includeChildren=\" + includeChildren + \", type=\"\n                + type + \", user=\" + user + \", startDate=\" + startDate + \", endDate=\" + endDate + \", order=\" + order\n                + \", userNames=\" + userNames + \", userPaths=\" + userPaths + \"]\";\n    }\n\n}\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nSendTemplatedEmailProcess.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.email.process.impl;\n\nimport java.text.SimpleDateFormat;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.jcr.RepositoryException;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Property;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.jackrabbit.api.security.user.Authorizable;\nimport org.apache.jackrabbit.api.security.user.UserManager;\nimport org.apache.sling.api.resource.LoginException;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.api.resource.ResourceResolverFactory;\nimport org.apache.sling.jcr.resource.api.JcrResourceConstants;\nimport org.osgi.service.component.ComponentContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.adobe.acs.commons.email.EmailService;\nimport com.adobe.acs.commons.wcm.AuthorUIHelper;\nimport com.day.cq.commons.Externalizer;\nimport com.day.cq.dam.commons.util.DamUtil;\nimport com.day.cq.workflow.WorkflowException;\nimport com.day.cq.workflow.WorkflowSession;\nimport com.day.cq.workflow.exec.WorkItem;\nimport com.day.cq.workflow.exec.WorkflowData;\nimport com.day.cq.workflow.exec.WorkflowProcess;\nimport com.day.cq.workflow.metadata.MetaDataMap;\n\n/**\n * This abstract <code>SendTemplatedEmailProcess</code> class is a WorkFlow process step\n * that will send an email using {@link com.adobe.acs.commons.email.EmailService EmailService}.\n * By default jcr properties from the payload are automatically added to the email parameter\n * map. If the payload is a cq:Page then the properties at the jcr:content level\n * are added. If the payload is a dam:Asset then the properties at the metadata\n * node are added. In addition the parameters outlined in\n * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailConstants\n * SendTemplatedEmailConstants} are also automatically added. <br>\n * This process will send the email to a CQ user or members of a CQ group\n * specified by the process argument\n * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailProcess.Arguments#SEND_TO\n * SEND_TO} Implementing classes can override this logic by overriding the\n * method:\n * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailProcess#getEmailAddrs(com.day.cq.workflow.exec.WorkItem, org.apache.sling.api.resource.Resource, java.lang.String[])\n * getEmailAddrs() - method}<br>\n * Implementing classes can also add additional parameters by overriding the\n * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailProcess#getAdditionalParams(WorkItem, WorkflowSession, Resource)\n * getAdditionalParams() - method}\n * <p>\n * <p>\n * <p>\n * <b>Process Configuration</b> This process supports the following\n * configuration arguments:\n * <dl>\n * <dt><b>emailTemplate</b></dt>\n * <dd>String representing a path to the template to be used to send the email.\n * If no template is set no email is sent.</dd>\n * <dt><b>sendTo</b></dt>\n * <dd>String representing a path to a user or group. If the path is a user an\n * email will be sent to that user. if the path is to a group then the email\n * will be sent to all members of that group.</dd>\n * <dt><b>dateFormat</b></dt>\n * <dd>An optional parameter to specify how jcr Date properties are converted to\n * Strings. The format should be set using the\n * {@link java.text.SimpleDateFormat java.text.SimpleDateFormat}. Defaults to\n * <code>yyyy-MM-dd hh:mm a</code></dd>\n * </dl>\n *\n */\n@Component\n@Property(label = \"Workflow Label\", name = \"process.label\", value = \"Send Templated Email\", description = \"Sends a templated email using the ACS Commons Email Service\")\n@Service\npublic class SendTemplatedEmailProcess implements WorkflowProcess {\n\n    private static final Logger log = LoggerFactory.getLogger(SendTemplatedEmailProcess.class);\n\n    /**\n     * Service used to send the email\n     */\n    @Reference\n    private EmailService emailService;\n\n    /**\n     * Service used to generate a link to the payload on author environment\n     */\n    @Reference\n    private AuthorUIHelper authorUiHelper;\n\n    @Reference\n    private ResourceResolverFactory resourceResolverFactory;\n\n    /**\n     * used to generate a link to the payload on publish environment\n     */\n    @Reference\n    private Externalizer externalizer;\n\n    /**\n     * The available arguments to this process implementation.\n     */\n    protected enum Arguments {\n        PROCESS_ARGS(\"PROCESS_ARGS\"),\n        /**\n         * emailTemplate - process argument\n         */\n        TEMPLATE(\"emailTemplate\"),\n        /**\n         * sendTo - process argument\n         */\n        SEND_TO(\"sendTo\"),\n\n        /**\n         * dateFormat - process argument\n         */\n        DATE_FORMAT(\"dateFormat\");\n\n        private String argumentName;\n\n        Arguments(String argumentName) {\n            this.argumentName = argumentName;\n        }\n\n        public String getArgumentName() {\n            return this.argumentName;\n        }\n\n    }\n\n    @Override\n    public final void execute(WorkItem workItem, WorkflowSession workflowSession, MetaDataMap metaData)\n            throws WorkflowException {\n\n        final WorkflowData workflowData = workItem.getWorkflowData();\n        final String type = workflowData.getPayloadType();\n\n        // Check if the payload is a path in the JCR\n        if (!StringUtils.equals(type, \"JCR_PATH\")) {\n            return;\n        }\n\n        String[] args = buildArguments(metaData);\n\n        // process arguments\n        String emailTemplate = getValueFromArgs(Arguments.TEMPLATE.getArgumentName(), args);\n\n        if (emailTemplate == null) {\n            log.warn(\"Invalid process arguments, returning\");\n            return;\n        }\n\n        // set date format to be used in emails\n        String sdfParam = getValueFromArgs(Arguments.DATE_FORMAT.getArgumentName(), args);\n        SimpleDateFormat sdf = getSimpleDateFormat(sdfParam);\n\n        // Get the path to the JCR resource from the payload\n        final String payloadPath = workflowData.getPayload().toString();\n\n        // Get ResourceResolver\n        final Map<String, Object> authInfo = new HashMap<String, Object>();\n        authInfo.put(JcrResourceConstants.AUTHENTICATION_INFO_SESSION, workflowSession.getSession());\n\n        try (ResourceResolver resourceResolver = resourceResolverFactory.getResourceResolver(authInfo) ) {\n            Resource payloadRes = resourceResolver.getResource(payloadPath);\n\n            // Email Parameter map\n            Map<String, String> emailParams = new HashMap<String, String>();\n\n            // Set jcr path\n            emailParams.put(SendTemplatedEmailConstants.JCR_PATH, payloadPath);\n\n            // Get Payload params\n            Map<String, String> payloadProp = SendTemplatedEmailUtils.getPayloadProperties(payloadRes, sdf);\n            if (payloadProp != null) {\n                emailParams.putAll(payloadProp);\n            }\n\n            // Get Url params\n            Map<String, String> urlParams = getUrls(payloadRes);\n            emailParams.putAll(urlParams);\n\n            // Get Additional Parameters to add\n            Map<String, String> wfParams = getAdditionalParams(workItem, workflowSession, payloadRes);\n            emailParams.putAll(wfParams);\n\n            // get email addresses based on CQ user or group\n            String[] emailTo = getEmailAddrs(workItem, payloadRes, args);\n\n            List<String> failureList = emailService.sendEmail(emailTemplate, emailParams, emailTo);\n\n            if (failureList.isEmpty()) {\n                log.info(\"Email sent successfully to {} recipients\", emailTo.length);\n            } else {\n                log.error(\"Email sent failed\");\n            }\n\n        } catch (LoginException e) {\n            log.error(\"Could not acquire a ResourceResolver object from the Workflow Session's JCR Session: {}\", e);\n        }\n    }\n\n    /***\n     * Gets a String[] of email addresses to send the email to. By default calls\n     * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailUtils#getEmailAddrsFromUserPath(ResourceResolver, String)}\n     * Protected so that it can be overridden by implementing classes to add\n     * unique logic to where emails are routed to.\n     *\n     * @param workItem\n     *            the current WorkItem in the workflow\n     * @param payloadResource\n     *            the current payload as a Resource\n     * @param args\n     *            process arguments configured by the workflow step\n     * @return String[] of email addresses\n     */\n    protected String[] getEmailAddrs(WorkItem workItem, Resource payloadResource, String[] args) {\n        ResourceResolver resolver = payloadResource.getResourceResolver();\n        String sendToUser = getValueFromArgs(Arguments.SEND_TO.getArgumentName(), args);\n        return SendTemplatedEmailUtils.getEmailAddrsFromPathOrName(resolver, sendToUser);\n    }\n\n    /***\n     * Returns a Map<String, String> of additional parameters that will be added\n     * to the full list of email parameters that is sent to the EmailService. By\n     * default adds the Workflow Title:\n     * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailConstants#WF_MODEL_TITLE\n     * WF_MODEL_TITLE} and adds the Workflow Step Title:\n     * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailConstants#WF_STEP_TITLE\n     * WF_STEP_TITLE}\n     * {@link com.adobe.acs.commons.email.process.impl.SendTemplatedEmailConstants#WF_INITIATOR\n     * WF_INITIATOR} Protected so that implementing classes can override and\n     * add additional parameters.\n     *\n     * @param workItem\n     * @param workflowSession\n     * @param payloadResource\n     * @return Map<String, String> of additional parameters to be added to email\n     *         params\n     */\n    protected Map<String, String> getAdditionalParams(WorkItem workItem, WorkflowSession workflowSession,\n            Resource payloadResource) {\n        Map<String, String> wfParams = new HashMap<String, String>();\n\n        try {\n            wfParams.put(SendTemplatedEmailConstants.WF_STEP_TITLE, workItem.getNode().getTitle());\n            wfParams.put(SendTemplatedEmailConstants.WF_MODEL_TITLE, workItem.getWorkflow().getWorkflowModel()\n                    .getTitle());\n            // Set workflow initiator\n            wfParams.put(SendTemplatedEmailConstants.WF_INITIATOR, workItem.getWorkflow().getInitiator());\n            \n            if(workItem.getMetaDataMap().containsKey(\"comment\")) {\n                wfParams.put(SendTemplatedEmailConstants.WF_STEP_COMMENT, workItem.getMetaDataMap().get(\"comment\").toString());\n            }\n        } catch (Exception e) {\n            log.warn(\"Error getting workflow title and workflow step title {}\", e);\n        }\n\n        return wfParams;\n    }\n\n    /***\n     * Gets value from workflow process arguments\n     *\n     * @param key\n     * @param arguments\n     * @return String of the argument value or null if not found\n     */\n    protected String getValueFromArgs(String key, String[] arguments) {\n        for (String str : arguments) {\n            String trimmedStr = str.trim();\n            if (trimmedStr.startsWith(key + \":\")) {\n                return trimmedStr.substring((key + \":\").length());\n            }\n        }\n        return null;\n    }\n\n    /***\n     * Uses the AuthorUIHelper to generate links to the payload on author Uses\n     * Externalizer to generate links to the payload on publish\n     *\n     * @param payloadRes\n     * @return\n     */\n    private Map<String, String> getUrls(Resource payloadRes) {\n\n        Map<String, String> urlParams = new HashMap<String, String>();\n        if (payloadRes == null) {\n            return urlParams;\n        }\n\n        String payloadPath = payloadRes.getPath();\n        ResourceResolver resolver = payloadRes.getResourceResolver();\n\n        if (DamUtil.isAsset(payloadRes)) {\n            // add author url\n            String assetDetailsUrl = authorUiHelper.generateEditAssetLink(payloadPath, true, resolver);\n            urlParams.put(SendTemplatedEmailConstants.AUTHOR_LINK, assetDetailsUrl);\n\n            // add publish url\n            String publishUrl = externalizer.publishLink(resolver, payloadPath);\n            urlParams.put(SendTemplatedEmailConstants.PUBLISH_LINK, publishUrl);\n\n        } else {\n\n            // add absolute author url\n            String assetDetailsUrl = authorUiHelper.generateEditPageLink(payloadPath, true, resolver);\n            urlParams.put(SendTemplatedEmailConstants.AUTHOR_LINK, assetDetailsUrl);\n\n            // add publish url\n            String publishUrl = externalizer.publishLink(resolver, payloadPath + \".html\");\n            urlParams.put(SendTemplatedEmailConstants.PUBLISH_LINK, publishUrl);\n        }\n\n        return urlParams;\n    }\n\n    /***\n     *\n     * @param metaData\n     * @return\n     */\n    private String[] buildArguments(MetaDataMap metaData) {\n        // the 'old' way, ensures backward compatibility\n        String processArgs = metaData.get(Arguments.PROCESS_ARGS.getArgumentName(), String.class);\n        if (processArgs != null && !processArgs.equals(\"\")) {\n            return processArgs.split(\",\");\n        } else {\n            return new String[0];\n        }\n    }\n\n    /***\n     * Set the format to be used for displaying dates in the email Defaults to\n     * format of 'yyyy-MM-dd hh:mm a'\n     *\n     * @param formatString\n     *            - workflow process argument to override default format\n     * @return SimpleDateFormat that will be used to convert jcr Date properties\n     *         to Strings\n     */\n    private SimpleDateFormat getSimpleDateFormat(String formatString) {\n        SimpleDateFormat defaultFormat = new SimpleDateFormat(\"yyyy-MM-dd hh:mm a\");\n\n        if (formatString == null || formatString.isEmpty()) {\n            return defaultFormat;\n        }\n\n        try {\n            return new SimpleDateFormat(formatString);\n        } catch (IllegalArgumentException e) {\n            // invalid pattern\n            return defaultFormat;\n        }\n    }\n\n    @Activate\n    protected void activate(ComponentContext context) throws RepositoryException {\n        // activate\n    }\n\n    @Deactivate\n    protected void deactivate(ComponentContext context) {\n        // deactivate\n    }\n\n}\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nVariant.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.data;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.text.ParseException;\nimport java.time.Instant;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.lang3.reflect.MethodUtils;\nimport org.apache.commons.lang3.time.FastDateFormat;\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.CellStyle;\nimport org.apache.poi.ss.usermodel.DataFormatter;\nimport org.apache.poi.ss.usermodel.DateUtil;\nimport org.osgi.annotation.versioning.ProviderType;\n\n/**\n * Used to represent values that might be provided as one baseType but used as\n * another. Avoids glue code and switch statements in other parts of the code\n * especially dealing with data from spreadsheets.\n */\n@ProviderType\npublic final class Variant {\n\n    private Class baseType = null;\n    private static final Locale STANDARD_LOCALE = Locale.ROOT;\n    private static final FastDateFormat STANDARD_DATE_FORMAT = FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.SHORT, STANDARD_LOCALE);\n    private Optional<Long> longVal = Optional.empty();\n    private Optional<Double> doubleVal = Optional.empty();\n    private Optional<String> stringVal = Optional.empty();\n    private Optional<Boolean> booleanVal = Optional.empty();\n    private Optional<Date> dateVal = Optional.empty();\n\n    private static final FastDateFormat[] DATE_FORMATS = {\n            FastDateFormat.getDateInstance(FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getDateInstance(FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getTimeInstance(FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getTimeInstance(FastDateFormat.LONG, STANDARD_LOCALE),\n            STANDARD_DATE_FORMAT,\n            FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.SHORT, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.SHORT, FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.LONG, STANDARD_LOCALE),\n            FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, STANDARD_LOCALE),\n            FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", STANDARD_LOCALE)\n    };\n\n    public Variant() {\n    }\n\n    public <T> Variant(T src) {\n        setValue(src);\n    }\n\n    public Variant(Cell src) {\n        this(src, Locale.getDefault());\n    }\n\n    public Variant(Cell src, Locale locale) {\n        setValue(src, locale);\n    }\n\n    public void clear() {\n        longVal = Optional.empty();\n        doubleVal = Optional.empty();\n        stringVal = Optional.empty();\n        booleanVal = Optional.empty();\n        dateVal = Optional.empty();\n    }\n\n    public boolean isEmpty() {\n        return !stringVal.isPresent()\n                && !longVal.isPresent()\n                && !doubleVal.isPresent()\n                && !dateVal.isPresent()\n                && !booleanVal.isPresent();\n    }\n\n    @SuppressWarnings(\"squid:S00115\")\n    public static enum CellType {\n        // POI switches from int-based to enum-based constants, and unfortunately they also removed things along the way.\n        // This bridges the gap between the constants and the enum types.\n        // _NONE is used to match POI 4, see https://poi.apache.org/apidocs/4.0/org/apache/poi/ss/usermodel/CellType.html\n        // therefore ignoring the code climate issue for this\n        _NONE(3), NUMERIC(0), STRING(1), FORMULA(2), BLANK(3), BOOLEAN(4), ERROR(5);\n        int ord;\n        CellType(int ord) {\n            this.ord=ord;\n        }\n\n        public static CellType fromObject(Object o) {\n            if (o.getClass() == String.class || o.getClass().isEnum()) {\n                return CellType.valueOf(o.toString());\n            } else {\n                int num = (Integer) o;\n                for (CellType ct:values()) {\n                    if (ct.ord == num) {\n                        return ct;\n                    }\n                }\n                return null;\n            }\n        }\n    }\n\n    private void setValue(Cell cell, Locale locale) {\n        try {\n            // Use reflection to access the method as it changes return type from int to CellType in 4.x\n            CellType cellType = CellType.fromObject(MethodUtils.invokeMethod(cell, \"getCellType\"));\n            if (cellType == CellType.FORMULA) {\n                // Use reflection to access the method as it changes return type from int to CellType in 4.x\n                cellType = CellType.fromObject(MethodUtils.invokeMethod(cell,\"getCachedFormulaResultType\"));\n            }\n            switch (cellType) {\n                case BOOLEAN:\n                    setValue(cell.getBooleanCellValue());\n                    break;\n                case NUMERIC:\n                    double number = cell.getNumericCellValue();\n                    if (Math.floor(number) == number) {\n                        setValue((long) number);\n                    } else {\n                        setValue(number);\n                    }\n                    if (DateUtil.isCellDateFormatted(cell)) {\n                        setValue(cell.getDateCellValue());\n                        baseType = Calendar.class;\n                    }\n                    DataFormatter dataFormatter = new DataFormatter(locale);\n                    if (cellType == CellType.FORMULA) {\n                        setValue(dataFormatter.formatCellValue(cell));\n                    } else {\n                        CellStyle cellStyle = cell.getCellStyle();\n                        setValue(dataFormatter.formatRawCellContents(\n                                cell.getNumericCellValue(),\n                                cellStyle.getDataFormat(),\n                                cellStyle.getDataFormatString()\n                        ));\n                    }\n                    break;\n                case STRING:\n                    setValue(cell.getStringCellValue().trim());\n                    break;\n                case BLANK:\n                default:\n                    clear();\n                    break;\n            }\n        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {\n            Logger.getLogger(Variant.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    @SuppressWarnings(\"squid:S3776\")\n    public final <T> void setValue(T val) {\n        if (val == null) {\n            return;\n        }\n        Class valueType = val.getClass();\n        if (valueType == Variant.class) {\n            Variant v = (Variant) val;\n            longVal = v.longVal;\n            doubleVal = v.doubleVal;\n            stringVal = v.stringVal;\n            booleanVal = v.booleanVal;\n            dateVal = v.dateVal;\n            this.baseType = v.baseType;\n        } else if (valueType == Byte.TYPE || valueType == Byte.class) {\n            setLongVal(((Byte) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Integer.TYPE || valueType == Integer.class) {\n            setLongVal(((Integer) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Long.TYPE || valueType == Long.class) {\n            setLongVal((Long) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Short.TYPE || valueType == Short.class) {\n            setLongVal(((Short) val).longValue());\n            if (baseType == null || baseType == String.class) {\n                baseType = Long.TYPE;\n            }\n        } else if (valueType == Float.TYPE || valueType == Float.class\n                || valueType == Double.TYPE || valueType == Double.class) {\n            setDoubleVal((Double) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Double.TYPE;\n            }\n        } else if (valueType == Boolean.TYPE || valueType == Boolean.class) {\n            setBooleanVal((Boolean) val);\n            if (baseType == null || baseType == String.class) {\n                baseType = Boolean.TYPE;\n            }\n        } else if (valueType == String.class) {\n            setStringVal((String) val);\n            if (baseType == null) {\n                baseType = String.class;\n            }\n        } else if (valueType == Date.class) {\n            setDateVal((Date) val);\n            baseType = Calendar.class;\n        } else if (valueType == Instant.class) {\n            setDateVal(new Date(((Instant) val).toEpochMilli()));\n            baseType = Calendar.class;\n        } else if (Calendar.class.isAssignableFrom(valueType)) {\n            setDateVal(((Calendar) val).getTime());\n            baseType = Calendar.class;\n        } else {\n            setStringVal(String.valueOf(val));\n            if (baseType == null) {\n                baseType = String.class;\n            }\n        }\n    }\n\n    private void setLongVal(Long l) {\n        longVal = l == null ? Optional.empty() : Optional.of(l);\n    }\n\n    private void setDoubleVal(Double d) {\n        doubleVal = d == null ? Optional.empty() : Optional.of(d);\n    }\n\n    private void setStringVal(String s) {\n        if (s != null && !s.isEmpty()) {\n            stringVal = Optional.of(s);\n        } else {\n            stringVal = Optional.empty();\n        }\n    }\n\n    private void setBooleanVal(Boolean b) {\n        booleanVal = b == null ? Optional.empty() : Optional.of(b);\n    }\n\n    private void setDateVal(Date d) {\n        dateVal = d == null ? Optional.empty() : Optional.of(d);\n    }\n\n    public Long toLong() {\n        return longVal.orElse(dateVal.map(Date::getTime)\n                .orElse(doubleVal.map(Double::longValue)\n                        .orElse(booleanVal.map(b -> (Long) (b ? 1L : 0L))\n                                .orElseGet(() -> {\n                                    try {\n                                        return stringVal.map(s -> (long) Double.parseDouble(s)).orElse(null);\n                                    } catch (NumberFormatException ex) {\n                                        return null;\n                                    }\n                                }))));\n    }\n\n    public Double toDouble() {\n        return doubleVal.orElse(longVal.map(Long::doubleValue)\n                .orElse(booleanVal.map(b -> (Double) (b ? 1.0 : 0.0))\n                        .orElseGet(() -> {\n                            try {\n                                return stringVal.map(Double::parseDouble).orElse(null);\n                            } catch (NumberFormatException ex) {\n                                return null;\n                            }\n                        })));\n    }\n\n    @Override\n    public String toString() {\n        return stringVal.orElse(dateVal.map(STANDARD_DATE_FORMAT::format)\n                .orElse(doubleVal.map(String::valueOf)\n                        .orElse(longVal.map(String::valueOf)\n                                .orElse(booleanVal.map(String::valueOf)\n                                        .orElse(null)))));\n    }\n\n    public Date toDate() {\n        return dateVal.orElse(longVal.map(Date::new)\n                .orElse(stringVal.map(s -> {\n                    for (FastDateFormat format : DATE_FORMATS) {\n                        try {\n                            return format.parse(s);\n                        } catch (ParseException ex) {\n                            // No good, go to the next pattern\n                        }\n                    }\n                    return null;\n                }).orElse(null)));\n    }\n\n    public Boolean toBoolean() {\n        return booleanVal.orElse(longVal.map(l -> l != 0)\n                .orElse(doubleVal.map(d -> d != 0)\n                        .orElse(stringVal.map(this::isStringTruthy)\n                                .orElse(null))));\n    }\n\n    /**\n     * Truthiness is any non-empty string that looks like a non-zero number or\n     * looks like it is True, Yes, or X\n     *\n     * @param s String to evaluate\n     * @return True if it is truthy, otherwise false\n     */\n    public boolean isStringTruthy(String s) {\n        if (s == null || s.trim().isEmpty()) {\n            return false;\n        } else if (StringUtils.isNumeric(s)) {\n            return Long.parseLong(s) != 0;\n        } else {\n            char c = s.trim().toLowerCase().charAt(0);\n            return (c == 't' || c == 'y' || c == 'x');\n        }\n    }\n\n    private <U, T> T apply(U value, Function<U, T> func) {\n        return value == null ? null : func.apply(value);\n    }\n\n    @SuppressWarnings(\"squid:S3776\")\n    public <T> T asType(Class<T> type) {\n        if (type == Byte.TYPE || type == Byte.class) {\n            return (T) apply(toLong(), Long::byteValue);\n        } else if (type == Integer.TYPE || type == Integer.class) {\n            return (T) apply(toLong(), Long::intValue);\n        } else if (type == Long.TYPE || type == Long.class) {\n            return (T) toLong();\n        } else if (type == Short.TYPE || type == Short.class) {\n            return (T) apply(toLong(), Long::shortValue);\n        } else if (type == Float.TYPE || type == Float.class) {\n            return (T) apply(toDouble(), Double::floatValue);\n        } else if (type == Double.TYPE || type == Double.class) {\n            return (T) toDouble();\n        } else if (type == Boolean.TYPE || type == Boolean.class) {\n            return (T) toBoolean();\n        } else if (type == String.class) {\n            return (T) toString();\n        } else if (type == Date.class) {\n            return (T) toDate();\n        } else if (type == Instant.class) {\n            return (T) toDate().toInstant();\n        } else if (Calendar.class.isAssignableFrom(type)) {\n            Calendar c = Calendar.getInstance();\n            c.setTime(toDate());\n            return (T) c;\n        } else {\n            return null;\n        }\n    }\n\n    public static <S, D> D convert(S val, Class<D> destType) {\n        Variant v = new Variant(val);\n        return v.asType(destType);\n    }\n\n    Class getBaseType() {\n        return baseType;\n    }\n}\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\nTo achieve the possibility of changing string formatter implementation or bug fixes without breaking the ABI it's important to hide that ABI. All other formatters/sinks have already been written in that way.\n\nNote, that this change will break `blackhole::formatter::string_t` API/ABI as it were described in https://github.com/3Hren/blackhole/milestones, but for now it's okay, because nobody uses it explicitly except the Blackhole internals.\n\nIn this file:\nstring.cpp\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <boost/algorithm/string/predicate.hpp>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/string.hpp>\n#include <blackhole/record.hpp>\n\nnamespace {\n\nstruct version_t {\n    int major;\n    int minor;\n};\n\n}  // namespace\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<>\nstruct display_traits<version_t> {\n    static auto apply(const version_t& version, writer_t& wr) -> void {\n        wr.write(\"{}.{}\", version.major, version.minor);\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\nnamespace testing {\n\nusing ::testing::AnyOf;\nusing ::testing::Eq;\n\nTEST(string_t, Message) {\n    formatter::string_t formatter(\"[{message}]\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[value]\", writer.result().to_string());\n}\n\nTEST(string_t, Severity) {\n    // NOTE: No severity mapping provided, formatter falls back to the numeric case.\n    formatter::string_t formatter(\"[{severity}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNum) {\n    formatter::string_t formatter(\"[{severity:d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUser) {\n    formatter::string_t formatter(\"[{severity}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUserExplicit) {\n    formatter::string_t formatter(\"[{severity:s}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNumWithMappingProvided) {\n    formatter::string_t formatter(\"[{severity:d}]\", [](int severity, const std::string&, writer_t& writer) {\n        writer.write(\"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityNumWithSpec) {\n    formatter::string_t formatter(\"[{severity:*^3d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[*0*]\", writer.result().to_string());\n}\n\nTEST(string_t, SeverityUserWithSpec) {\n    formatter::string_t formatter(\"[{severity:<7}]\", [](int severity, const std::string& spec, writer_t& writer) {\n        writer.write(spec, \"DEBUG\");\n    });\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[DEBUG  ]\", writer.result().to_string());\n}\n\nTEST(string_t, CombinedSeverityNumWithMessage) {\n    formatter::string_t formatter(\"[{severity:d}]: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[0]: value\", writer.result().to_string());\n}\n\nTEST(string_t, Generic) {\n    formatter::string_t formatter(\"{protocol}/{version:.1f}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", {1.1}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1\", writer.result().to_string());\n}\n\nTEST(string_t, GenericNull) {\n    formatter::string_t formatter(\"{protocol}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"none\", writer.result().to_string());\n}\n\nTEST(string_t, GenericNullWithSpec) {\n    formatter::string_t formatter(\"{protocol:>5}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\" none\", writer.result().to_string());\n}\n\nTEST(string_t, ThrowsIfGenericAttributeNotFound) {\n    formatter::string_t formatter(\"{protocol}/{version:.1f}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    EXPECT_THROW(formatter.format(record, writer), std::logic_error);\n}\n\nTEST(string_t, GenericOptional) {\n    formatter::string_t formatter(\"{protocol}{version:.1f}\", {\n        {\"version\", formatter::option::optional_t{\"/\", \" - REQUIRED\"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", {1.1}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1 - REQUIRED\", writer.result().to_string());\n}\n\nTEST(string_t, GenericLazyUnspec) {\n    formatter::string_t formatter(\"{protocol}/{version}\");\n\n    version_t version{1, 1};\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", version}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1\", writer.result().to_string());\n}\n\nTEST(string_t, GenericLazySpec) {\n    formatter::string_t formatter(\"{protocol}/{version:>4s} - alpha\");\n\n    version_t version{1, 1};\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"protocol\", {\"HTTP\"}}, {\"version\", version}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"HTTP/1.1 - alpha\", writer.result().to_string());\n}\n\nTEST(string_t, ThrowsIfOptionsContainsReservedPlaceholderNames) {\n    using formatter::option::optional_t;\n\n    EXPECT_THROW((formatter::string_t(\"{protocol}\", {{\"message\", optional_t{\"[\", \"]\"}}})),\n        std::logic_error);\n}\n\nTEST(string_t, Process) {\n    formatter::string_t formatter(\"{process}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(std::to_string(::getpid()), writer.result().to_string());\n}\n\nTEST(string_t, ProcessIdExplicitly) {\n    formatter::string_t formatter(\"{process:d}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(std::to_string(::getpid()), writer.result().to_string());\n}\n\nTEST(string_t, ProcessName) {\n    formatter::string_t formatter(\"{process:s}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_TRUE(writer.result().to_string().size() > 0);\n}\n\nTEST(string_t, Thread) {\n    formatter::string_t formatter(\"{thread}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_EQ(stream.str(), writer.result().to_string());\n}\n\nTEST(string_t, ThreadExplicitly) {\n    formatter::string_t formatter(\"{thread:#x}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_EQ(stream.str(), writer.result().to_string());\n}\n\nTEST(string_t, ThreadExplicitlySpec) {\n    formatter::string_t formatter(\"{thread:>#16x}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    std::ostringstream stream;\n#ifdef __linux__\n    stream << std::hex << std::internal << std::showbase << std::setw(2) << std::setfill('0');\n#endif\n    stream << std::this_thread::get_id();\n\n    EXPECT_TRUE(boost::ends_with(writer.result().to_string(), stream.str()));\n}\n\nstruct threadname_guard {\n    template<std::size_t N>\n    threadname_guard(const char(&name)[N]) {\n        #ifdef __linux__\n            ::pthread_setname_np(::pthread_self(), name);\n        #elif __APPLE__\n            ::pthread_setname_np(name);\n        #else\n        #error \"Not implemented. Please write an implementation for your OS.\"\n        #endif\n    }\n\n    ~threadname_guard() {\n        #ifdef __linux__\n            ::pthread_setname_np(::pthread_self(), \"\");\n        #elif __APPLE__\n            ::pthread_setname_np(\"\");\n        #else\n        #error \"Not implemented. Please write an implementation for your OS.\"\n        #endif\n    }\n};\n\nTEST(string_t, ThreadName) {\n    formatter::string_t formatter(\"{thread:s}\");\n\n    threadname_guard guard(\"thread#0\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"thread#0\", writer.result().to_string());\n}\n\nTEST(string_t, ThreadNameWithSpec) {\n    formatter::string_t formatter(\"{thread:>10s}\");\n\n    threadname_guard guard(\"thread#0\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"  thread#0\", writer.result().to_string());\n}\n\nTEST(string_t, Timestamp) {\n    // NOTE: By default %Y-%m-%d %H:%M:%S.%f pattern is used.\n    formatter::string_t formatter(\"[{timestamp}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \".\" << fmt::pad(std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count() % 1000000, 6, '0') << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampExplicit) {\n    formatter::string_t formatter(\"[{timestamp:{%Y}}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampExplicitWithType) {\n    formatter::string_t formatter(\"[{timestamp:{%H:%M:%S}s}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[\" << fmt::StringRef(buffer, len) << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampSpec) {\n    formatter::string_t formatter(\"[{timestamp:>30s}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto time = record_t::clock_type::to_time_t(timestamp);\n    std::tm tm;\n    ::gmtime_r(&time, &tm);\n    char buffer[128];\n    const auto len = std::strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", &tm);\n    fmt::MemoryWriter wr;\n    wr << \"[    \" << fmt::StringRef(buffer, len) << \".\" << fmt::pad(std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count() % 1000000, 6, '0') << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, TimestampNum) {\n    formatter::string_t formatter(\"[{timestamp:d}]\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n\n    const auto timestamp = record.timestamp();\n    const auto usec = std::chrono::duration_cast<\n        std::chrono::microseconds\n    >(timestamp.time_since_epoch()).count();\n    fmt::MemoryWriter wr;\n    wr << \"[\" << usec << \"]\";\n\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(wr.str(), writer.result().to_string());\n}\n\nTEST(string_t, Leftover) {\n    formatter::string_t formatter(\"{...}\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1: 42, key#2: value#2\"),\n        Eq(\"key#2: value#2, key#1: 42\")\n    ));\n}\n\nTEST(string_t, LeftoverEmpty) {\n    formatter::string_t formatter(\"[{...}]\");\n\n    const string_view message(\"-\");\n    const attribute_list attributes{};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"[]\", writer.result().to_string());\n}\n\nTEST(string_t, LeftoverWithPrefixAndSuffix) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}: {v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"[key#1: 42, key#2: value#2]\"),\n        Eq(\"[key#2: value#2, key#1: 42]\")\n    ));\n}\n\nTEST(string_t, LeftoverEmptyWithPrefixAndSuffix) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}: {v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_EQ(\"\", writer.result().to_string());\n}\n\nTEST(DISABLED_string_t, LeftoverWithPattern) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"\", \"\", \"{k}={v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1=42, key#2=value#2\"),\n        Eq(\"key#2=value#2, key#1=42\")\n    ));\n}\n\nTEST(string_t, LeftoverWithSeparator) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"\", \"\", \"{k}={v}\", \" | \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    EXPECT_THAT(writer.result().to_string(), AnyOf(\n        Eq(\"key#1: 42 | key#2: value#2\"),\n        Eq(\"key#2: value#2 | key#1: 42\")\n    ));\n}\n\nTEST(string_t, Type) {\n    EXPECT_EQ(\"string\", std::string(factory<formatter::string_t>::type()));\n}\n\n}  // namespace testing\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nChecksumGeneratorOptionsFactory.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum.impl.options;\n\nimport com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGeneratorOptions;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.sling.api.SlingHttpServletRequest;\n\nimport java.io.IOException;\n\npublic class ChecksumGeneratorOptionsFactory {\n\n    private ChecksumGeneratorOptionsFactory() {\n        // Private cstor\n    }\n\n    public static ChecksumGeneratorOptions getOptions(SlingHttpServletRequest request, String name) throws IOException {\n        if (StringUtils.equalsIgnoreCase(\"REQUEST\", name)) {\n            return new RequestChecksumGeneratorOptions(request);\n        } else {\n            return new DefaultChecksumGeneratorOptions(request);\n        }\n    }\n}\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nReviewTaskAssetMoverHandler.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.dam.impl;\n\n\nimport com.adobe.acs.commons.cqsearch.QueryUtil;\nimport com.adobe.granite.asset.api.Asset;\nimport com.adobe.granite.asset.api.AssetManager;\nimport com.adobe.granite.asset.api.AssetVersionManager;\nimport com.day.cq.commons.jcr.JcrConstants;\nimport com.day.cq.commons.jcr.JcrUtil;\nimport com.day.cq.dam.api.DamConstants;\nimport com.day.cq.search.PredicateGroup;\nimport com.day.cq.search.Query;\nimport com.day.cq.search.QueryBuilder;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.ConfigurationPolicy;\nimport org.apache.felix.scr.annotations.Properties;\nimport org.apache.felix.scr.annotations.Property;\nimport org.apache.felix.scr.annotations.PropertyOption;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.resource.LoginException;\nimport org.apache.sling.api.resource.PersistenceException;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.api.resource.ResourceResolverFactory;\nimport org.apache.sling.api.resource.ValueMap;\nimport org.apache.sling.commons.osgi.PropertiesUtil;\nimport org.apache.sling.commons.scheduler.ScheduleOptions;\nimport org.apache.sling.commons.scheduler.Scheduler;\nimport org.osgi.service.event.Event;\nimport org.osgi.service.event.EventConstants;\nimport org.osgi.service.event.EventHandler;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.Node;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport java.text.SimpleDateFormat;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n@Component(\n        label = \"ACS AEM Commons - Review Task Move Handler\",\n        description = \"Create an OSGi configuration to enable this feature.\",\n        metatype = true,\n        immediate = true,\n        policy = ConfigurationPolicy.REQUIRE\n)\n@Properties({\n        @Property(\n                label = \"Event Topics\",\n                value = {ReviewTaskAssetMoverHandler.DEFAULT_TOPIC},\n                description = \"[Required] Event Topics this event handler will to respond to. Defaults to: com/adobe/granite/taskmanagement/event\",\n                name = EventConstants.EVENT_TOPIC,\n                propertyPrivate = true\n        ),\n\n        /* Event filters support LDAP filter syntax and have access to event.getProperty(..) values */\n        /* LDAP Query syntax: https://goo.gl/MCX2or */\n        @Property(\n                label = \"Event Filters\",\n                // Only listen on events associated with nodes that end with /jcr:content\n                value = \"(&(TaskTypeName=dam:review)(EventType=TASK_COMPLETED))\",\n                description = \"Event Filters used to further restrict this event handler; Uses LDAP expression against event properties. Defaults to: (&(TaskTypeName=dam:review)(EventType=TASK_COMPLETED))\",\n                name = EventConstants.EVENT_FILTER,\n                propertyPrivate = true\n        )\n})\n@Service\npublic class ReviewTaskAssetMoverHandler implements EventHandler {\n    private static final Logger log = LoggerFactory.getLogger(ReviewTaskAssetMoverHandler.class);\n\n    public static final String DEFAULT_TOPIC = \"com/adobe/granite/taskmanagement/event\";\n    private static final String PATH_CONTENT_DAM = DamConstants.MOUNTPOINT_ASSETS;\n    private static final String APPROVED = \"approved\";\n    private static final String REJECTED = \"rejected\";\n    private static final String REL_ASSET_METADATA = \"jcr:content/metadata\";\n    private static final String REL_ASSET_RENDITIONS = \"jcr:content/renditions\";\n    private static final String REL_PN_DAM_STATUS = REL_ASSET_METADATA + \"/dam:status\";\n\n    private static final String PN_ON_APPROVE = \"onApproveMoveTo\";\n    private static final String PN_ON_REJECT = \"onRejectMoveTo\";\n    private static final String PN_CONTENT_PATH = \"contentPath\";\n    private static final String PN_CONFLICT_RESOLUTION = \"onReviewConflictResolution\";\n    private static final String CONFLICT_RESOLUTION_SKIP = \"skip\";\n    private static final String CONFLICT_RESOLUTION_REPLACE = \"replace\";\n    private static final String CONFLICT_RESOLUTION_NEW_ASSET = \"new-asset\";\n    private static final String CONFLICT_RESOLUTION_NEW_VERSION = \"new-version\";\n\n    public static final String USER_EVENT_TYPE = \"acs-aem-commons.review-task-mover\";\n\n    private static final String SERVICE_NAME = \"review-task-asset-mover\";\n    private static final Map<String, Object> AUTH_INFO;\n\n    static {\n        AUTH_INFO = Collections.singletonMap(ResourceResolverFactory.SUBSERVICE, (Object) SERVICE_NAME);\n    }\n\n    @Reference\n    private ResourceResolverFactory resourceResolverFactory;\n\n    @Reference\n    private Scheduler scheduler;\n\n    @Reference\n    private QueryBuilder queryBuilder;\n\n    private static final String DEFAULT_DEFAULT_CONFLICT_RESOLUTION = CONFLICT_RESOLUTION_NEW_VERSION;\n    private String defaultConflictResolution = DEFAULT_DEFAULT_CONFLICT_RESOLUTION;\n    @Property(label = \"Default Conflict Resolution\",\n            description = \"Select default behavior if conflict resolution is not provided at the review task level.\",\n            options = {\n                    @PropertyOption(name = CONFLICT_RESOLUTION_NEW_VERSION, value = \"Add as version (new-version)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_NEW_ASSET, value = \"Add as new asset (new-asset)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_REPLACE, value = \"Replace (replace)\"),\n                    @PropertyOption(name = CONFLICT_RESOLUTION_SKIP, value = \"Skip (skip)\")\n            },\n            value = DEFAULT_DEFAULT_CONFLICT_RESOLUTION)\n    public static final String PROP_DEFAULT_CONFLICT_RESOLUTION = \"conflict-resolution.default\";\n\n    private static final String DEFAULT_LAST_MODIFIED_BY = \"Review Task\";\n    private String lastModifiedBy = DEFAULT_LAST_MODIFIED_BY;\n    @Property(label = \"Last Modified By\",\n            description = \"For Conflict Resolution: Version, the review task event does not track the user that completed the event. Use this property to specify the static name of of the [dam:Asset]/jcr:content@jcr:lastModifiedBy. Default: Review Task\",\n            value = DEFAULT_LAST_MODIFIED_BY)\n    public static final String PROP_LAST_MODIFIED_BY = \"conflict-resolution.version.last-modified-by\";\n\n\n    @Activate\n    protected void activate(Map<String, Object> config) {\n        lastModifiedBy = PropertiesUtil.toString(config.get(PROP_LAST_MODIFIED_BY), DEFAULT_LAST_MODIFIED_BY);\n        defaultConflictResolution = PropertiesUtil.toString(config.get(PROP_DEFAULT_CONFLICT_RESOLUTION), DEFAULT_DEFAULT_CONFLICT_RESOLUTION);\n    }\n\n    @Override\n    public void handleEvent(Event event) {\n\n        try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(AUTH_INFO)) {\n            final String path = (String) event.getProperty(\"TaskId\");\n            final Resource taskResource = resourceResolver.getResource(path);\n\n            if (taskResource != null) {\n                final ValueMap taskProperties = taskResource.getValueMap();\n\n                // Perform a fast check to see if this project has the required properties to perform the asset moving\n                if (StringUtils.startsWith(taskProperties.get(PN_ON_APPROVE, String.class), PATH_CONTENT_DAM)\n                        || StringUtils.startsWith(taskProperties.get(PN_ON_REJECT, String.class), PATH_CONTENT_DAM)) {\n\n                    log.debug(\"Handling event (creating a Job) for Assets Review Task @ [ {} ]\", path);\n\n                    ScheduleOptions options = scheduler.NOW();\n                    String jobName = this.getClass().getSimpleName().toString().replace(\".\", \"/\") + \"/\" + path;\n                    options.name(jobName);\n\n                    options.canRunConcurrently(false);\n\n                    scheduler.schedule(new ImmediateJob(path), options);\n                }\n            }\n        } catch (LoginException e) {\n            log.error(\"Could not get resource resolver\", e);\n        }\n    }\n\n    private class ImmediateJob implements Runnable {\n        private final String path;\n\n        public ImmediateJob(String path) {\n            this.path = path;\n        }\n\n        @Override\n        public void run() {\n            try (ResourceResolver resourceResolver = resourceResolverFactory.getServiceResourceResolver(AUTH_INFO)) {\n\n                // Access data passed into the Job from the Event\n                Resource resource = resourceResolver.getResource(path);\n                AssetManager assetManager = resourceResolver.adaptTo(AssetManager.class);\n\n                if (resource != null && assetManager != null) {\n                    ValueMap taskProperties = resource.getValueMap();\n                    String contentPath = taskProperties.get(PN_CONTENT_PATH, String.class);\n\n                    if (StringUtils.startsWith(contentPath, PATH_CONTENT_DAM)) {\n                        Query query = findAssets(resourceResolver, contentPath);\n                        log.debug(\"Found [ {} ] assets under [ {} ] that were reviewed and require processing.\",\n                                query.getResult().getHits().size(),\n                                contentPath);\n\n                        final Iterator<Resource> assets = query.getResult().getResources();\n                        resourceResolver.adaptTo(Session.class).getWorkspace().getObservationManager().setUserData(USER_EVENT_TYPE);\n\n                        while (assets.hasNext()) {\n                            final Asset asset = assetManager.getAsset(assets.next().getPath());\n                            moveAsset(resourceResolver, assetManager, asset, taskProperties);\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                log.error(\"Could not process Review Task Mover\", e);\n            }\n        }\n\n        /**\n         * Find all assets under the Task contentPath that have a dam:status of approved or rejected.\n         *\n         * @param resourceResolver the resource resolver used to find the Assets to move.\n         * @param contentPath      the DAM contentPath which the task covers.\n         * @return the CloseableQuery whose result represents dam:Assets for which dam:status is set to approved or rejected\n         */\n        private Query findAssets(ResourceResolver resourceResolver, String contentPath) {\n            Map<String, String> params = new HashMap<String, String>();\n            params.put(\"type\", DamConstants.NT_DAM_ASSET);\n            params.put(\"path\", contentPath);\n            params.put(\"property\", REL_PN_DAM_STATUS);\n            params.put(\"property.1_value\", APPROVED);\n            params.put(\"property.2_value\", REJECTED);\n            params.put(\"p.offset\", \"0\");\n            params.put(\"p.limit\", \"-1\");\n\n            Query query = queryBuilder.createQuery(PredicateGroup.create(params), resourceResolver.adaptTo(Session.class));\n            QueryUtil.setResourceResolverOn(resourceResolver, query);\n            return query;\n        }\n\n\n        /**\n         * Create a unique asset name based on the current time and a up-to-1000 counter.\n         *\n         * @param assetManager assetManager object\n         * @param destPath     the folder the asset will be moved into\n         * @param assetName    the asset name\n         * @return a unique asset path to the asset\n         * @throws PersistenceException\n         */\n        private String createUniqueAssetPath(AssetManager assetManager, String destPath, String assetName) throws PersistenceException {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n            final String now = sdf.format(new Date());\n            String destAssetPath = destPath + \"/\" + assetName;\n\n            int count = 0;\n            while (assetManager.assetExists(destAssetPath)) {\n                if (count > 1000) {\n                    throw new PersistenceException(\"Unable to generate a unique name after 1000 attempts. Something must be wrong!\");\n                }\n\n                if (count == 0) {\n                    destAssetPath = destPath + \"/\" + now + \"_\" + assetName;\n                } else {\n                    destAssetPath = destPath + \"/\" + now + \"_\" + count + \"_\" + assetName;\n                }\n\n                count++;\n            }\n\n            return destAssetPath;\n        }\n\n        /**\n         * Creates a new revision of an asset and replaces its renditions (including original), and metadata node.\n         *\n         * @param resourceResolver the ResourceResolver object\n         * @param assetManager     the AssetManager object\n         * @param originalAsset    the asset to create a new version for\n         * @param reviewedAsset    the asset to that will represent the new version\n         * @throws PersistenceException\n         */\n        private void createRevision(ResourceResolver resourceResolver, AssetManager assetManager, Asset originalAsset, Asset reviewedAsset) throws PersistenceException {\n            Session session = resourceResolver.adaptTo(Session.class);\n\n            // Create the new version\n            AssetVersionManager versionManager = resourceResolver.adaptTo(AssetVersionManager.class);\n            versionManager.createVersion(originalAsset.getPath(), \"Review Task (\" + reviewedAsset.getValueMap().get(REL_PN_DAM_STATUS, \"Unknown\") + \")\");\n\n            String assetPath = originalAsset.getPath();\n\n            // Delete the existing metadata and renditions from the old asset\n\n            resourceResolver.delete(resourceResolver.getResource(assetPath + \"/\" + REL_ASSET_METADATA));\n            resourceResolver.delete(resourceResolver.getResource(assetPath + \"/\" + REL_ASSET_RENDITIONS));\n\n            try {\n                Node originalAssetJcrContentNode = session.getNode(originalAsset.getPath() + \"/\" + JcrConstants.JCR_CONTENT);\n\n                Node newAssetMetadataNode = session.getNode(reviewedAsset.getPath() + \"/\" + REL_ASSET_METADATA);\n                Node newAssetRenditionsNode = session.getNode(reviewedAsset.getPath() + \"/\" + REL_ASSET_RENDITIONS);\n\n                JcrUtil.copy(newAssetMetadataNode, originalAssetJcrContentNode, null);\n                JcrUtil.copy(newAssetRenditionsNode, originalAssetJcrContentNode, null);\n\n                JcrUtil.setProperty(originalAssetJcrContentNode, JcrConstants.JCR_LASTMODIFIED, new Date());\n                JcrUtil.setProperty(originalAssetJcrContentNode, JcrConstants.JCR_LAST_MODIFIED_BY, lastModifiedBy);\n\n                assetManager.removeAsset(reviewedAsset.getPath());\n            } catch (RepositoryException e) {\n                log.error(\"Could not create a new version of the asset\", e);\n                throw new PersistenceException(e.getMessage());\n            }\n        }\n\n        /**\n         * Move the asset based on the its dam:status (approved or rejected).\n         *\n         * @param asset          the asset to move\n         * @param taskProperties the task properties containing the target onApproveMoveTo and onRejectMoveTo paths\n         */\n        @SuppressWarnings(\"squid:S3776\")\n        private void moveAsset(ResourceResolver resourceResolver, AssetManager assetManager, Asset asset, ValueMap taskProperties) {\n            try {\n                final String status = asset.getValueMap().get(REL_PN_DAM_STATUS, String.class);\n                final String conflictResolution = taskProperties.get(PN_CONFLICT_RESOLUTION, defaultConflictResolution);\n                final String onApprovePath = taskProperties.get(PN_ON_APPROVE, String.class);\n                final String onRejectPath = taskProperties.get(PN_ON_REJECT, String.class);\n\n                String destPath = null;\n\n                if (StringUtils.equals(APPROVED, status)) {\n                    destPath = onApprovePath;\n                } else if (StringUtils.equals(REJECTED, status)) {\n                    destPath = onRejectPath;\n                }\n\n                if (destPath != null) {\n                    if (StringUtils.startsWith(destPath, PATH_CONTENT_DAM)) {\n\n                        String destAssetPath = destPath + \"/\" + asset.getName();\n                        final boolean exists = assetManager.assetExists(destAssetPath);\n\n                        if (exists) {\n                            if (StringUtils.equals(asset.getPath(), destAssetPath)) {\n                                log.info(\"Reviewed asset [ {} ] is already in its final location, so there is nothing to do.\", asset.getPath());\n                            } else if (CONFLICT_RESOLUTION_REPLACE.equals(conflictResolution)) {\n                                assetManager.removeAsset(destAssetPath);\n                                resourceResolver.commit();\n                                assetManager.moveAsset(asset.getPath(), destAssetPath);\n                                log.info(\"Moved with replace [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            } else if (CONFLICT_RESOLUTION_NEW_ASSET.equals(conflictResolution)) {\n                                destAssetPath = createUniqueAssetPath(assetManager, destPath, asset.getName());\n                                assetManager.moveAsset(asset.getPath(), destAssetPath);\n                                log.info(\"Moved with unique asset name [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            } else if (CONFLICT_RESOLUTION_NEW_VERSION.equals(conflictResolution)) {\n                                log.info(\"Creating new version of existing asset [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                                createRevision(resourceResolver, assetManager, assetManager.getAsset(destAssetPath), asset);\n                            } else if (CONFLICT_RESOLUTION_SKIP.equals(conflictResolution)) {\n                                log.info(\"Skipping with due to existing asset at the same destination [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                        asset.getPath(), destAssetPath, status);\n                            }\n                        } else {\n                            assetManager.moveAsset(asset.getPath(), destAssetPath);\n                            log.info(\"Moved [ {} ] ~> [ {} ] based on approval status [ {} ]\",\n                                    asset.getPath(), destAssetPath, status);\n                        }\n                    } else {\n                        log.warn(\"Request to move reviewed asset to a non DAM Asset path [ {} ]\", destPath);\n                    }\n                }\n\n                if (resourceResolver.hasChanges()) {\n                    resourceResolver.commit();\n                }\n            } catch (PersistenceException e) {\n                log.error(\"Could not move reviewed asset [ {} ]\", asset.getPath(), e);\n                resourceResolver.revert();\n                resourceResolver.refresh();\n            }\n        }\n    }\n\n    protected void bindResourceResolverFactory(ResourceResolverFactory resourceResolverFactory) {\n        if (this.resourceResolverFactory == null) {\n            this.resourceResolverFactory = resourceResolverFactory;\n        }\n    }\n\n    protected void unbindResourceResolverFactory(ResourceResolverFactory resourceResolverFactory) {\n        if (this.resourceResolverFactory == resourceResolverFactory) {\n            this.resourceResolverFactory = null;\n        }\n    }\n\n    protected void bindScheduler(Scheduler scheduler) {\n        if (this.scheduler == null) {\n            this.scheduler = scheduler;\n        }\n    }\n\n    protected void unbindScheduler(Scheduler scheduler) {\n        if (this.scheduler == scheduler) {\n            this.scheduler = null;\n        }\n    }\n\n    protected void bindQueryBuilder(QueryBuilder queryBuilder) {\n        if (this.queryBuilder == null) {\n            this.queryBuilder = queryBuilder;\n        }\n    }\n\n    protected void unbindQueryBuilder(QueryBuilder queryBuilder) {\n        if (this.queryBuilder == queryBuilder) {\n            this.queryBuilder = null;\n        }\n    }\n}\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\nIn this file:\njson.cpp\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n#include <rapidjson/document.h>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/json.hpp>\n#include <blackhole/record.hpp>\n\nnamespace {\n\nstruct endpoint_t {\n    std::string host;\n    std::uint16_t port;\n};\n\n}  // namespace\n\nnamespace blackhole {\ninline namespace v1 {\n\ntemplate<>\nstruct display_traits<endpoint_t> {\n    static auto apply(const endpoint_t& endpoint, writer_t& wr) -> void {\n        wr.write(\"{}:{}\", endpoint.host, endpoint.port);\n    }\n};\n\n}  // namespace v1\n}  // namespace blackhole\n\nnamespace blackhole {\nnamespace testing {\nnamespace formatter {\n\nusing ::blackhole::formatter::json_t;\n\nTEST(json_t, FormatMessage) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n}\n\nTEST(json_t, FormatSeverity) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(4, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n\n    ASSERT_TRUE(doc.HasMember(\"severity\"));\n    ASSERT_TRUE(doc[\"severity\"].IsInt());\n    EXPECT_EQ(4, doc[\"severity\"].GetInt());\n}\n\nTEST(json_t, FormatTimestamp) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(4, message, pack);\n    record.activate();\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n\n    ASSERT_TRUE(doc.HasMember(\"timestamp\"));\n    ASSERT_TRUE(doc[\"timestamp\"].IsUint64());\n    EXPECT_TRUE(doc[\"timestamp\"].GetUint64() > 0);\n}\n\nTEST(json_t, FormatAttribute) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"counter\", 42}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n}\n\nTEST(json_t, FormatAttributeNull) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", nullptr}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsNull());\n}\n\nTEST(json_t, FormatAttributeBool) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"available\", true}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"available\"));\n    ASSERT_TRUE(doc[\"available\"].IsBool());\n    EXPECT_TRUE(doc[\"available\"].GetBool());\n}\n\nTEST(json_t, FormatAttributeDouble) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"pi\", 3.1415}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"pi\"));\n    ASSERT_TRUE(doc[\"pi\"].IsDouble());\n    EXPECT_DOUBLE_EQ(3.1415, doc[\"pi\"].GetDouble());\n}\n\nTEST(json_t, FormatAttributeString) {\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeUser) {\n    endpoint_t endpoint{\"127.0.0.1\", 8080};\n\n    json_t formatter;\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", endpoint}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatDuplicateAttributesDefault) {\n    auto formatter = json_t::builder_t()\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list a1{{\"counter\", 42}};\n    const attribute_list a2{{\"counter\", 100}};\n    const attribute_pack pack{a1, a2};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":42\") != std::string::npos);\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":100\") != std::string::npos);\n}\n\nTEST(json_t, FormatDuplicateAttributesUnique) {\n    auto formatter = json_t::builder_t()\n        .unique()\n        .build();\n\n    const string_view message(\"value\");\n    // Earlier attribute list has more precedence than the later ones.\n    const attribute_list a1{{\"counter\", 42}};\n    const attribute_list a2{{\"counter\", 100}};\n    const attribute_pack pack{a1, a2};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"message\"].GetString());\n\n    ASSERT_TRUE(doc.HasMember(\"counter\"));\n    ASSERT_TRUE(doc[\"counter\"].IsInt());\n    EXPECT_EQ(42, doc[\"counter\"].GetInt());\n\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":42\") != std::string::npos);\n    EXPECT_TRUE(writer.result().to_string().find(\"\\\"counter\\\":100\") == std::string::npos);\n}\n\nTEST(json_t, FormatMessageWithRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields\", {\"message\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"message\"));\n    ASSERT_TRUE(doc[\"fields\"][\"message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"fields\"][\"message\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"fields\"][\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"fields\"][\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithNestedRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"/fields/external\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"fields\"));\n    ASSERT_TRUE(doc[\"fields\"].HasMember(\"external\"));\n    ASSERT_TRUE(doc[\"fields\"][\"external\"].IsObject());\n    ASSERT_TRUE(doc[\"fields\"][\"external\"].HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"fields\"][\"external\"][\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"fields\"][\"external\"][\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatAttributeStringWithRootRouting) {\n    auto formatter = json_t::builder_t()\n        .route(\"\", {\"endpoint\"})\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"endpoint\", \"127.0.0.1:8080\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"endpoint\"));\n    ASSERT_TRUE(doc[\"endpoint\"].IsString());\n    EXPECT_STREQ(\"127.0.0.1:8080\", doc[\"endpoint\"].GetString());\n}\n\nTEST(json_t, FormatMessageWithRenaming) {\n    auto formatter = json_t::builder_t()\n        .rename(\"message\", \"#message\")\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"#message\"));\n    ASSERT_TRUE(doc[\"#message\"].IsString());\n    EXPECT_STREQ(\"value\", doc[\"#message\"].GetString());\n}\n\nTEST(json_t, FormatAttributeWithRenaming) {\n    auto formatter = json_t::builder_t()\n        .rename(\"source\", \"#source\")\n        .build();\n\n    const string_view message(\"value\");\n    const attribute_list attributes{{\"source\", \"storage\"}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n    formatter.format(record, writer);\n\n    rapidjson::Document doc;\n    doc.Parse<0>(writer.result().to_string().c_str());\n    ASSERT_TRUE(doc.HasMember(\"#source\"));\n    ASSERT_TRUE(doc[\"#source\"].IsString());\n    EXPECT_STREQ(\"storage\", doc[\"#source\"].GetString());\n}\n\n}  // namespace formatter\n}  // namespace testing\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nNodeExistsPredicateEvaluator.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.cqsearch.impl;\n\nimport com.day.cq.search.Predicate;\nimport com.day.cq.search.eval.AbstractPredicateEvaluator;\nimport com.day.cq.search.eval.EvaluationContext;\nimport com.day.cq.search.eval.PredicateEvaluator;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.RepositoryException;\nimport javax.jcr.query.Row;\nimport java.util.Map;\n\n/**\n * This AEM QueryBuilder predicate checks if a JCR node exists, or doesn't\n * exist, off the provided relative path.\n *\n * There are 3 configurations:\n *\n * nodeExists.or = true | false (defaults to false) -- When nodeExists.or =\n * false (the default), all .exists and .notexists conditions for this predicate\n * are AND'd together to determine if the result node is included.\n *\n * nodeExists.#_exists = relative path (relative from the result node) to\n * another node. This relative path mush exist for this expression to return\n * true -- Multiple exists conditions can be present and need to be prefixed via\n * the usual `#_exists` syntax.\n *\n * nodeExists.#_notexists = relative path (relative from the result node) to\n * another node. This relative path mush NOT exist for this expression to return\n * true -- Multiple exists conditions can be present and need to be prefixed via\n * the usual `#_notexists` syntax.\n *\n * nodeExists.or=true nodeExists.exists=jcr:content/renditions/original\n * nodeExists.2_exists=jcr:content/renditions/cq5dam.thumbnail.48.48.png\n * nodeExists.1_notexists=jcr:content/renditions/cq5dam.web.1280.1280.png\n * nodeExists.2_notexists=jcr:content/renditions/cq5dam.web.600.400.png\n */\n@Component(\n        factory = \"com.day.cq.search.eval.PredicateEvaluator/nodeExists\"\n)\npublic class NodeExistsPredicateEvaluator extends AbstractPredicateEvaluator implements PredicateEvaluator {\n\n    private static final Logger log = LoggerFactory.getLogger(NodeExistsPredicateEvaluator.class);\n\n    public static final String OR = \"or\";\n    public static final String EXISTS_REL_PATH = \"exists\";\n    public static final String NOT_EXISTS_REL_PATH = \"notexists\";\n\n    @Override\n    public final boolean canXpath(final Predicate predicate, final EvaluationContext context) {\n        return false;\n    }\n\n    @Override\n    public final boolean canFilter(final Predicate predicate, final EvaluationContext context) {\n        return !(predicate.getParameters().isEmpty()\n                || (predicate.getParameters().size() == 1\n                && predicate.getParameters().get(OR) != null));\n    }\n\n    @Override\n    @SuppressWarnings(\"squid:S3776\")\n    public final boolean includes(final Predicate predicate, final Row row, final EvaluationContext context) {\n        boolean or = predicate.getBool(OR);\n\n        if (log.isDebugEnabled()) {\n            if (or) {\n                log.debug(\"NodeExistsPredicatorEvaluator evaluating as [ OR ]\");\n            } else {\n                log.debug(\"NodeExistsPredicatorEvaluator evaluating as [ AND ]\");\n            }\n        }\n\n        for (final Map.Entry<String, String> entry : predicate.getParameters().entrySet()) {\n            boolean ruleIncludes = false;\n\n            String operation = entry.getKey();\n            if (StringUtils.contains(operation, \"_\")) {\n                operation = StringUtils.substringAfterLast(entry.getKey(), \"_\");\n            }\n\n            try {\n                if (EXISTS_REL_PATH.equals(operation)) {\n                    ruleIncludes = row.getNode().hasNode(entry.getValue());\n                } else if (NOT_EXISTS_REL_PATH.equals(operation)) {\n                    ruleIncludes = !row.getNode().hasNode(entry.getValue());\n                } else if (!OR.equals(operation)) {\n                    log.debug(\"Invalid operation [ {} ]\", operation);\n                }\n\n                // Return quickly from the evaluation loop\n                if (or && ruleIncludes) {\n                    // If OR condition; return true on the first condition match\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Including [ {} ] based on [ {}  -> {} ] as part of [ OR ]\",\n                                row.getPath(), operation, entry.getValue());\n                    }\n                    return true;\n                } else if (!or && !ruleIncludes) {\n                    // If AND condition; return true on the first condition failure\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Excluding [ {} ] based on [ {}  -> {} ] as part of [ AND ]\",\n                                row.getPath(), operation, entry.getValue());\n                    }\n\n                    return false;\n                }\n            } catch (RepositoryException e) {\n                log.error(\"Unable to check if Node [ {} : {} ] via the nodeExists QueryBuilder predicate\", new String[]{entry.getKey(), entry.getValue()}, e);\n            }\n        }\n\n        if (or) {\n            // For ORs, if a true condition was met in the loop, the method would have already returned true, so must be false.\n            if (log.isDebugEnabled()) {\n                try {\n                    log.debug(\"Excluding [ {} ] based on NOT matching conditions as part of [ OR ]\", row.getPath());\n                } catch (RepositoryException e) {\n                    log.error(\"Could not obtain path from for Result row in predicate evaluator\", e);\n                }\n            }\n            return false;\n        } else {\n            // If ANDs, if a false condition was met in the loop, the method would have already returned false, so must be true.\n            if (log.isDebugEnabled()) {\n                try {\n                    log.debug(\"Include [ {} ] based on ALL matching conditions as part of [ AND ]\", row.getPath());\n                } catch (RepositoryException e) {\n                    log.error(\"Could not obtain path from for Result row in predicate evaluator\", e);\n                }\n            }\n            return true;\n        }\n    }\n}\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\nIn this file:\nudp.cpp\n#include \"blackhole/sink/socket/udp.hpp\"\n\n#include <boost/asio/ip/udp.hpp>\n#include <boost/lexical_cast.hpp>\n\n#include \"blackhole/cpp17/string_view.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace sink {\nnamespace socket {\n\nnamespace udp {\n\nclass inner_t {\npublic:\n    virtual ~inner_t() {}\n    virtual auto write(const string_view& data) -> void = 0;\n};\n\nclass blocking_t : public inner_t {\n    boost::asio::io_service io_service;\n    boost::asio::ip::udp::socket socket;\n    boost::asio::ip::udp::endpoint endpoint;\n\npublic:\n    blocking_t(const std::string& host, std::uint16_t port) :\n        io_service(),\n        socket(io_service)\n    {\n        boost::asio::ip::udp::resolver resolver(io_service);\n        boost::asio::ip::udp::resolver::query query(host, boost::lexical_cast<std::string>(port),\n            boost::asio::ip::udp::resolver::query::flags::numeric_service);\n        endpoint = *resolver.resolve(query);\n    }\n\n    auto write(const string_view& data) -> void {\n        socket.send_to(boost::asio::buffer(data.data(), data.size()), endpoint);\n    }\n};\n\nclass nonblocking_t : public inner_t {\npublic:\n};\n\n}  // namespace udp\n\nudp_t::udp_t(const std::string& host, std::uint16_t port) :\n    inner(new udp::blocking_t(host, port))\n{}\n\nudp_t::~udp_t() = default;\n\nauto udp_t::filter(const record_t&) -> bool {\n    return true;\n}\n\nauto udp_t::emit(const record_t&, const string_view& formatted) -> void {\n    inner->write(formatted);\n}\n\n}  // namespace socket\n}  // namespace sink\n\nauto factory<sink::socket::udp_t>::type() -> const char* {\n    return \"udp\";\n}\n\n}  // namespace v1\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\nIn this file:\njson.cpp\n#include \"blackhole/formatter/json.hpp\"\n\n#include <array>\n#include <set>\n#include <unordered_map>\n\n#include <boost/variant/apply_visitor.hpp>\n\n#ifndef RAPIDJSON_HAS_STDSTRING\n#define RAPIDJSON_HAS_STDSTRING 1\n#endif\n#include <rapidjson/document.h>\n#include <rapidjson/stringbuffer.h>\n#include <rapidjson/writer.h>\n#include <rapidjson/pointer.h>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/record.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\nnamespace {\n\nstruct visitor_t {\n    typedef void result_type;\n\n    rapidjson::Value& node;\n    rapidjson::MemoryPoolAllocator<>& allocator;\n\n    const string_view& name;\n\n    auto operator()(std::nullptr_t) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), rapidjson::kNullType, allocator);\n    }\n\n    // For `bool`, `std::int64_t`, `std::uint64_t` and `double` types.\n    template<typename T>\n    auto operator()(T value) -> void {\n        static_assert(\n            std::is_same<T, bool>::value ||\n            std::is_same<T, std::int64_t>::value ||\n            std::is_same<T, std::uint64_t>::value ||\n            std::is_same<T, double>::value, \"type mismatch\");\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), value, allocator);\n    }\n\n    auto operator()(const string_view& value) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            rapidjson::StringRef(value.data(), value.size()), allocator);\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) -> void {\n        writer_t wr;\n        value(wr);\n\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            wr.result().to_string(), allocator);\n    }\n};\n\n/// A RapidJSON Stream concept implementation required to avoid intermediate buffer allocation.\nstruct stream_t {\n    typedef char Ch;\n\n    writer_t& wr;\n\n    /// Writes a character directly into the underlying buffer.\n    // TODO: Seems like writing string one-by-one affects the performance. See similar benchmarks\n    // that differs only with input string length.\n    auto Put(Ch c) -> void {\n        wr.inner << c;\n    }\n\n    /// Does nothing, because there is no intermediate buffer.\n    auto Flush() -> void {}\n};\n\n}  // namespace\n\nclass json_t::properties_t {\npublic:\n    bool unique;\n    bool newline;\n\n    struct {\n        std::map<std::string, std::vector<std::string>> specified;\n        std::string unspecified;\n    } routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    properties_t() :\n        unique(false),\n        newline(false)\n    {}\n};\n\nclass json_t::inner_t {\n    template<typename> class builder;\n\npublic:\n    // A JSON routing pointer for attributes that weren't mentioned in `routing` map.\n    rapidjson::Pointer rest;\n    // Routing map from attribute name to its JSON pointer.\n    std::map<std::string, rapidjson::Pointer> routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    bool unique;\n\n    inner_t(json_t::properties_t properties) :\n        rest(properties.routing.unspecified),\n        mapping(std::move(properties.mapping)),\n        unique(properties.unique)\n    {\n        for (const auto& route : properties.routing.specified) {\n            for (const auto& name : route.second) {\n                routing.insert({name, rapidjson::Pointer(route.first)});\n            }\n        }\n    }\n\n    template<typename Document>\n    auto get(const string_view& name, Document& root) -> rapidjson::Value& {\n        // TODO: Here we can avoid a temporary string construction by using multi indexed\n        // containers.\n        const auto it = routing.find(name.to_string());\n\n        if (it == routing.end()) {\n            return rest.GetWithDefault(root, rapidjson::kObjectType);\n        } else {\n            return it->second.GetWithDefault(root, rapidjson::kObjectType);\n        }\n    }\n\n    template<typename Document>\n    auto create(Document& root, const record_t& record) -> builder<Document>;\n\n    auto renamed(const string_view& name) const -> string_view {\n        const auto it = mapping.find(name.to_string());\n\n        if (it == mapping.end()) {\n            return name;\n        } else {\n            return it->second;\n        }\n    }\n};\n\ntemplate<typename Document>\nclass json_t::inner_t::builder {\n    Document& root;\n    const record_t& record;\n    inner_t& inner;\n\npublic:\n    builder(Document& root, const record_t& record, inner_t& inner) :\n        root(root),\n        record(record),\n        inner(inner)\n    {}\n\n    auto message() -> void {\n        apply(\"message\", record.message());\n    }\n\n    auto severity() -> void {\n        apply(\"severity\", static_cast<std::int64_t>(record.severity()));\n    }\n\n    auto timestamp() -> void {\n        apply(\"timestamp\", std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(record.timestamp().time_since_epoch()).count());\n    }\n\n    auto build(writer_t& writer) -> void {\n        stream_t stream{writer};\n        rapidjson::Writer<stream_t> wr(stream);\n        root.Accept(wr);\n    }\n\n    auto attributes() -> void {\n        if (inner.unique) {\n            // TODO: Small buffer optimization is possible here (see stack allocator with arena).\n            // TODO: Also consider using `unordered_set` instead. But it requires either manually or\n            // indirectly implementing murmur3 hashing to be fully compatible with the Standard.\n            std::set<string_view> set;\n\n            for (const auto& attributes : record.attributes()) {\n                for (const auto& attribute : attributes.get()) {\n                    if (set.insert(attribute.first).second) {\n                        apply(attribute.first, attribute.second);\n                    }\n                }\n            }\n            return;\n        }\n\n        // TODO: Make flattened range\n        // TODO: Make uniqued range.\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                apply(attribute.first, attribute.second);\n            }\n        }\n    }\n\nprivate:\n    template<typename T>\n    auto apply(const string_view& name, const T& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        visitor(value);\n    }\n\n    auto apply(const string_view& name, const attribute::view_t& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        boost::apply_visitor(visitor, value.inner().value);\n    }\n};\n\ntemplate<typename Document>\nauto json_t::inner_t::create(Document& root, const record_t& record) ->\n    builder<Document>\n{\n    return builder<Document>{root, record, *this};\n}\n\njson_t::json_t() :\n    inner(new inner_t(properties_t()))\n{}\n\njson_t::json_t(properties_t properties) :\n    inner(new inner_t(std::move(properties)))\n{}\n\njson_t::~json_t() {}\n\nauto json_t::format(const record_t& record, writer_t& writer) -> void {\n    typedef rapidjson::GenericDocument<\n        rapidjson::UTF8<>,\n        rapidjson::MemoryPoolAllocator<>,\n        rapidjson::MemoryPoolAllocator<>\n    > document_type;\n\n    std::array<char, 4096> value_buffer;\n    std::array<char, 1024> parse_buffer;\n    rapidjson::MemoryPoolAllocator<> value_allocator(value_buffer.data(), value_buffer.size());\n    rapidjson::MemoryPoolAllocator<> parse_allocator(parse_buffer.data(), parse_buffer.size());\n\n    document_type root(&value_allocator, parse_buffer.size(), &parse_allocator);\n    root.SetObject();\n\n    // TODO: Try to use `AutoUTF<>` or `AutoUTFOutputStream` for UTF-8 validation.\n\n    auto builder = inner->create(root, record);\n    builder.message();\n    builder.severity();\n    builder.timestamp();\n    builder.attributes();\n\n    builder.build(writer);\n\n    // TODO: Add newline if required. Obtained through config.\n    // if (config.newline) {\n    //     writer << '\\n';\n    // }\n}\n\njson_t::builder_t::builder_t() :\n    properties(new properties_t)\n{}\n\njson_t::builder_t::~builder_t() = default;\n\nauto json_t::builder_t::route(std::string route) -> builder_t& {\n    properties->routing.unspecified = std::move(route);\n    return *this;\n}\n\nauto json_t::builder_t::route(std::string route, std::vector<std::string> attributes) -> builder_t& {\n    properties->routing.specified[std::move(route)] = std::move(attributes);\n    return *this;\n}\n\nauto json_t::builder_t::rename(std::string from, std::string to) -> builder_t& {\n    properties->mapping[std::move(from)] = std::move(to);\n    return *this;\n}\n\nauto json_t::builder_t::unique() -> builder_t& {\n    properties->unique = true;\n    return *this;\n}\n\nauto json_t::builder_t::build() const -> json_t {\n    return {std::move(*properties)};\n}\n\n}  // namespace formatter\n}  // namespace v1\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\nFor example:\n\n``` json\n{\n  \"message\":\"stopping {:d} execution unit(s)\",\n  \"severity\":1,\n  \"timestamp\":1454064629638488,\n  \"source\":\"core\"\n}\n```\n\nWhere \"message\" field should be formatted.\n\nIn this file:\njson.cpp\n#include \"blackhole/formatter/json.hpp\"\n\n#include <array>\n#include <set>\n#include <unordered_map>\n\n#include <boost/optional/optional.hpp>\n#include <boost/variant/apply_visitor.hpp>\n\n#ifndef RAPIDJSON_HAS_STDSTRING\n#define RAPIDJSON_HAS_STDSTRING 1\n#endif\n#include <rapidjson/document.h>\n#include <rapidjson/stringbuffer.h>\n#include <rapidjson/writer.h>\n#include <rapidjson/pointer.h>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/record.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\nnamespace {\n\nstruct visitor_t {\n    typedef void result_type;\n\n    rapidjson::Value& node;\n    rapidjson::MemoryPoolAllocator<>& allocator;\n\n    const string_view& name;\n\n    auto operator()(std::nullptr_t) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), rapidjson::kNullType, allocator);\n    }\n\n    // For `bool`, `std::int64_t`, `std::uint64_t` and `double` types.\n    template<typename T>\n    auto operator()(T value) -> void {\n        static_assert(\n            std::is_same<T, bool>::value ||\n            std::is_same<T, std::int64_t>::value ||\n            std::is_same<T, std::uint64_t>::value ||\n            std::is_same<T, double>::value, \"type mismatch\");\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), value, allocator);\n    }\n\n    auto operator()(const string_view& value) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            rapidjson::StringRef(value.data(), value.size()), allocator);\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) -> void {\n        writer_t wr;\n        value(wr);\n\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            wr.result().to_string(), allocator);\n    }\n};\n\n/// A RapidJSON Stream concept implementation required to avoid intermediate buffer allocation.\nstruct stream_t {\n    typedef char Ch;\n\n    writer_t& wr;\n\n    /// Writes a character directly into the underlying buffer.\n    // TODO: Seems like writing string one-by-one affects the performance. See similar benchmarks\n    // that differs only with input string length.\n    auto Put(Ch c) -> void {\n        wr.inner << c;\n    }\n\n    /// Does nothing, because there is no intermediate buffer.\n    auto Flush() -> void {}\n};\n\n}  // namespace\n\nclass json_t::properties_t {\npublic:\n    bool unique;\n    bool newline;\n\n    struct {\n        std::map<std::string, std::vector<std::string>> specified;\n        std::string unspecified;\n    } routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    properties_t() :\n        unique(false),\n        newline(false)\n    {}\n};\n\nclass json_t::inner_t {\n    template<typename> class builder;\n\npublic:\n    // A JSON routing pointer for attributes that weren't mentioned in `routing` map.\n    rapidjson::Pointer rest;\n    // Routing map from attribute name to its JSON pointer.\n    std::map<std::string, rapidjson::Pointer> routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    bool unique;\n\n    inner_t(json_t::properties_t properties) :\n        rest(properties.routing.unspecified),\n        mapping(std::move(properties.mapping)),\n        unique(properties.unique)\n    {\n        for (const auto& route : properties.routing.specified) {\n            for (const auto& name : route.second) {\n                routing.insert({name, rapidjson::Pointer(route.first)});\n            }\n        }\n    }\n\n    template<typename Document>\n    auto get(const string_view& name, Document& root) -> rapidjson::Value& {\n        // TODO: Here we can avoid a temporary string construction by using multi indexed\n        // containers.\n        const auto it = routing.find(name.to_string());\n\n        if (it == routing.end()) {\n            return rest.GetWithDefault(root, rapidjson::kObjectType);\n        } else {\n            return it->second.GetWithDefault(root, rapidjson::kObjectType);\n        }\n    }\n\n    template<typename Document>\n    auto create(Document& root, const record_t& record) -> builder<Document>;\n\n    auto renamed(const string_view& name) const -> string_view {\n        const auto it = mapping.find(name.to_string());\n\n        if (it == mapping.end()) {\n            return name;\n        } else {\n            return it->second;\n        }\n    }\n};\n\ntemplate<typename Document>\nclass json_t::inner_t::builder {\n    Document& root;\n    const record_t& record;\n    inner_t& inner;\n\npublic:\n    builder(Document& root, const record_t& record, inner_t& inner) :\n        root(root),\n        record(record),\n        inner(inner)\n    {}\n\n    auto message() -> void {\n        apply(\"message\", record.message());\n    }\n\n    auto severity() -> void {\n        apply(\"severity\", static_cast<std::int64_t>(record.severity()));\n    }\n\n    auto timestamp() -> void {\n        apply(\"timestamp\", std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(record.timestamp().time_since_epoch()).count());\n    }\n\n    auto build(writer_t& writer) -> void {\n        stream_t stream{writer};\n        rapidjson::Writer<stream_t> wr(stream);\n        root.Accept(wr);\n    }\n\n    auto attributes() -> void {\n        if (inner.unique) {\n            // TODO: Small buffer optimization is possible here (see stack allocator with arena).\n            // TODO: Also consider using `unordered_set` instead. But it requires either manually or\n            // indirectly implementing murmur3 hashing to be fully compatible with the Standard.\n            std::set<string_view> set;\n\n            for (const auto& attributes : record.attributes()) {\n                for (const auto& attribute : attributes.get()) {\n                    if (set.insert(attribute.first).second) {\n                        apply(attribute.first, attribute.second);\n                    }\n                }\n            }\n            return;\n        }\n\n        // TODO: Make flattened range\n        // TODO: Make uniqued range.\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                apply(attribute.first, attribute.second);\n            }\n        }\n    }\n\nprivate:\n    template<typename T>\n    auto apply(const string_view& name, const T& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        visitor(value);\n    }\n\n    auto apply(const string_view& name, const attribute::view_t& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        boost::apply_visitor(visitor, value.inner().value);\n    }\n};\n\ntemplate<typename Document>\nauto json_t::inner_t::create(Document& root, const record_t& record) ->\n    builder<Document>\n{\n    return builder<Document>{root, record, *this};\n}\n\njson_t::json_t() :\n    inner(new inner_t(properties_t()))\n{}\n\njson_t::json_t(properties_t properties) :\n    inner(new inner_t(std::move(properties)))\n{}\n\njson_t::~json_t() {}\n\nauto json_t::format(const record_t& record, writer_t& writer) -> void {\n    typedef rapidjson::GenericDocument<\n        rapidjson::UTF8<>,\n        rapidjson::MemoryPoolAllocator<>,\n        rapidjson::MemoryPoolAllocator<>\n    > document_type;\n\n    std::array<char, 4096> value_buffer;\n    std::array<char, 1024> parse_buffer;\n    rapidjson::MemoryPoolAllocator<> value_allocator(value_buffer.data(), value_buffer.size());\n    rapidjson::MemoryPoolAllocator<> parse_allocator(parse_buffer.data(), parse_buffer.size());\n\n    document_type root(&value_allocator, parse_buffer.size(), &parse_allocator);\n    root.SetObject();\n\n    // TODO: Try to use `AutoUTF<>` or `AutoUTFOutputStream` for UTF-8 validation.\n\n    auto builder = inner->create(root, record);\n    builder.message();\n    builder.severity();\n    builder.timestamp();\n    builder.attributes();\n\n    builder.build(writer);\n\n    // TODO: Add newline if required. Obtained through config.\n    // if (config.newline) {\n    //     writer << '\\n';\n    // }\n}\n\njson_t::builder_t::builder_t() :\n    properties(new properties_t)\n{}\n\njson_t::builder_t::~builder_t() = default;\n\nauto json_t::builder_t::route(std::string route) -> builder_t& {\n    properties->routing.unspecified = std::move(route);\n    return *this;\n}\n\nauto json_t::builder_t::route(std::string route, std::vector<std::string> attributes) -> builder_t& {\n    properties->routing.specified[std::move(route)] = std::move(attributes);\n    return *this;\n}\n\nauto json_t::builder_t::rename(std::string from, std::string to) -> builder_t& {\n    properties->mapping[std::move(from)] = std::move(to);\n    return *this;\n}\n\nauto json_t::builder_t::unique() -> builder_t& {\n    properties->unique = true;\n    return *this;\n}\n\nauto json_t::builder_t::build() const -> json_t {\n    return {std::move(*properties)};\n}\n\n}  // namespace formatter\n\nauto factory<formatter::json_t>::type() noexcept -> const char* {\n    return \"json\";\n}\n\nauto factory<formatter::json_t>::from(const config::node_t& config) -> formatter::json_t {\n    formatter::json_t::builder_t builder;\n\n    if (auto unique = config[\"unique\"].to_bool()) {\n        if (unique.get()) {\n            builder.unique();\n        }\n    }\n\n    if (auto mapping = config[\"mapping\"]) {\n        mapping.each_map([&](const std::string& key, const config::node_t& value) {\n            builder.rename(key, value.to_string());\n        });\n    }\n\n    if (auto routing = config[\"routing\"]) {\n        routing.each_map([&](const std::string& key, const config::node_t& value) {\n            try {\n                // TODO: Probably it's right thing to explicitly check whether the value is string.\n                value.to_string();\n                builder.route(key);\n                return;\n            } catch (const std::logic_error&) {\n                // Eat.\n            }\n\n            std::vector<std::string> attributes;\n            value.each([&](const config::node_t& config) {\n                attributes.emplace_back(config.to_string());\n            });\n            builder.route(key, std::move(attributes));\n        });\n    }\n\n    return builder.build();\n}\n\n}  // namespace v1\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\nTo achieve the possibility of changing string formatter implementation or bug fixes without breaking the ABI it's important to hide that ABI. All other formatters/sinks have already been written in that way.\n\nNote, that this change will break `blackhole::formatter::string_t` API/ABI as it were described in https://github.com/3Hren/blackhole/milestones, but for now it's okay, because nobody uses it explicitly except the Blackhole internals.\n\nIn this file:\nstring.cpp\n#include <benchmark/benchmark.h>\n\n#include <blackhole/attribute.hpp>\n#include <blackhole/attributes.hpp>\n#include <blackhole/cpp17/string_view.hpp>\n#include <blackhole/extensions/writer.hpp>\n#include <blackhole/formatter/string.hpp>\n#include <blackhole/record.hpp>\n\n#include \"mod.hpp\"\n\nnamespace blackhole {\nnamespace benchmark {\n\nstatic void format_literal(::benchmark::State& state) {\n    formatter::string_t formatter(\"message: value\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_pid(::benchmark::State& state) {\n    formatter::string_t formatter(\"{process}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_procname(::benchmark::State& state) {\n    formatter::string_t formatter(\"{process:s}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_tid(::benchmark::State& state) {\n    formatter::string_t formatter(\"{thread}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_message(::benchmark::State& state) {\n    formatter::string_t formatter(\"message: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_timestamp(::benchmark::State& state) {\n    formatter::string_t formatter(\"{timestamp}\");\n\n    const string_view message(\"-\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    record.activate();\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_leftover(::benchmark::State& state) {\n    formatter::string_t formatter(\"{...}\", {\n        {\"...\", formatter::option::leftover_t{false, \"[\", \"]\", \"{k}={v}\", \", \"}}\n    });\n\n    const string_view message(\"-\");\n    const attribute_list attributes{{\"key#1\", {42}}, {\"key#2\", {\"value#2\"}}};\n    const attribute_pack pack{attributes};\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nstatic void format_severity_message(::benchmark::State& state) {\n    formatter::string_t formatter(\"{severity:d}: {message}\");\n\n    const string_view message(\"value\");\n    const attribute_pack pack;\n    record_t record(0, message, pack);\n    writer_t writer;\n\n    while (state.KeepRunning()) {\n        formatter.format(record, writer);\n    }\n\n    state.SetItemsProcessed(state.iterations());\n}\n\nNBENCHMARK(\"formatter.string[lit]\", format_literal);\nNBENCHMARK(\"formatter.string[pid]\", format_pid);\nNBENCHMARK(\"formatter.string[tid]\", format_tid);\nNBENCHMARK(\"formatter.string[procname]\", format_procname);\nNBENCHMARK(\"formatter.string[message]\", format_message);\nNBENCHMARK(\"formatter.string[timestamp]\", format_timestamp);\nNBENCHMARK(\"formatter.string[severity + message]\", format_severity_message);\nNBENCHMARK(\"formatter.string[...]\", format_leftover);\n\n}  // namespace benchmark\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nChecksumGeneratorImpl.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum.impl;\n\nimport com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGenerator;\nimport com.adobe.acs.commons.analysis.jcrchecksum.ChecksumGeneratorOptions;\nimport com.adobe.acs.commons.analysis.jcrchecksum.impl.options.DefaultChecksumGeneratorOptions;\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.jackrabbit.vault.util.Text;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.Node;\nimport javax.jcr.NodeIterator;\nimport javax.jcr.Property;\nimport javax.jcr.PropertyIterator;\nimport javax.jcr.PropertyType;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.Value;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\n/**\n * Utility that generates checksums for JCR paths.  The checksum is calculated using a depth first traversal\n * and calculates an aggregate checksum on the nodes with the specified node types\n * (via {@link ChecksumGeneratorOptions}).\n */\n@Component\n@Service\n@SuppressWarnings(\"squid:S2070\") // SHA1 not used cryptographically\npublic class ChecksumGeneratorImpl implements ChecksumGenerator {\n    private static final Logger log = LoggerFactory.getLogger(ChecksumGeneratorImpl.class);\n\n    /**\n     * Convenience method for  generateChecksums(session, path, new DefaultChecksumGeneratorOptions()).\n     *\n     * @param session the session\n     * @param path tthe root path to generate checksums for\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    public Map<String, String> generateChecksums(Session session, String path) throws RepositoryException,\n            IOException {\n        return generateChecksums(session, path, new DefaultChecksumGeneratorOptions());\n    }\n\n    /**\n     * Traverses the content tree whose root is defined by the path param, respecting the {@link\n     * ChecksumGeneratorOptions}.\n     * Generates map of checksum hashes in the format [ ABSOLUTE PATH ] : [ CHECKSUM OF NODE SYSTEM ]\n     *\n     * @param session the session\n     * @param path the root path to generate checksums for\n     * @param options the {@link ChecksumGeneratorOptions} that define the checksum generation\n     * @return the map of abs path ~&gt; checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    public Map<String, String> generateChecksums(Session session, String path, ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        Node node = session.getNode(path);\n\n        if (node == null) {\n            log.warn(\"Path [ {} ] not found while generating checksums\", path);\n            return new LinkedHashMap<>();\n        }\n\n        return traverseTree(node, options);\n    }\n\n    /**\n     * Traverse the tree for candidate aggregate nodes.\n     * @param node the current node being traversed\n     * @param options the checksum generator options\n     * @return a map of paths and checksums\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    private Map<String, String> traverseTree(Node node, ChecksumGeneratorOptions options) throws\n            RepositoryException,\n            IOException {\n\n        final Map<String, String> checksums = new LinkedHashMap<>();\n\n        if (isExcludedSubTree(node, options)) {\n            return checksums;\n        } else if (isChecksumable(node, options) && !isExcludedNodeName(node, options)) {\n            // Tree-traversal has found a node to checksum (checksum will include all valid sub-tree nodes)\n            final String checksum = generatedNodeChecksum(node.getPath(), node, options);\n            if (checksum != null) {\n                checksums.put(node.getPath(), checksum);\n                log.debug(\"Top Level Node: {} ~> {}\", node.getPath(), checksum);\n            }\n        } else {\n            // Traverse the tree for checksum-able node systems\n            NodeIterator children = node.getNodes();\n\n            while (children.hasNext()) {\n                // Check each child with recursive logic; if child is checksum-able the call into traverseTree will\n                // handle this case\n                checksums.putAll(traverseTree(children.nextNode(), options));\n            }\n        }\n\n        return checksums;\n    }\n\n\n    /**\n     * Ensures the node's primary type is included in the Included Node Types and NOT in the Excluded Node Types and NOT in the Excluded Node Names.\n     *\n     * @param node    the candidate node\n     * @param options the checksum options containing the included and excluded none types\n     * @return true if the node represents a checksum-able node system\n     * @throws RepositoryException\n     */\n    private boolean isChecksumable(Node node, ChecksumGeneratorOptions options) throws RepositoryException {\n        final Set<String> nodeTypeIncludes = options.getIncludedNodeTypes();\n        final Set<String> nodeTypeExcludes = options.getExcludedNodeTypes();\n\n        final String primaryNodeType = node.getPrimaryNodeType().getName();\n\n        return nodeTypeIncludes.contains(primaryNodeType) && !nodeTypeExcludes.contains(primaryNodeType);\n    }\n\n    /**\n     * Generates a checksum for a single node and its node sub-system, respecting the options.\n     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum\n     * @param node the node whose subsystem to create a checksum for\n     * @param options the {@link ChecksumGeneratorOptions} options\n     * @return a map containing 1 entry in the form [ node.getPath() ] : [ CHECKSUM OF NODE SYSTEM ]\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    @SuppressWarnings(\"squid:S3776\")\n    protected String generatedNodeChecksum(final String aggregateNodePath,\n                                                  final Node node,\n                                                  final ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        if (isExcludedSubTree(node, options)) { return \"\"; }\n\n        final Map<String, String> checksums = new LinkedHashMap<>();\n\n        if (!isExcludedNodeName(node, options)) {\n            /* Create checksums for Node's properties */\n            final String checksum = generatePropertyChecksums(aggregateNodePath, node, options);\n            if (checksum != null) {\n                checksums.put(getChecksumKey(aggregateNodePath, node.getPath()), checksum);\n            }\n        }\n\n        /* Then process node's children */\n\n        final Map<String, String> lexicographicallySortedChecksums = new TreeMap<>();\n        final boolean hasOrderedChildren = hasOrderedChildren(node);\n        final NodeIterator children = node.getNodes();\n\n        while (children.hasNext()) {\n            final Node child = children.nextNode();\n\n            if (isExcludedSubTree(child, options)) {\n                // Skip this node!\n            } else if (!isExcludedNodeType(child, options)) {\n                if (hasOrderedChildren) {\n                    // Use the order dictated by the JCR\n                    final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);\n                    if (checksum != null) {\n                        checksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n\n                        log.debug(\"Aggregated Ordered Node: {} ~> {}\",\n                                getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n                    }\n\n                } else {\n                    final String checksum = generatedNodeChecksum(aggregateNodePath, child, options);\n                    if (checksum != null) {\n                        // If order is not dictated by JCR, collect so we can sort later\n                        lexicographicallySortedChecksums.put(getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n\n                        log.debug(\"Aggregated Unordered Node: {} ~> {}\",\n                                getChecksumKey(aggregateNodePath, child.getPath()), checksum);\n                    }\n                }\n            }\n        }\n\n        if (!hasOrderedChildren && lexicographicallySortedChecksums.size() > 0) {\n            // Order is not dictated by JCR, so add the lexicographically sorted entries to the checksums string\n            checksums.putAll(lexicographicallySortedChecksums);\n        }\n\n        final String nodeChecksum = aggregateChecksums(checksums);\n        log.debug(\"Node [ {} ] has a aggregated checksum of [ {} ]\", getChecksumKey(aggregateNodePath, node.getPath()), nodeChecksum);\n\n        return nodeChecksum;\n    }\n\n    /**\n     * Returns a lexicographically sorted map of the [PROPERTY PATH] : [CHECKSUM OF PROPERTIES].\n     * @param aggregateNodePath the absolute path of the node being aggregated into a checksum\n     * @param node  the node to collect and checksum the properties for\n     * @param options the checksum generator options\n     * @return the map of the properties and their checksums\n     * @throws RepositoryException\n     */\n    protected String generatePropertyChecksums(final String aggregateNodePath,\n                                                      final Node node,\n                                                      final ChecksumGeneratorOptions options)\n            throws RepositoryException, IOException {\n\n        SortedMap<String, String> propertyChecksums = new TreeMap<>();\n        PropertyIterator properties = node.getProperties();\n\n        while (properties.hasNext()) {\n            final Property property = properties.nextProperty();\n\n            if (options.getExcludedProperties().contains(property.getName())) {\n                // Skip this property as it is excluded\n                log.debug(\"Excluding property: {}\", node.getPath() + \"/@\" + property.getName());\n                continue;\n            }\n\n            /* Accept the property for checksuming */\n\n            final List<String> checksums = new ArrayList<String>();\n\n            final List<Value> values = getPropertyValues(property);\n\n            for (final Value value : values) {\n                if (value.getType() == PropertyType.BINARY) {\n                    checksums.add(getBinaryChecksum(value));\n                } else {\n                    checksums.add(getStringChecksum(value));\n                }\n            }\n\n            if (!options.getSortedProperties().contains(property.getName())) {\n                Collections.sort(checksums);\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Property: {} ~> {}\",\n                        getChecksumKey(aggregateNodePath, property.getPath()),\n                        StringUtils.join(checksums, \",\"));\n            }\n\n            propertyChecksums.put(getChecksumKey(aggregateNodePath, property.getPath()),\n                    StringUtils.join(checksums, \",\"));\n        }\n\n        return aggregateChecksums(propertyChecksums);\n    }\n\n\n    /**\n     * Generates the relative key used for tracking nodes and properties.\n     * @param aggregatePath the absolute path of the node being aggregated.\n     * @param path the path of the item being checksumed\n     * @return the key\n     */\n    protected String getChecksumKey(String aggregatePath, String path) {\n        if (\"/\".equals(aggregatePath) && \"/\".equals(path)) {\n            return \"/\";\n        } else if (\"/\".equals(aggregatePath)) {\n            return path;\n        }\n\n        String baseNodeName = Text.getName(aggregatePath);\n        String relPath = StringUtils.removeStart(path, aggregatePath);\n\n        return baseNodeName + relPath;\n    }\n\n    /**\n     * Normalizes a property values to a list; allows single and multi-values to be treated the same in code.\n     * @param property the propert to get the value(s) from\n     * @return a list of the property's value(s)\n     * @throws RepositoryException\n     */\n    private List<Value> getPropertyValues(final Property property) throws RepositoryException {\n        final List<Value> values = new ArrayList<>();\n\n        if (property.isMultiple()) {\n            values.addAll(Arrays.asList(property.getValues()));\n        } else {\n            values.add(property.getValue());\n        }\n\n        return values;\n    }\n\n    /**\n     * Gets the checksum for a Binary value.\n     * @param value the Value\n     * @return the checksum\n     * @throws RepositoryException\n     * @throws IOException\n     */\n    protected String getBinaryChecksum(final Value value) throws RepositoryException, IOException {\n        InputStream stream = null;\n\n        try {\n            stream = value.getBinary().getStream();\n            return DigestUtils.sha1Hex(stream);\n        } finally {\n            if (stream != null) {\n                stream.close();\n            }\n        }\n    }\n\n    /**\n     * Gets the checksum for a String value.\n     * @param value the Value\n     * @return the checksum\n     * @throws RepositoryException\n     */\n    protected static String getStringChecksum(final Value value) throws RepositoryException {\n        return DigestUtils.sha1Hex(value.getString());\n    }\n\n    /**\n     * Checks if node has ordered children.\n     * @param node the node\n     * @return true if the node has ordered children\n     * @throws RepositoryException\n     */\n    protected boolean hasOrderedChildren(final Node node) throws RepositoryException {\n        boolean hasOrderedChildren = false;\n\n        try {\n            hasOrderedChildren = node.getPrimaryNodeType().hasOrderableChildNodes();\n        } catch (UnsupportedOperationException e) {\n            // This is an exception thrown in the test scenarios using the Mock JCR API\n            // This would not happen using the actual JCR APIs\n            // Allow other exceptions to be thrown and break processing normally\n        }\n\n        return hasOrderedChildren;\n    }\n\n    /**\n     * Aggregates a set of checksum entries into a single checksum value.\n     * @param checksums the checksums\n     * @return the checksum value\n     */\n    protected String aggregateChecksums(final Map<String, String> checksums) {\n        if (checksums.isEmpty()) { return null; }\n\n        StringBuilder data = new StringBuilder();\n\n        for (Map.Entry<String, String> entry : checksums.entrySet()) {\n            data.append(entry.getKey() + \"=\" + entry.getValue());\n        }\n\n        return DigestUtils.sha1Hex(data.toString());\n    }\n\n    protected boolean isExcludedSubTree(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        for (String exclude : options.getExcludedSubTrees()) {\n            if (isPathFragmentMatch(node, exclude)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    protected boolean isExcludedNodeName(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        for (String exclude : options.getExcludedNodeNames()) {\n            if (isPathFragmentMatch(node, exclude)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    protected boolean isExcludedNodeType(final Node node, final ChecksumGeneratorOptions options) throws RepositoryException {\n        return options.getExcludedNodeTypes().contains(node.getPrimaryNodeType().getName());\n    }\n\n    private boolean isPathFragmentMatch(final Node node, final String fragmentPath) throws RepositoryException {\n        final List<String> fragments = Arrays.asList(StringUtils.split(fragmentPath, \"/\"));\n\n        Collections.reverse(fragments);\n\n        Node current = node;\n        for (String fragment : fragments) {\n\n            fragment = StringUtils.stripToNull(fragment);\n\n            if (current == null) {\n                return false;\n            } else if (StringUtils.startsWith(fragment,\"[\") && StringUtils.endsWith(fragment, \"]\")) {\n                final String nodeType = StringUtils.stripToEmpty(StringUtils.substringBetween(fragment, \"[\", \"]\"));\n\n                if (!current.isNodeType(nodeType)) {\n                    return false;\n                }\n            } else {\n                if (!StringUtils.equals(fragment, current.getName())) {\n                    return false;\n                }\n            }\n\n            current = current.getParent();\n        }\n\n        return true;\n    }\n}\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nAuditLogSearchServlet.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.adobe.acs.commons.audit_log_search.impl;\n\nimport com.adobe.acs.commons.audit_log_search.AuditLogSearchRequest;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonPrimitive;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.felix.scr.annotations.sling.SlingServlet;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.SlingHttpServletResponse;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.api.resource.ValueMap;\nimport org.apache.sling.api.servlets.HttpConstants;\nimport org.apache.sling.api.servlets.SlingSafeMethodsServlet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.jcr.NodeIterator;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.query.Query;\nimport javax.jcr.query.QueryManager;\nimport javax.servlet.ServletException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.text.ParseException;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@SlingServlet(\n        methods = {HttpConstants.METHOD_GET},\n        resourceTypes = {\"acs-commons/components/utilities/audit-log-search\"},\n        selectors = {\"auditlogsearch\"},\n        extensions = {\"json\"})\n@SuppressWarnings(\"serial\")\npublic class AuditLogSearchServlet extends SlingSafeMethodsServlet {\n\n    private static final Logger log = LoggerFactory.getLogger(AuditLogSearchServlet.class);\n\n    @Override\n    @SuppressWarnings(\"squid:S1141\")\n    protected final void doGet(SlingHttpServletRequest request, SlingHttpServletResponse response)\n            throws ServletException, IOException {\n\n        log.trace(\"doGet\");\n\n        AuditLogSearchRequest req = null;\n\n        JsonObject result = new JsonObject();\n        boolean succeeded = true;\n        try {\n            req = new AuditLogSearchRequest(request);\n            log.debug(\"Loaded search request: {}\", req);\n\n            JsonArray results = new JsonArray();\n            long count = 0;\n            String whereClause = req.getQueryParameters();\n            StringBuilder queryBuilder = new StringBuilder(\"SELECT * FROM [cq:AuditEvent] AS s\");\n            if (StringUtils.isNotEmpty(whereClause)) {\n                queryBuilder.append(\" WHERE \").append(whereClause);\n            }\n            String queryStr = queryBuilder.toString();\n            log.debug(\"Finding audit events with: {}\", queryStr);\n            ResourceResolver resolver = request.getResourceResolver();\n            QueryManager queryManager = resolver.adaptTo(Session.class).getWorkspace().getQueryManager();\n            Query query = queryManager.createQuery(queryStr, Query.JCR_SQL2);\n\n            int limit = -1;\n            if (StringUtils.isNotEmpty(request.getParameter(\"limit\"))) {\n                limit = Integer.parseInt(request.getParameter(\"limit\"), 10);\n                if (limit > 0) {\n                    log.debug(\"Limiting to {} results\", limit);\n                    query.setLimit(limit);\n                }\n            }\n\n            NodeIterator nodes = query.execute().getNodes();\n            log.debug(\"Query execution complete!\");\n            while (nodes.hasNext()) {\n                results.add(serializeAuditEvent(resolver.getResource(nodes.nextNode().getPath()), req));\n                count++;\n            }\n            result.addProperty(\"count\", count);\n            result.add(\"events\", results);\n            log.debug(\"Found {} audit events\", count);\n        } catch (ParseException e) {\n            log.warn(\"Encountered exception parsing start / end date\", e);\n            succeeded = false;\n        } catch (RepositoryException e) {\n            log.warn(\"Encountered respository exception attempting to retrieve audit events\", e);\n            succeeded = false;\n        } catch (ClassNotFoundException e) {\n            log.warn(\"Encountered exception deserializing attributes\", e);\n            succeeded = false;\n        }\n\n        result.addProperty(\"succeeded\", succeeded);\n\n        response.setContentType(\"application/json\");\n        response.getWriter().write(result.toString());\n    }\n\n    private JsonObject serializeAuditEvent(Resource auditEventResource, AuditLogSearchRequest request)\n            throws RepositoryException, IOException, ClassNotFoundException {\n        JsonObject auditEvent = new JsonObject();\n        ValueMap properties = auditEventResource.getValueMap();\n        auditEvent.addProperty(\"category\", properties.get(\"cq:category\", String.class));\n        auditEvent.addProperty(\"eventPath\", auditEventResource.getPath());\n        auditEvent.addProperty(\"path\", properties.get(\"cq:path\", String.class));\n        auditEvent.addProperty(\"type\", properties.get(\"cq:type\", String.class));\n        String userId = properties.get(\"cq:userid\", String.class);\n        auditEvent.addProperty(\"userId\", userId);\n        auditEvent.addProperty(\"userName\", request.getUserName(auditEventResource.getResourceResolver(), userId));\n        auditEvent.addProperty(\"userPath\", request.getUserPath(auditEventResource.getResourceResolver(), userId));\n        auditEvent.addProperty(\"time\", properties.get(\"cq:time\", new Date()).getTime());\n\n        JsonArray modified = getModifiedProperties(properties);\n        if (properties.get(\"above\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"above=\" + properties.get(\"above\", String.class)));\n        }\n        if (properties.get(\"destination\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"destination=\" + properties.get(\"destination\", String.class)));\n        }\n        if (properties.get(\"versionId\", String.class) != null) {\n            modified.add(new JsonPrimitive(\"versionId=\" + properties.get(\"versionId\", String.class)));\n        }\n        if (modified.size() != 0) {\n            auditEvent.add(\"modified\", modified);\n        }\n\n        return auditEvent;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private JsonArray getModifiedProperties(ValueMap properties) throws IOException {\n        JsonArray modifiedProperties = new JsonArray();\n        InputStream is = properties.get(\"cq:properties\", InputStream.class);\n        if (is != null) {\n            ObjectInputStream ois = new ObjectInputStream(is);\n            ois.readInt();\n\n            while (ois.available() != -1) {\n                try {\n                    Object obj = ois.readObject();\n                    if (obj instanceof HashSet) {\n                        Set<String> propertiesSet = (Set<String>) obj;\n                        for (String property : propertiesSet) {\n                            modifiedProperties.add(new JsonPrimitive(property));\n                        }\n                        break;\n                    }\n                } catch (Exception e) {\n                    break;\n                }\n            }\n        }\n        return modifiedProperties;\n    }\n\n}\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\nIn this file:\njson.cpp\n#include \"blackhole/formatter/json.hpp\"\n\n#include <array>\n#include <set>\n#include <unordered_map>\n\n#include <boost/optional/optional.hpp>\n#include <boost/variant/apply_visitor.hpp>\n\n#ifndef RAPIDJSON_HAS_STDSTRING\n#define RAPIDJSON_HAS_STDSTRING 1\n#endif\n#include <rapidjson/document.h>\n#include <rapidjson/stringbuffer.h>\n#include <rapidjson/writer.h>\n#include <rapidjson/pointer.h>\n\n#include \"blackhole/attribute.hpp\"\n#include \"blackhole/config/node.hpp\"\n#include \"blackhole/config/option.hpp\"\n#include \"blackhole/record.hpp\"\n#include \"blackhole/extensions/writer.hpp\"\n\n#include \"blackhole/detail/attribute.hpp\"\n\nnamespace blackhole {\ninline namespace v1 {\nnamespace formatter {\nnamespace {\n\nstruct visitor_t {\n    typedef void result_type;\n\n    rapidjson::Value& node;\n    rapidjson::MemoryPoolAllocator<>& allocator;\n\n    const string_view& name;\n\n    auto operator()(std::nullptr_t) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), rapidjson::kNullType, allocator);\n    }\n\n    // For `bool`, `std::int64_t`, `std::uint64_t` and `double` types.\n    template<typename T>\n    auto operator()(T value) -> void {\n        static_assert(\n            std::is_same<T, bool>::value ||\n            std::is_same<T, std::int64_t>::value ||\n            std::is_same<T, std::uint64_t>::value ||\n            std::is_same<T, double>::value, \"type mismatch\");\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()), value, allocator);\n    }\n\n    auto operator()(const string_view& value) -> void {\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            rapidjson::StringRef(value.data(), value.size()), allocator);\n    }\n\n    auto operator()(const attribute::view_t::function_type& value) -> void {\n        writer_t wr;\n        value(wr);\n\n        node.AddMember(rapidjson::StringRef(name.data(), name.size()),\n            wr.result().to_string(), allocator);\n    }\n};\n\n/// A RapidJSON Stream concept implementation required to avoid intermediate buffer allocation.\nstruct stream_t {\n    typedef char Ch;\n\n    writer_t& wr;\n\n    /// Writes a character directly into the underlying buffer.\n    // TODO: Seems like writing string one-by-one affects the performance. See similar benchmarks\n    // that differs only with input string length.\n    auto Put(Ch c) -> void {\n        wr.inner << c;\n    }\n\n    /// Does nothing, because there is no intermediate buffer.\n    auto Flush() -> void {}\n};\n\n}  // namespace\n\nclass json_t::properties_t {\npublic:\n    bool unique;\n    bool newline;\n\n    struct {\n        std::map<std::string, std::vector<std::string>> specified;\n        std::string unspecified;\n    } routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    properties_t() :\n        unique(false),\n        newline(false)\n    {}\n};\n\nclass json_t::inner_t {\n    template<typename> class builder;\n\npublic:\n    // A JSON routing pointer for attributes that weren't mentioned in `routing` map.\n    rapidjson::Pointer rest;\n    // Routing map from attribute name to its JSON pointer.\n    std::map<std::string, rapidjson::Pointer> routing;\n\n    std::unordered_map<std::string, std::string> mapping;\n\n    bool unique;\n\n    inner_t(json_t::properties_t properties) :\n        rest(properties.routing.unspecified),\n        mapping(std::move(properties.mapping)),\n        unique(properties.unique)\n    {\n        for (const auto& route : properties.routing.specified) {\n            for (const auto& name : route.second) {\n                routing.insert({name, rapidjson::Pointer(route.first)});\n            }\n        }\n    }\n\n    template<typename Document>\n    auto get(const string_view& name, Document& root) -> rapidjson::Value& {\n        // TODO: Here we can avoid a temporary string construction by using multi indexed\n        // containers.\n        const auto it = routing.find(name.to_string());\n\n        if (it == routing.end()) {\n            return rest.GetWithDefault(root, rapidjson::kObjectType);\n        } else {\n            return it->second.GetWithDefault(root, rapidjson::kObjectType);\n        }\n    }\n\n    template<typename Document>\n    auto create(Document& root, const record_t& record) -> builder<Document>;\n\n    auto renamed(const string_view& name) const -> string_view {\n        const auto it = mapping.find(name.to_string());\n\n        if (it == mapping.end()) {\n            return name;\n        } else {\n            return it->second;\n        }\n    }\n};\n\ntemplate<typename Document>\nclass json_t::inner_t::builder {\n    Document& root;\n    const record_t& record;\n    inner_t& inner;\n\npublic:\n    builder(Document& root, const record_t& record, inner_t& inner) :\n        root(root),\n        record(record),\n        inner(inner)\n    {}\n\n    auto message() -> void {\n        apply(\"message\", record.formatted());\n    }\n\n    auto severity() -> void {\n        apply(\"severity\", static_cast<std::int64_t>(record.severity()));\n    }\n\n    auto timestamp() -> void {\n        apply(\"timestamp\", std::chrono::duration_cast<\n            std::chrono::microseconds\n        >(record.timestamp().time_since_epoch()).count());\n    }\n\n    auto build(writer_t& writer) -> void {\n        stream_t stream{writer};\n        rapidjson::Writer<stream_t> wr(stream);\n        root.Accept(wr);\n    }\n\n    auto attributes() -> void {\n        if (inner.unique) {\n            // TODO: Small buffer optimization is possible here (see stack allocator with arena).\n            // TODO: Also consider using `unordered_set` instead. But it requires either manually or\n            // indirectly implementing murmur3 hashing to be fully compatible with the Standard.\n            std::set<string_view> set;\n\n            for (const auto& attributes : record.attributes()) {\n                for (const auto& attribute : attributes.get()) {\n                    if (set.insert(attribute.first).second) {\n                        apply(attribute.first, attribute.second);\n                    }\n                }\n            }\n            return;\n        }\n\n        // TODO: Make flattened range\n        // TODO: Make uniqued range.\n        for (const auto& attributes : record.attributes()) {\n            for (const auto& attribute : attributes.get()) {\n                apply(attribute.first, attribute.second);\n            }\n        }\n    }\n\nprivate:\n    template<typename T>\n    auto apply(const string_view& name, const T& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        visitor(value);\n    }\n\n    auto apply(const string_view& name, const attribute::view_t& value) -> void {\n        const auto renamed = inner.renamed(name);\n        visitor_t visitor{inner.get(name, root), root.GetAllocator(), renamed};\n        boost::apply_visitor(visitor, value.inner().value);\n    }\n};\n\ntemplate<typename Document>\nauto json_t::inner_t::create(Document& root, const record_t& record) ->\n    builder<Document>\n{\n    return builder<Document>{root, record, *this};\n}\n\njson_t::json_t() :\n    inner(new inner_t(properties_t()))\n{}\n\njson_t::json_t(properties_t properties) :\n    inner(new inner_t(std::move(properties)))\n{}\n\njson_t::~json_t() {}\n\nauto json_t::format(const record_t& record, writer_t& writer) -> void {\n    typedef rapidjson::GenericDocument<\n        rapidjson::UTF8<>,\n        rapidjson::MemoryPoolAllocator<>,\n        rapidjson::MemoryPoolAllocator<>\n    > document_type;\n\n    std::array<char, 4096> value_buffer;\n    std::array<char, 1024> parse_buffer;\n    rapidjson::MemoryPoolAllocator<> value_allocator(value_buffer.data(), value_buffer.size());\n    rapidjson::MemoryPoolAllocator<> parse_allocator(parse_buffer.data(), parse_buffer.size());\n\n    document_type root(&value_allocator, parse_buffer.size(), &parse_allocator);\n    root.SetObject();\n\n    // TODO: Try to use `AutoUTF<>` or `AutoUTFOutputStream` for UTF-8 validation.\n\n    auto builder = inner->create(root, record);\n    builder.message();\n    builder.severity();\n    builder.timestamp();\n    builder.attributes();\n\n    builder.build(writer);\n\n    // TODO: Add newline if required. Obtained through config.\n    // if (config.newline) {\n    //     writer << '\\n';\n    // }\n}\n\njson_t::builder_t::builder_t() :\n    properties(new properties_t)\n{}\n\njson_t::builder_t::~builder_t() = default;\n\nauto json_t::builder_t::route(std::string route) -> builder_t& {\n    properties->routing.unspecified = std::move(route);\n    return *this;\n}\n\nauto json_t::builder_t::route(std::string route, std::vector<std::string> attributes) -> builder_t& {\n    properties->routing.specified[std::move(route)] = std::move(attributes);\n    return *this;\n}\n\nauto json_t::builder_t::rename(std::string from, std::string to) -> builder_t& {\n    properties->mapping[std::move(from)] = std::move(to);\n    return *this;\n}\n\nauto json_t::builder_t::unique() -> builder_t& {\n    properties->unique = true;\n    return *this;\n}\n\nauto json_t::builder_t::build() const -> json_t {\n    return {std::move(*properties)};\n}\n\n}  // namespace formatter\n\nauto factory<formatter::json_t>::type() noexcept -> const char* {\n    return \"json\";\n}\n\nauto factory<formatter::json_t>::from(const config::node_t& config) -> formatter::json_t {\n    formatter::json_t::builder_t builder;\n\n    if (auto unique = config[\"unique\"].to_bool()) {\n        if (unique.get()) {\n            builder.unique();\n        }\n    }\n\n    if (auto mapping = config[\"mapping\"]) {\n        mapping.each_map([&](const std::string& key, const config::node_t& value) {\n            builder.rename(key, value.to_string());\n        });\n    }\n\n    if (auto routing = config[\"routing\"]) {\n        routing.each_map([&](const std::string& key, const config::node_t& value) {\n            try {\n                // TODO: Probably it's right thing to explicitly check whether the value is string.\n                value.to_string();\n                builder.route(key);\n                return;\n            } catch (const std::logic_error&) {\n                // Eat.\n            }\n\n            std::vector<std::string> attributes;\n            value.each([&](const config::node_t& config) {\n                attributes.emplace_back(config.to_string());\n            });\n            builder.route(key, std::move(attributes));\n        });\n    }\n\n    return builder.build();\n}\n\n}  // namespace v1\n}  // namespace blackhole\n\n",
  "You are a software engineer developer and need to resolve the following issue, give me the solved code between <code></code> and create a main function between <main></main> to test the code:\n\r\nApache commons lang 2 is not maintained anymore since years. Usage of it should be replaced with Apache Commons Lang 3. Both libraries are part of AEM as a Cloud Service and AEM 6.x, only a change of the imports is required.\r\n\r\nThere is one exception, the usage of AEMs MailTemplate API which currently does not provide an alternative. Once that is available we can change the last remaining usage of Apache commons lang 2.\r\n\r\n\r\n\r\n\nIn this file:\nRequestChecksumGeneratorOptions.java\n/*\n * ACS AEM Commons\n *\n * Copyright (C) 2013 - 2023 Adobe\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.adobe.acs.commons.analysis.jcrchecksum.impl.options;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.request.RequestParameter;\nimport org.apache.sling.api.resource.Resource;\nimport org.apache.sling.api.resource.ResourceResolver;\n\nimport org.osgi.annotation.versioning.ProviderType;\n\n@ProviderType\npublic class RequestChecksumGeneratorOptions extends AbstractChecksumGeneratorOptions {\n\n    public RequestChecksumGeneratorOptions(SlingHttpServletRequest request)  {\n        this.addIncludedNodeTypes(request.getParameterValues(NODES_TYPES));\n        this.addExcludedNodeTypes(request.getParameterValues(NODE_TYPE_EXCLUDES));\n        this.addExcludedProperties(request.getParameterValues(PROPERTY_EXCLUDES));\n        this.addSortedProperties(request.getParameterValues(SORTED_PROPERTIES));\n    }\n\n    public static Set<String> getPaths(SlingHttpServletRequest request) throws IOException {\n        Set<String> paths = new HashSet<>();\n\n        // Add Paths\n\n        if (request.getParameterValues(PATHS) != null) {\n            String[] pathArr = request.getParameterValues(PATHS);\n            for (String path : pathArr) {\n                if (path.length() > 0) {\n                    paths.add(path);\n                }\n            }\n        }\n\n        paths.addAll(getPathsFromQuery(request.getResourceResolver(),\n                request.getParameter(QUERY_TYPE),\n                request.getParameter(QUERY)));\n\n        RequestParameter data = request.getRequestParameter(DATA);\n        if (data != null && data.getInputStream() != null) {\n            paths.addAll(getPathsFromInputstream(data.getInputStream(), request.getCharacterEncoding()));\n        }\n\n        return paths;\n    }\n\n    private static Set<String> getPathsFromQuery(ResourceResolver resourceResolver, String language, String query) {\n        if (StringUtils.isBlank(query)) {\n            return Collections.emptySet();\n        }\n\n        Set<String> paths = new HashSet<>();\n        language = StringUtils.defaultIfEmpty(language, \"xpath\");\n        Iterator<Resource> resources = resourceResolver.findResources(query, language);\n\n        while (resources.hasNext()) {\n            paths.add(resources.next().getPath());\n        }\n\n        return paths;\n    }\n\n    private static Set<String> getPathsFromInputstream(InputStream is, String encoding) throws IOException {\n        if (is == null) {\n            return Collections.emptySet();\n        }\n\n        Set<String> paths = new HashSet<>();\n        encoding = (encoding != null) ?  encoding : Charset.defaultCharset().name();\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(is, encoding))) {\n            String path;\n            while ((path = br.readLine()) != null) {\n                paths.add(path);\n            }\n        }\n\n        return paths;\n    }\n}\n"
]